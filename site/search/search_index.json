{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Audiometer Documentation","text":"<p>Welcome to the Audiometer documentation!</p>"},{"location":"#sections","title":"Sections","text":"<ul> <li>User Guide</li> <li>Reference Manual</li> <li>About</li> </ul>"},{"location":"api/audio_player/","title":"audio_player Module","text":""},{"location":"api/audio_player/#app.audio_player.AudioPlayer","title":"<code>AudioPlayer</code>","text":"Source code in <code>app\\audio_player.py</code> <pre><code>class AudioPlayer:\n\n    def __init__(self):\n        \"\"\"An audio player that can play sine beeps at various frequencies, volumes and with various durations.\n        Automatically detects current samplerate of selected sound device.\n        \"\"\"\n        self.fs = self.get_device_samplerate()\n        self.beep_duration = 10\n        self.volume = 0.5\n        self.frequency = 440\n        self.stream = None\n        self.is_playing = False\n\n    def generate_tone(self):\n        \"\"\"generates a sine tone with current audio player settings\n\n        Returns:\n            np.array: sine wave as numpy array\n        \"\"\"\n        t = np.linspace(start=0, \n                        stop=self.beep_duration, \n                        num=int(self.fs * self.beep_duration), \n                        endpoint=False)\n        tone = np.sin(2 * np.pi * self.frequency * t) * self.volume\n        return tone\n\n    def play_beep(self, frequency, volume, duration, channel='lr'):\n        \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters\n\n        Args:\n            frequency (int): f in Hz\n            volume (float): volume multiplier (between 0 and 1)\n            duration (int): duration of beep in seconds\n            channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively\n        \"\"\"\n        self.frequency = frequency\n        self.volume = volume\n        self.beep_duration = duration\n        tone = self.generate_tone()\n        if channel == 'l':\n            sd.play(np.array([tone, np.zeros(len(tone))]).T, self.fs)\n        elif channel == 'r':\n            sd.play(np.array([np.zeros(len(tone)), tone]).T, self.fs)\n        else:\n            sd.play(tone, self.fs)\n\n    def stop(self):\n        \"\"\"Stops the current playback\n        \"\"\"\n        sd.stop()\n\n\n    def int_or_str(self, text):\n        \"\"\"Helper function for argument parsing.\"\"\"\n        try:\n            return int(text)\n        except ValueError:\n            return text\n\n\n    def get_device_samplerate(self):\n        \"\"\"gets current samplerate from the selected audio output device\n\n        Returns:\n            float: samplerate of current sound device\n        \"\"\"\n        parser = argparse.ArgumentParser(add_help=False)\n        parser.add_argument(\n            '-l', '--list-devices', action='store_true',\n            help='show list of audio devices and exit')\n        args, remaining = parser.parse_known_args()\n        if args.list_devices:\n            print(sd.query_devices())\n            parser.exit(0)\n        parser = argparse.ArgumentParser(\n            description=__doc__,\n            formatter_class=argparse.RawDescriptionHelpFormatter,\n            parents=[parser])\n        parser.add_argument(\n            'frequency', nargs='?', metavar='FREQUENCY', type=float, default=500,\n            help='frequency in Hz (default: %(default)s)')\n        parser.add_argument(\n            '-d', '--device', type=self.int_or_str,\n            help='output device (numeric ID or substring)')\n        parser.add_argument(\n            '-a', '--amplitude', type=float, default=0.2,\n            help='amplitude (default: %(default)s)')\n        args = parser.parse_args(remaining)\n        return sd.query_devices(args.device, 'output')['default_samplerate']\n</code></pre>"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.__init__","title":"<code>__init__()</code>","text":"<p>An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device.</p> Source code in <code>app\\audio_player.py</code> <pre><code>def __init__(self):\n    \"\"\"An audio player that can play sine beeps at various frequencies, volumes and with various durations.\n    Automatically detects current samplerate of selected sound device.\n    \"\"\"\n    self.fs = self.get_device_samplerate()\n    self.beep_duration = 10\n    self.volume = 0.5\n    self.frequency = 440\n    self.stream = None\n    self.is_playing = False\n</code></pre>"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.generate_tone","title":"<code>generate_tone()</code>","text":"<p>generates a sine tone with current audio player settings</p> <p>Returns:</p> Type Description <p>np.array: sine wave as numpy array</p> Source code in <code>app\\audio_player.py</code> <pre><code>def generate_tone(self):\n    \"\"\"generates a sine tone with current audio player settings\n\n    Returns:\n        np.array: sine wave as numpy array\n    \"\"\"\n    t = np.linspace(start=0, \n                    stop=self.beep_duration, \n                    num=int(self.fs * self.beep_duration), \n                    endpoint=False)\n    tone = np.sin(2 * np.pi * self.frequency * t) * self.volume\n    return tone\n</code></pre>"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.get_device_samplerate","title":"<code>get_device_samplerate()</code>","text":"<p>gets current samplerate from the selected audio output device</p> <p>Returns:</p> Name Type Description <code>float</code> <p>samplerate of current sound device</p> Source code in <code>app\\audio_player.py</code> <pre><code>def get_device_samplerate(self):\n    \"\"\"gets current samplerate from the selected audio output device\n\n    Returns:\n        float: samplerate of current sound device\n    \"\"\"\n    parser = argparse.ArgumentParser(add_help=False)\n    parser.add_argument(\n        '-l', '--list-devices', action='store_true',\n        help='show list of audio devices and exit')\n    args, remaining = parser.parse_known_args()\n    if args.list_devices:\n        print(sd.query_devices())\n        parser.exit(0)\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        parents=[parser])\n    parser.add_argument(\n        'frequency', nargs='?', metavar='FREQUENCY', type=float, default=500,\n        help='frequency in Hz (default: %(default)s)')\n    parser.add_argument(\n        '-d', '--device', type=self.int_or_str,\n        help='output device (numeric ID or substring)')\n    parser.add_argument(\n        '-a', '--amplitude', type=float, default=0.2,\n        help='amplitude (default: %(default)s)')\n    args = parser.parse_args(remaining)\n    return sd.query_devices(args.device, 'output')['default_samplerate']\n</code></pre>"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.int_or_str","title":"<code>int_or_str(text)</code>","text":"<p>Helper function for argument parsing.</p> Source code in <code>app\\audio_player.py</code> <pre><code>def int_or_str(self, text):\n    \"\"\"Helper function for argument parsing.\"\"\"\n    try:\n        return int(text)\n    except ValueError:\n        return text\n</code></pre>"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.play_beep","title":"<code>play_beep(frequency, volume, duration, channel='lr')</code>","text":"<p>Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>int</code> <p>f in Hz</p> required <code>volume</code> <code>float</code> <p>volume multiplier (between 0 and 1)</p> required <code>duration</code> <code>int</code> <p>duration of beep in seconds</p> required <code>channel</code> <code>string</code> <p>'l', 'r' or 'lr' for only left, only right or both channels respectively</p> <code>'lr'</code> Source code in <code>app\\audio_player.py</code> <pre><code>def play_beep(self, frequency, volume, duration, channel='lr'):\n    \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters\n\n    Args:\n        frequency (int): f in Hz\n        volume (float): volume multiplier (between 0 and 1)\n        duration (int): duration of beep in seconds\n        channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively\n    \"\"\"\n    self.frequency = frequency\n    self.volume = volume\n    self.beep_duration = duration\n    tone = self.generate_tone()\n    if channel == 'l':\n        sd.play(np.array([tone, np.zeros(len(tone))]).T, self.fs)\n    elif channel == 'r':\n        sd.play(np.array([np.zeros(len(tone)), tone]).T, self.fs)\n    else:\n        sd.play(tone, self.fs)\n</code></pre>"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.stop","title":"<code>stop()</code>","text":"<p>Stops the current playback</p> Source code in <code>app\\audio_player.py</code> <pre><code>def stop(self):\n    \"\"\"Stops the current playback\n    \"\"\"\n    sd.stop()\n</code></pre>"},{"location":"api/audiogram/","title":"audiogram Module","text":""},{"location":"api/audiogram/#app.audiogram.create_audiogram","title":"<code>create_audiogram(freqs, right_values, left_values, bi_values=None, save=False)</code>","text":"<p>Erstellt ein Audiogramm basierend auf den gegebenen Frequenzen und H\u00f6rschwellenwerten.</p> <p>Parameters:</p> Name Type Description Default <code>freqs</code> <code>list of int</code> <p>Eine Liste von Frequenzen in Hertz.</p> required <code>right_values</code> <code>list of int</code> <p>Eine Liste von H\u00f6rschwellen in dB HL vom rechten Ohr.</p> required <code>left_values</code> <code>list of int</code> <p>Eine Liste von H\u00f6rschwellen in dB HL vom linken Ohr</p> required Source code in <code>app\\audiogram.py</code> <pre><code>def create_audiogram(freqs, right_values, left_values, bi_values=None, save=False):\n    \"\"\"Erstellt ein Audiogramm basierend auf den gegebenen Frequenzen und H\u00f6rschwellenwerten.\n\n    Args:\n        freqs (list of int): Eine Liste von Frequenzen in Hertz.\n        right_values (list of int): Eine Liste von H\u00f6rschwellen in dB HL vom rechten Ohr.\n        left_values (list of int): Eine Liste von H\u00f6rschwellen in dB HL vom linken Ohr\n\n    \"\"\"\n\n    #TODO save figure\n    fig, ax = plt.subplots(figsize=(5, 4))\n\n    # Bereichsfarben hinzuf\u00fcgen\n    ax.axhspan(-10, 20, facecolor='lightgreen', alpha=0.3)\n    ax.axhspan(20, 40, facecolor='lightskyblue', alpha=0.3)\n    ax.axhspan(40, 70, facecolor='yellow', alpha=0.3)\n    ax.axhspan(70, 90, facecolor='orange', alpha=0.3)\n    ax.axhspan(90, 120, facecolor='red', alpha=0.3)\n\n    # Text f\u00fcr die H\u00f6rgrade direkt neben die y-Achse setzen\n    ax.text(52, 15, 'Normalh\u00f6rigkeit', ha='left', va='center', fontsize=8, color='black')\n    ax.text(52, 35, 'Leichte Schwerh\u00f6rigkeit', ha='left', va='center', fontsize=8)\n    ax.text(52, 65, 'Mittlere Schwerh\u00f6rigkeit', ha='left', va='center', fontsize=8)\n    ax.text(52, 85, 'Schwere Schwerh\u00f6rigkeit', ha='left', va='center', fontsize=8)\n    ax.text(52, 115, 'Hochgradige Schwerh\u00f6rigkeit', ha='left', va='center', fontsize=8)\n\n    # Plot der H\u00f6rschwellen\n    ax.plot(np.log2(freqs), right_values, marker='o', linestyle='-', color='firebrick', label='rechtes Ohr')\n    ax.plot(np.log2(freqs), left_values, marker='x', linestyle='-', color='dodgerblue', label='linkes Ohr')\n    if bi_values is not None:\n        ax.plot(np.log2(freqs), bi_values, marker='^', linestyle='-', color='darkgoldenrod', label='binauraler H\u00f6rtest')\n\n    # Achsne invertieren und beschriften\n    ax.invert_yaxis()  \n    ax.set_title('Audiogramm')\n    ax.set_xlabel('Frequenzen (Hz)')\n    ax.set_ylabel('H\u00f6rschwelle (dB HL)')\n    ax.set_ylim(120, -10)\n\n    # Benutzerdefinierte x-Achsen-Ticks\n    x_ticks = np.log2(freqs)\n    x_labels = [f\"{int(freq)}\" for freq in freqs]\n    ax.set_xticks(x_ticks)\n    ax.set_xticklabels(x_labels)\n\n\n    ax.set_yticks(np.arange(0, 121, 10))\n    ax.grid(True, which='both', linestyle='--', linewidth=0.5)  # Grid for better readability\n    ax.legend(loc='upper right')\n\n    # if save:\n    #     plt.savefig(\"audiogram.png\")  # Save the figure as an image file\n\n    return fig\n</code></pre>"},{"location":"api/main/","title":"main Module","text":""},{"location":"api/main/#app.main.AudioPlayer","title":"<code>AudioPlayer</code>","text":"Source code in <code>app\\audio_player.py</code> <pre><code>class AudioPlayer:\n\n    def __init__(self):\n        \"\"\"An audio player that can play sine beeps at various frequencies, volumes and with various durations.\n        Automatically detects current samplerate of selected sound device.\n        \"\"\"\n        self.fs = self.get_device_samplerate()\n        self.beep_duration = 10\n        self.volume = 0.5\n        self.frequency = 440\n        self.stream = None\n        self.is_playing = False\n\n    def generate_tone(self):\n        \"\"\"generates a sine tone with current audio player settings\n\n        Returns:\n            np.array: sine wave as numpy array\n        \"\"\"\n        t = np.linspace(start=0, \n                        stop=self.beep_duration, \n                        num=int(self.fs * self.beep_duration), \n                        endpoint=False)\n        tone = np.sin(2 * np.pi * self.frequency * t) * self.volume\n        return tone\n\n    def play_beep(self, frequency, volume, duration, channel='lr'):\n        \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters\n\n        Args:\n            frequency (int): f in Hz\n            volume (float): volume multiplier (between 0 and 1)\n            duration (int): duration of beep in seconds\n            channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively\n        \"\"\"\n        self.frequency = frequency\n        self.volume = volume\n        self.beep_duration = duration\n        tone = self.generate_tone()\n        if channel == 'l':\n            sd.play(np.array([tone, np.zeros(len(tone))]).T, self.fs)\n        elif channel == 'r':\n            sd.play(np.array([np.zeros(len(tone)), tone]).T, self.fs)\n        else:\n            sd.play(tone, self.fs)\n\n    def stop(self):\n        \"\"\"Stops the current playback\n        \"\"\"\n        sd.stop()\n\n\n    def int_or_str(self, text):\n        \"\"\"Helper function for argument parsing.\"\"\"\n        try:\n            return int(text)\n        except ValueError:\n            return text\n\n\n    def get_device_samplerate(self):\n        \"\"\"gets current samplerate from the selected audio output device\n\n        Returns:\n            float: samplerate of current sound device\n        \"\"\"\n        parser = argparse.ArgumentParser(add_help=False)\n        parser.add_argument(\n            '-l', '--list-devices', action='store_true',\n            help='show list of audio devices and exit')\n        args, remaining = parser.parse_known_args()\n        if args.list_devices:\n            print(sd.query_devices())\n            parser.exit(0)\n        parser = argparse.ArgumentParser(\n            description=__doc__,\n            formatter_class=argparse.RawDescriptionHelpFormatter,\n            parents=[parser])\n        parser.add_argument(\n            'frequency', nargs='?', metavar='FREQUENCY', type=float, default=500,\n            help='frequency in Hz (default: %(default)s)')\n        parser.add_argument(\n            '-d', '--device', type=self.int_or_str,\n            help='output device (numeric ID or substring)')\n        parser.add_argument(\n            '-a', '--amplitude', type=float, default=0.2,\n            help='amplitude (default: %(default)s)')\n        args = parser.parse_args(remaining)\n        return sd.query_devices(args.device, 'output')['default_samplerate']\n</code></pre>"},{"location":"api/main/#app.main.AudioPlayer.__init__","title":"<code>__init__()</code>","text":"<p>An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device.</p> Source code in <code>app\\audio_player.py</code> <pre><code>def __init__(self):\n    \"\"\"An audio player that can play sine beeps at various frequencies, volumes and with various durations.\n    Automatically detects current samplerate of selected sound device.\n    \"\"\"\n    self.fs = self.get_device_samplerate()\n    self.beep_duration = 10\n    self.volume = 0.5\n    self.frequency = 440\n    self.stream = None\n    self.is_playing = False\n</code></pre>"},{"location":"api/main/#app.main.AudioPlayer.generate_tone","title":"<code>generate_tone()</code>","text":"<p>generates a sine tone with current audio player settings</p> <p>Returns:</p> Type Description <p>np.array: sine wave as numpy array</p> Source code in <code>app\\audio_player.py</code> <pre><code>def generate_tone(self):\n    \"\"\"generates a sine tone with current audio player settings\n\n    Returns:\n        np.array: sine wave as numpy array\n    \"\"\"\n    t = np.linspace(start=0, \n                    stop=self.beep_duration, \n                    num=int(self.fs * self.beep_duration), \n                    endpoint=False)\n    tone = np.sin(2 * np.pi * self.frequency * t) * self.volume\n    return tone\n</code></pre>"},{"location":"api/main/#app.main.AudioPlayer.get_device_samplerate","title":"<code>get_device_samplerate()</code>","text":"<p>gets current samplerate from the selected audio output device</p> <p>Returns:</p> Name Type Description <code>float</code> <p>samplerate of current sound device</p> Source code in <code>app\\audio_player.py</code> <pre><code>def get_device_samplerate(self):\n    \"\"\"gets current samplerate from the selected audio output device\n\n    Returns:\n        float: samplerate of current sound device\n    \"\"\"\n    parser = argparse.ArgumentParser(add_help=False)\n    parser.add_argument(\n        '-l', '--list-devices', action='store_true',\n        help='show list of audio devices and exit')\n    args, remaining = parser.parse_known_args()\n    if args.list_devices:\n        print(sd.query_devices())\n        parser.exit(0)\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        parents=[parser])\n    parser.add_argument(\n        'frequency', nargs='?', metavar='FREQUENCY', type=float, default=500,\n        help='frequency in Hz (default: %(default)s)')\n    parser.add_argument(\n        '-d', '--device', type=self.int_or_str,\n        help='output device (numeric ID or substring)')\n    parser.add_argument(\n        '-a', '--amplitude', type=float, default=0.2,\n        help='amplitude (default: %(default)s)')\n    args = parser.parse_args(remaining)\n    return sd.query_devices(args.device, 'output')['default_samplerate']\n</code></pre>"},{"location":"api/main/#app.main.AudioPlayer.int_or_str","title":"<code>int_or_str(text)</code>","text":"<p>Helper function for argument parsing.</p> Source code in <code>app\\audio_player.py</code> <pre><code>def int_or_str(self, text):\n    \"\"\"Helper function for argument parsing.\"\"\"\n    try:\n        return int(text)\n    except ValueError:\n        return text\n</code></pre>"},{"location":"api/main/#app.main.AudioPlayer.play_beep","title":"<code>play_beep(frequency, volume, duration, channel='lr')</code>","text":"<p>Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>int</code> <p>f in Hz</p> required <code>volume</code> <code>float</code> <p>volume multiplier (between 0 and 1)</p> required <code>duration</code> <code>int</code> <p>duration of beep in seconds</p> required <code>channel</code> <code>string</code> <p>'l', 'r' or 'lr' for only left, only right or both channels respectively</p> <code>'lr'</code> Source code in <code>app\\audio_player.py</code> <pre><code>def play_beep(self, frequency, volume, duration, channel='lr'):\n    \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters\n\n    Args:\n        frequency (int): f in Hz\n        volume (float): volume multiplier (between 0 and 1)\n        duration (int): duration of beep in seconds\n        channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively\n    \"\"\"\n    self.frequency = frequency\n    self.volume = volume\n    self.beep_duration = duration\n    tone = self.generate_tone()\n    if channel == 'l':\n        sd.play(np.array([tone, np.zeros(len(tone))]).T, self.fs)\n    elif channel == 'r':\n        sd.play(np.array([np.zeros(len(tone)), tone]).T, self.fs)\n    else:\n        sd.play(tone, self.fs)\n</code></pre>"},{"location":"api/main/#app.main.AudioPlayer.stop","title":"<code>stop()</code>","text":"<p>Stops the current playback</p> Source code in <code>app\\audio_player.py</code> <pre><code>def stop(self):\n    \"\"\"Stops the current playback\n    \"\"\"\n    sd.stop()\n</code></pre>"},{"location":"api/main/#app.main.Familiarization","title":"<code>Familiarization</code>","text":"<p>               Bases: <code>Procedure</code></p> Source code in <code>app\\model.py</code> <pre><code>class Familiarization(Procedure):\n\n    def __init__(self, startlevel=40, signal_length=1, id=\"\", **additional_data):\n        \"\"\"Familiarization process\n\n        Args:\n            startlevel (int, optional): starting level of procedure in dBHL. Defaults to 40.\n            signal_length (int, optional): length of played signals in seconds. Defaults to 1.\n        \"\"\"\n        super().__init__(startlevel, signal_length)      \n        self.fails = 0 # number of times familiarization failed\n        self.tempfile = self.create_temp_csv(id=id, **additional_data) # create a temporary file to store level at frequencies\n\n\n    def get_temp_csv_filename(self):\n        return self.tempfile\n\n\n    def familiarize(self):\n        \"\"\"Main function\n\n        Returns:\n            bool: familiarization successful\n        \"\"\"\n        while True:\n            self.tone_heard = True\n\n            # first loop (always -20dBHL)\n            while self.tone_heard:\n                self.play_tone()\n\n                if self.jump_to_end == True:\n                    for f in self.freq_bands:\n                        self.add_to_temp_csv(20, f, 'lr', self.get_temp_csv_filename())\n                    return True\n\n                if self.tone_heard:\n                    self.level -= 20\n                else:\n                    self.level += 10\n\n            # second loop (always +10dBHL)\n            while not self.tone_heard:\n                self.play_tone()\n                if not self.tone_heard:\n                    self.level += 10\n\n            # replay tone with same level\n            self.play_tone()\n\n            if not self.tone_heard:\n                self.fails += 1\n                if self.fails &gt;= 2:\n                    print(\"Familiarization unsuccessful. Please read rules and start again.\")\n                    return False\n                else:\n                    self.level = self.startlevel\n\n            else:\n                print(\"Familiarization successful!\")\n                self.add_to_temp_csv(self.level, '1000', 'l', self.tempfile)\n                return True\n</code></pre>"},{"location":"api/main/#app.main.Familiarization.__init__","title":"<code>__init__(startlevel=40, signal_length=1, id='', **additional_data)</code>","text":"<p>Familiarization process</p> <p>Parameters:</p> Name Type Description Default <code>startlevel</code> <code>int</code> <p>starting level of procedure in dBHL. Defaults to 40.</p> <code>40</code> <code>signal_length</code> <code>int</code> <p>length of played signals in seconds. Defaults to 1.</p> <code>1</code> Source code in <code>app\\model.py</code> <pre><code>def __init__(self, startlevel=40, signal_length=1, id=\"\", **additional_data):\n    \"\"\"Familiarization process\n\n    Args:\n        startlevel (int, optional): starting level of procedure in dBHL. Defaults to 40.\n        signal_length (int, optional): length of played signals in seconds. Defaults to 1.\n    \"\"\"\n    super().__init__(startlevel, signal_length)      \n    self.fails = 0 # number of times familiarization failed\n    self.tempfile = self.create_temp_csv(id=id, **additional_data) # create a temporary file to store level at frequencies\n</code></pre>"},{"location":"api/main/#app.main.Familiarization.familiarize","title":"<code>familiarize()</code>","text":"<p>Main function</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>familiarization successful</p> Source code in <code>app\\model.py</code> <pre><code>def familiarize(self):\n    \"\"\"Main function\n\n    Returns:\n        bool: familiarization successful\n    \"\"\"\n    while True:\n        self.tone_heard = True\n\n        # first loop (always -20dBHL)\n        while self.tone_heard:\n            self.play_tone()\n\n            if self.jump_to_end == True:\n                for f in self.freq_bands:\n                    self.add_to_temp_csv(20, f, 'lr', self.get_temp_csv_filename())\n                return True\n\n            if self.tone_heard:\n                self.level -= 20\n            else:\n                self.level += 10\n\n        # second loop (always +10dBHL)\n        while not self.tone_heard:\n            self.play_tone()\n            if not self.tone_heard:\n                self.level += 10\n\n        # replay tone with same level\n        self.play_tone()\n\n        if not self.tone_heard:\n            self.fails += 1\n            if self.fails &gt;= 2:\n                print(\"Familiarization unsuccessful. Please read rules and start again.\")\n                return False\n            else:\n                self.level = self.startlevel\n\n        else:\n            print(\"Familiarization successful!\")\n            self.add_to_temp_csv(self.level, '1000', 'l', self.tempfile)\n            return True\n</code></pre>"},{"location":"api/main/#app.main.Procedure","title":"<code>Procedure</code>","text":"Source code in <code>app\\model.py</code> <pre><code>class Procedure():\n\n    def __init__(self, startlevel, signal_length):\n        \"\"\"The parent class for the familiarization, the main procedure, and the short version\n\n        Args:\n            startlevel (float): starting level of procedure in dBHL\n            signal_length (float): length of played signals in seconds\n        \"\"\"\n        self.ap = AudioPlayer()\n        self.startlevel = startlevel\n        self.level = startlevel\n        self.signal_length = signal_length\n        self.frequency = 1000\n        self.zero_dbhl = 0.00002 # zero_dbhl in absolute numbers. Needs to be calibrated!\n        self.tone_heard = False\n        self.freq_bands = ['125', '250', '500', '1000', '2000', '4000', '8000']\n        self.side = 'l'\n        self.test_mode = True\n        self.jump_to_end = False\n\n\n    def dbhl_to_volume(self, dbhl):\n        \"\"\"Calculate dBHL into absolute numbers\n\n        Args:\n            dbhl (float): value in dBHL\n\n        Returns:\n            float: value in absolute numbers\n        \"\"\"\n        return self.zero_dbhl * 10 ** (dbhl / 10)\n\n\n    def key_press(self, key):\n        if key == keyboard.Key.space:\n            self.tone_heard = True\n            print(\"Tone heard!\")\n        elif self.test_mode and key == keyboard.Key.right:\n            self.jump_to_end = True\n\n\n    def play_tone(self):\n        \"\"\"Set tone_heard to False, play beep, then wait max 4s for keypress.\n        If key is pressed, set tone_heard to True.\n        Then wait for around about 2s (randomized).\n        \"\"\"\n        self.tone_heard = False\n        print(self.frequency, \"Hz - playing tone at\", self.level, \"dBHL.\")\n        self.ap.play_beep(self.frequency, self.dbhl_to_volume(self.level), self.signal_length, self.side)\n        listener = keyboard.Listener(on_press=self.key_press, on_release=None)\n        listener.start()\n        current_wait_time = 0\n        max_wait_time = 4000 # in ms \n        step_size = 50 # in ms\n        while current_wait_time &lt; max_wait_time and not self.tone_heard: # wait for keypress\n            time.sleep(step_size / 1000)\n            current_wait_time += step_size\n        listener.stop()\n        self.ap.stop()\n        if not self.tone_heard:\n            print(\"Tone not heard :(\")\n        else:\n            sleep_time = random.uniform(1, 2.5) # random wait time between 1 and 2.5\n            time.sleep(sleep_time) # wait before next tone is played. #TODO test times\n\n\n    def create_temp_csv(self, id=\"\", **additional_data):\n        \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header\n        and NaN in the second and third line as starting value for each band.\n        (second line: left ear, third line: right ear)\n        ID and additional data will be stored in subsequent lines in the format: key, value.\n\n        Args:\n            id (string, optional): id to be stored, that will later be used for naming exported csv file\n\n        Returns:\n            str: name of temporary file\n        \"\"\"\n        with tfile.NamedTemporaryFile(mode='w+', delete=False, newline='', suffix='.csv') as temp_file:\n            # Define the CSV writer\n            csv_writer = csv.writer(temp_file)\n\n            # Write header\n            csv_writer.writerow(self.freq_bands)\n\n            # Write value NaN for each frequency in second and third row\n            csv_writer.writerow(['NaN' for _ in range(len(self.freq_bands))])\n            csv_writer.writerow(['NaN' for _ in range(len(self.freq_bands))])\n\n            # Write id and additional data\n            if id:\n                csv_writer.writerow([\"id\", id])\n            if additional_data:\n                for key, value in additional_data.items():\n                    csv_writer.writerow([key, value])\n\n            return temp_file.name\n\n\n    def add_to_temp_csv(self, value, frequency, side, temp_filename):\n        \"\"\"Add a value in for a specific frequency to the temporary csv file\n\n        Args:\n            value (str): level in dBHL at specific frequency\n            frequency (str): frequency where value should be added\n            side (str): specify which ear ('l' or 'r')\n            temp_filename (str): name of temporary csv file\n        \"\"\"\n        # Read all rows from the CSV file\n        with open(temp_filename, mode='r', newline='') as temp_file:\n            dict_reader = csv.DictReader(temp_file)\n            rows = list(dict_reader)\n\n        # Update the relevant row based on the side parameter\n        if side == 'l':\n            rows[0][frequency] = value\n        elif side == 'r':\n            rows[1][frequency] = value\n        else:\n            rows[0][frequency] = value\n            rows[1][frequency] = value\n\n        # Write all rows back to the CSV file\n        with open(temp_filename, mode='w', newline='') as temp_file:\n            dict_writer = csv.DictWriter(temp_file, fieldnames=self.freq_bands)\n            dict_writer.writeheader()\n            dict_writer.writerows(rows)\n\n        print(rows[0], rows[1])\n        for row in rows[2:]:\n            print(row['125'], row['250'])\n\n\n    def get_value_from_csv(self, frequency, temp_filename, side='l'):\n        \"\"\"Get the value at a specific frequency from the temporary csv file\n\n        Args:\n            frequency (str): frequency where value is stored\n            temp_filename (str): name of temporary csv file\n            side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'.\n\n        Returns:\n            str: dBHL value at specified frequency\n        \"\"\"\n        with open(temp_filename, mode='r', newline='') as temp_file:\n            dict_reader = csv.DictReader(temp_file)\n            freq_dict = next(dict_reader) # left ear\n            if side == 'r': # go to next line if right side\n                freq_dict = next(dict_reader)    \n            return freq_dict[frequency]\n\n\n    def create_final_csv(self, temp_filename):\n        \"\"\"makes a permanent csv file from the temporary file\n\n        Args:\n            temp_filename (str): name of temporary csv file\n        \"\"\"\n        # read temp file\n        with open(temp_filename, mode='r', newline='') as temp_file:\n            dict_reader = csv.DictReader(temp_file)\n            rows = list(dict_reader)\n        # get date and time    \n        now = datetime.now()\n        date_str = now.strftime(\"%Y%m%d_%H%M%S\")\n        try:\n            id = self.rows[2]['250']\n        except:\n            id = False\n\n        if id:\n            final_filename = id + \"_audiogramm_\" + date_str + \".csv\"\n        else:\n            final_filename = \"missingID_audiogramm_\" + date_str + \".csv\"\n\n\n        with open(final_filename, mode='x', newline='') as final_file:\n            dict_writer = csv.DictWriter(final_file, fieldnames=self.freq_bands)\n            dict_writer.writeheader()\n            dict_writer.writerows(rows)\n\n        print(\"Datei gespeicher als \" + final_filename)\n</code></pre>"},{"location":"api/main/#app.main.Procedure.__init__","title":"<code>__init__(startlevel, signal_length)</code>","text":"<p>The parent class for the familiarization, the main procedure, and the short version</p> <p>Parameters:</p> Name Type Description Default <code>startlevel</code> <code>float</code> <p>starting level of procedure in dBHL</p> required <code>signal_length</code> <code>float</code> <p>length of played signals in seconds</p> required Source code in <code>app\\model.py</code> <pre><code>def __init__(self, startlevel, signal_length):\n    \"\"\"The parent class for the familiarization, the main procedure, and the short version\n\n    Args:\n        startlevel (float): starting level of procedure in dBHL\n        signal_length (float): length of played signals in seconds\n    \"\"\"\n    self.ap = AudioPlayer()\n    self.startlevel = startlevel\n    self.level = startlevel\n    self.signal_length = signal_length\n    self.frequency = 1000\n    self.zero_dbhl = 0.00002 # zero_dbhl in absolute numbers. Needs to be calibrated!\n    self.tone_heard = False\n    self.freq_bands = ['125', '250', '500', '1000', '2000', '4000', '8000']\n    self.side = 'l'\n    self.test_mode = True\n    self.jump_to_end = False\n</code></pre>"},{"location":"api/main/#app.main.Procedure.add_to_temp_csv","title":"<code>add_to_temp_csv(value, frequency, side, temp_filename)</code>","text":"<p>Add a value in for a specific frequency to the temporary csv file</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>level in dBHL at specific frequency</p> required <code>frequency</code> <code>str</code> <p>frequency where value should be added</p> required <code>side</code> <code>str</code> <p>specify which ear ('l' or 'r')</p> required <code>temp_filename</code> <code>str</code> <p>name of temporary csv file</p> required Source code in <code>app\\model.py</code> <pre><code>def add_to_temp_csv(self, value, frequency, side, temp_filename):\n    \"\"\"Add a value in for a specific frequency to the temporary csv file\n\n    Args:\n        value (str): level in dBHL at specific frequency\n        frequency (str): frequency where value should be added\n        side (str): specify which ear ('l' or 'r')\n        temp_filename (str): name of temporary csv file\n    \"\"\"\n    # Read all rows from the CSV file\n    with open(temp_filename, mode='r', newline='') as temp_file:\n        dict_reader = csv.DictReader(temp_file)\n        rows = list(dict_reader)\n\n    # Update the relevant row based on the side parameter\n    if side == 'l':\n        rows[0][frequency] = value\n    elif side == 'r':\n        rows[1][frequency] = value\n    else:\n        rows[0][frequency] = value\n        rows[1][frequency] = value\n\n    # Write all rows back to the CSV file\n    with open(temp_filename, mode='w', newline='') as temp_file:\n        dict_writer = csv.DictWriter(temp_file, fieldnames=self.freq_bands)\n        dict_writer.writeheader()\n        dict_writer.writerows(rows)\n\n    print(rows[0], rows[1])\n    for row in rows[2:]:\n        print(row['125'], row['250'])\n</code></pre>"},{"location":"api/main/#app.main.Procedure.create_final_csv","title":"<code>create_final_csv(temp_filename)</code>","text":"<p>makes a permanent csv file from the temporary file</p> <p>Parameters:</p> Name Type Description Default <code>temp_filename</code> <code>str</code> <p>name of temporary csv file</p> required Source code in <code>app\\model.py</code> <pre><code>def create_final_csv(self, temp_filename):\n    \"\"\"makes a permanent csv file from the temporary file\n\n    Args:\n        temp_filename (str): name of temporary csv file\n    \"\"\"\n    # read temp file\n    with open(temp_filename, mode='r', newline='') as temp_file:\n        dict_reader = csv.DictReader(temp_file)\n        rows = list(dict_reader)\n    # get date and time    \n    now = datetime.now()\n    date_str = now.strftime(\"%Y%m%d_%H%M%S\")\n    try:\n        id = self.rows[2]['250']\n    except:\n        id = False\n\n    if id:\n        final_filename = id + \"_audiogramm_\" + date_str + \".csv\"\n    else:\n        final_filename = \"missingID_audiogramm_\" + date_str + \".csv\"\n\n\n    with open(final_filename, mode='x', newline='') as final_file:\n        dict_writer = csv.DictWriter(final_file, fieldnames=self.freq_bands)\n        dict_writer.writeheader()\n        dict_writer.writerows(rows)\n\n    print(\"Datei gespeicher als \" + final_filename)\n</code></pre>"},{"location":"api/main/#app.main.Procedure.create_temp_csv","title":"<code>create_temp_csv(id='', **additional_data)</code>","text":"<p>Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>string</code> <p>id to be stored, that will later be used for naming exported csv file</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <p>name of temporary file</p> Source code in <code>app\\model.py</code> <pre><code>def create_temp_csv(self, id=\"\", **additional_data):\n    \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header\n    and NaN in the second and third line as starting value for each band.\n    (second line: left ear, third line: right ear)\n    ID and additional data will be stored in subsequent lines in the format: key, value.\n\n    Args:\n        id (string, optional): id to be stored, that will later be used for naming exported csv file\n\n    Returns:\n        str: name of temporary file\n    \"\"\"\n    with tfile.NamedTemporaryFile(mode='w+', delete=False, newline='', suffix='.csv') as temp_file:\n        # Define the CSV writer\n        csv_writer = csv.writer(temp_file)\n\n        # Write header\n        csv_writer.writerow(self.freq_bands)\n\n        # Write value NaN for each frequency in second and third row\n        csv_writer.writerow(['NaN' for _ in range(len(self.freq_bands))])\n        csv_writer.writerow(['NaN' for _ in range(len(self.freq_bands))])\n\n        # Write id and additional data\n        if id:\n            csv_writer.writerow([\"id\", id])\n        if additional_data:\n            for key, value in additional_data.items():\n                csv_writer.writerow([key, value])\n\n        return temp_file.name\n</code></pre>"},{"location":"api/main/#app.main.Procedure.dbhl_to_volume","title":"<code>dbhl_to_volume(dbhl)</code>","text":"<p>Calculate dBHL into absolute numbers</p> <p>Parameters:</p> Name Type Description Default <code>dbhl</code> <code>float</code> <p>value in dBHL</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>value in absolute numbers</p> Source code in <code>app\\model.py</code> <pre><code>def dbhl_to_volume(self, dbhl):\n    \"\"\"Calculate dBHL into absolute numbers\n\n    Args:\n        dbhl (float): value in dBHL\n\n    Returns:\n        float: value in absolute numbers\n    \"\"\"\n    return self.zero_dbhl * 10 ** (dbhl / 10)\n</code></pre>"},{"location":"api/main/#app.main.Procedure.get_value_from_csv","title":"<code>get_value_from_csv(frequency, temp_filename, side='l')</code>","text":"<p>Get the value at a specific frequency from the temporary csv file</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>str</code> <p>frequency where value is stored</p> required <code>temp_filename</code> <code>str</code> <p>name of temporary csv file</p> required <code>side</code> <code>str</code> <p>specify which ear ('l' or 'r'). Defaults to 'l'.</p> <code>'l'</code> <p>Returns:</p> Name Type Description <code>str</code> <p>dBHL value at specified frequency</p> Source code in <code>app\\model.py</code> <pre><code>def get_value_from_csv(self, frequency, temp_filename, side='l'):\n    \"\"\"Get the value at a specific frequency from the temporary csv file\n\n    Args:\n        frequency (str): frequency where value is stored\n        temp_filename (str): name of temporary csv file\n        side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'.\n\n    Returns:\n        str: dBHL value at specified frequency\n    \"\"\"\n    with open(temp_filename, mode='r', newline='') as temp_file:\n        dict_reader = csv.DictReader(temp_file)\n        freq_dict = next(dict_reader) # left ear\n        if side == 'r': # go to next line if right side\n            freq_dict = next(dict_reader)    \n        return freq_dict[frequency]\n</code></pre>"},{"location":"api/main/#app.main.Procedure.play_tone","title":"<code>play_tone()</code>","text":"<p>Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized).</p> Source code in <code>app\\model.py</code> <pre><code>def play_tone(self):\n    \"\"\"Set tone_heard to False, play beep, then wait max 4s for keypress.\n    If key is pressed, set tone_heard to True.\n    Then wait for around about 2s (randomized).\n    \"\"\"\n    self.tone_heard = False\n    print(self.frequency, \"Hz - playing tone at\", self.level, \"dBHL.\")\n    self.ap.play_beep(self.frequency, self.dbhl_to_volume(self.level), self.signal_length, self.side)\n    listener = keyboard.Listener(on_press=self.key_press, on_release=None)\n    listener.start()\n    current_wait_time = 0\n    max_wait_time = 4000 # in ms \n    step_size = 50 # in ms\n    while current_wait_time &lt; max_wait_time and not self.tone_heard: # wait for keypress\n        time.sleep(step_size / 1000)\n        current_wait_time += step_size\n    listener.stop()\n    self.ap.stop()\n    if not self.tone_heard:\n        print(\"Tone not heard :(\")\n    else:\n        sleep_time = random.uniform(1, 2.5) # random wait time between 1 and 2.5\n        time.sleep(sleep_time) # wait before next tone is played. #TODO test times\n</code></pre>"},{"location":"api/main/#app.main.ScreeningProcedure","title":"<code>ScreeningProcedure</code>","text":"<p>               Bases: <code>Procedure</code></p> Source code in <code>app\\model.py</code> <pre><code>class ScreeningProcedure(Procedure):\n    def __init__(self,  temp_filename, signal_length=1):\n        \"\"\"short screening process to check if subject can hear specific frequencies at certain levels\n\n        Args:\n            signal_length (int, optional): length of played signals in seconds. Defaults to 1.\n        \"\"\"\n        super().__init__(startlevel=0, signal_length=signal_length)\n        self.temp_filename = temp_filename\n        self.freq_order = [1000, 2000]#, 4000, 8000, 500, 250, 125]\n\n        #TODO das als default, aber  variabel in der GUI\n        self.freq_levels = {125: 20, 250: 20, 500: 20, 1000: 20, 2000: 20, 4000: 20, 8000: 20}\n\n    def screen_test(self, binaural=False, **additional_data):\n        \"\"\"main functions\n\n        Returns:\n            bool: test successful\n        \"\"\"\n        if not binaural:\n            self.side = 'l'\n            success_l = self.screen_one_ear()\n\n            self.side = 'r'\n            success_r = self.screen_one_ear()\n\n            if success_l and success_r:\n                self.create_final_csv(self.temp_filename)\n                return True\n\n        if binaural:\n            self.side = 'lr'\n            success_lr = self.screen_one_ear()\n\n            if success_lr:\n                self.create_final_csv(self.temp_filename)\n                return True\n\n        return False\n\n\n    def screen_one_ear(self):\n        success = []\n        # test every frequency\n        for f in self.freq_order:\n            print(f\"Testing frequeny {f} Hz\")\n            s = self.screen_one_freq(f)\n            success.append(s)\n\n        if all(success):\n            return True\n\n        else:\n            return False\n\n\n    def screen_one_freq(self, freq):\n        \"\"\"screening for one frequency\n\n        Args:\n            freq (int): frequency to be tested\n            level (int): level at which the frequency is tested\n\n        Returns:\n            bool: tone heard\n        \"\"\"\n        self.frequency = freq\n        self.level = self.freq_levels[freq]\n        self.tone_heard = False\n        self.num_heard = 0\n\n        for i in range(3):\n            self.play_tone()\n\n            if self.tone_heard:\n                self.num_heard += 1\n\n            if self.num_heard &gt;= 2:\n                self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n                return True\n\n        return self.tone_heard\n</code></pre>"},{"location":"api/main/#app.main.ScreeningProcedure.__init__","title":"<code>__init__(temp_filename, signal_length=1)</code>","text":"<p>short screening process to check if subject can hear specific frequencies at certain levels</p> <p>Parameters:</p> Name Type Description Default <code>signal_length</code> <code>int</code> <p>length of played signals in seconds. Defaults to 1.</p> <code>1</code> Source code in <code>app\\model.py</code> <pre><code>def __init__(self,  temp_filename, signal_length=1):\n    \"\"\"short screening process to check if subject can hear specific frequencies at certain levels\n\n    Args:\n        signal_length (int, optional): length of played signals in seconds. Defaults to 1.\n    \"\"\"\n    super().__init__(startlevel=0, signal_length=signal_length)\n    self.temp_filename = temp_filename\n    self.freq_order = [1000, 2000]#, 4000, 8000, 500, 250, 125]\n\n    #TODO das als default, aber  variabel in der GUI\n    self.freq_levels = {125: 20, 250: 20, 500: 20, 1000: 20, 2000: 20, 4000: 20, 8000: 20}\n</code></pre>"},{"location":"api/main/#app.main.ScreeningProcedure.screen_one_freq","title":"<code>screen_one_freq(freq)</code>","text":"<p>screening for one frequency</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>int</code> <p>frequency to be tested</p> required <code>level</code> <code>int</code> <p>level at which the frequency is tested</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>tone heard</p> Source code in <code>app\\model.py</code> <pre><code>def screen_one_freq(self, freq):\n    \"\"\"screening for one frequency\n\n    Args:\n        freq (int): frequency to be tested\n        level (int): level at which the frequency is tested\n\n    Returns:\n        bool: tone heard\n    \"\"\"\n    self.frequency = freq\n    self.level = self.freq_levels[freq]\n    self.tone_heard = False\n    self.num_heard = 0\n\n    for i in range(3):\n        self.play_tone()\n\n        if self.tone_heard:\n            self.num_heard += 1\n\n        if self.num_heard &gt;= 2:\n            self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n            return True\n\n    return self.tone_heard\n</code></pre>"},{"location":"api/main/#app.main.ScreeningProcedure.screen_test","title":"<code>screen_test(binaural=False, **additional_data)</code>","text":"<p>main functions</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>test successful</p> Source code in <code>app\\model.py</code> <pre><code>def screen_test(self, binaural=False, **additional_data):\n    \"\"\"main functions\n\n    Returns:\n        bool: test successful\n    \"\"\"\n    if not binaural:\n        self.side = 'l'\n        success_l = self.screen_one_ear()\n\n        self.side = 'r'\n        success_r = self.screen_one_ear()\n\n        if success_l and success_r:\n            self.create_final_csv(self.temp_filename)\n            return True\n\n    if binaural:\n        self.side = 'lr'\n        success_lr = self.screen_one_ear()\n\n        if success_lr:\n            self.create_final_csv(self.temp_filename)\n            return True\n\n    return False\n</code></pre>"},{"location":"api/main/#app.main.StandardProcedure","title":"<code>StandardProcedure</code>","text":"<p>               Bases: <code>Procedure</code></p> Source code in <code>app\\model.py</code> <pre><code>class StandardProcedure(Procedure):\n\n    def __init__(self, temp_filename, signal_length=1):\n        \"\"\"Standard audiometer process (rising level)\n\n        Args:\n            temp_filename (str): name of temporary csv file where starting level is stored and future values will be stored\n            signal_length (int, optional): length of played signal in seconds. Defaults to 1.\n        \"\"\"\n        startlevel = int(self.get_value_from_csv('1000', temp_filename)) - 10 # 10 dB under level from familiarization\n        super().__init__(startlevel, signal_length)\n        self.temp_filename = temp_filename\n        self.freq_order = [1000]#, 2000, 4000, 8000, 500, 250, 125] # order in which frequencies are tested\n\n\n    def standard_test(self, binaural=False, **additional_data):\n        \"\"\"Main function\n\n        Returns:\n            bool: test successful\n        \"\"\"\n\n        if not binaural:\n            self.side = 'l'\n            success_l = self.standard_test_one_ear()\n\n            if self.test_mode == True and self.jump_to_end == True:\n                self.create_final_csv(self.temp_filename)\n                return True\n\n            self.side = 'r'\n            success_r = self.standard_test_one_ear()\n\n            if success_l and success_r:\n                self.create_final_csv(self.temp_filename)\n                return True\n\n        if binaural:\n            self.side = 'lr'\n            success_lr = self.standard_test_one_ear()\n\n            if self.test_mode == True and self.jump_to_end == True:\n                self.create_final_csv(self.temp_filename)\n                return True\n\n            if success_lr:\n                self.create_final_csv(self.temp_filename)\n                return True\n\n        return False\n\n\n    def standard_test_one_ear(self):\n        \"\"\"Audiometer for one ear\n\n        Returns:\n            bool: test successful\n        \"\"\"\n        success = []\n        # test every frequency\n        for f in self.freq_order:\n            print(f\"Testing frequency {f} Hz\")\n            s = self.standard_test_one_freq(f)\n\n            if self.test_mode == True and self.jump_to_end == True:\n                return True\n\n            success.append(s)\n\n        # retest 1000 Hz (and more frequencies if discrepancy is too high)\n        for f in self.freq_order:\n            print(f\"Retest at frequency {f} Hz\")\n            s = self.standard_test_one_freq(f, retest=True)\n            if s:\n                break\n\n        if all(success):\n            return True\n\n        else:\n            return False\n\n\n    def standard_test_one_freq(self, freq, retest=False):\n        \"\"\"Test for one frequency\n\n        Args:\n            freq (int): frequency at which hearing is tested\n            retest (bool, optional): Is this the retest at the end of step 3 according to DIN. Defaults to False\n\n        Returns:\n            bool: test successful\n        \"\"\"\n        self.tone_heard = False\n        self.frequency = freq\n        self.level = self.startlevel\n\n        # Step 1 (raise tone in 5 dB steps until it is heard)\n        while not self.tone_heard:\n            self.play_tone()\n\n            if self.test_mode == True and self.jump_to_end == True:\n                return True\n\n\n            if not self.tone_heard:\n                self.level += 5\n\n        # Step 2\n        answers = []\n        tries = 0\n\n        while tries &lt; 6:\n            # reduce in 10dB steps until no answer\n            while self.tone_heard:\n                self.level -= 10\n                self.play_tone()\n\n            # raise in 5 dB steps until answer\n            while not self.tone_heard:\n                self.level += 5\n                self.play_tone()\n\n            tries += 1\n            answers.append(self.level)\n            print(f\"Try nr {tries}: level: {self.level}\")\n\n            if answers.count(self.level) &gt;= 2:\n                if retest:\n                    if abs(self.level - int(self.get_value_from_csv(str(self.frequency), self.temp_filename, self.side))) &gt; 5:\n                        self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n                        return False\n                    else:\n                        self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n                        return True\n\n                # TODO Wenn Streuung mehr als 10 dB: Vermerk im Audiogramm\n                self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n                return True\n\n            # no three same answers in five tries\n            if tries == 3:\n                self.level += 10\n                self.play_tone()\n                answers = []\n\n        print(\"Something went wrong, please try from the beginning again.\")\n        return False\n</code></pre>"},{"location":"api/main/#app.main.StandardProcedure.__init__","title":"<code>__init__(temp_filename, signal_length=1)</code>","text":"<p>Standard audiometer process (rising level)</p> <p>Parameters:</p> Name Type Description Default <code>temp_filename</code> <code>str</code> <p>name of temporary csv file where starting level is stored and future values will be stored</p> required <code>signal_length</code> <code>int</code> <p>length of played signal in seconds. Defaults to 1.</p> <code>1</code> Source code in <code>app\\model.py</code> <pre><code>def __init__(self, temp_filename, signal_length=1):\n    \"\"\"Standard audiometer process (rising level)\n\n    Args:\n        temp_filename (str): name of temporary csv file where starting level is stored and future values will be stored\n        signal_length (int, optional): length of played signal in seconds. Defaults to 1.\n    \"\"\"\n    startlevel = int(self.get_value_from_csv('1000', temp_filename)) - 10 # 10 dB under level from familiarization\n    super().__init__(startlevel, signal_length)\n    self.temp_filename = temp_filename\n    self.freq_order = [1000]#, 2000, 4000, 8000, 500, 250, 125] # order in which frequencies are tested\n</code></pre>"},{"location":"api/main/#app.main.StandardProcedure.standard_test","title":"<code>standard_test(binaural=False, **additional_data)</code>","text":"<p>Main function</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>test successful</p> Source code in <code>app\\model.py</code> <pre><code>def standard_test(self, binaural=False, **additional_data):\n    \"\"\"Main function\n\n    Returns:\n        bool: test successful\n    \"\"\"\n\n    if not binaural:\n        self.side = 'l'\n        success_l = self.standard_test_one_ear()\n\n        if self.test_mode == True and self.jump_to_end == True:\n            self.create_final_csv(self.temp_filename)\n            return True\n\n        self.side = 'r'\n        success_r = self.standard_test_one_ear()\n\n        if success_l and success_r:\n            self.create_final_csv(self.temp_filename)\n            return True\n\n    if binaural:\n        self.side = 'lr'\n        success_lr = self.standard_test_one_ear()\n\n        if self.test_mode == True and self.jump_to_end == True:\n            self.create_final_csv(self.temp_filename)\n            return True\n\n        if success_lr:\n            self.create_final_csv(self.temp_filename)\n            return True\n\n    return False\n</code></pre>"},{"location":"api/main/#app.main.StandardProcedure.standard_test_one_ear","title":"<code>standard_test_one_ear()</code>","text":"<p>Audiometer for one ear</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>test successful</p> Source code in <code>app\\model.py</code> <pre><code>def standard_test_one_ear(self):\n    \"\"\"Audiometer for one ear\n\n    Returns:\n        bool: test successful\n    \"\"\"\n    success = []\n    # test every frequency\n    for f in self.freq_order:\n        print(f\"Testing frequency {f} Hz\")\n        s = self.standard_test_one_freq(f)\n\n        if self.test_mode == True and self.jump_to_end == True:\n            return True\n\n        success.append(s)\n\n    # retest 1000 Hz (and more frequencies if discrepancy is too high)\n    for f in self.freq_order:\n        print(f\"Retest at frequency {f} Hz\")\n        s = self.standard_test_one_freq(f, retest=True)\n        if s:\n            break\n\n    if all(success):\n        return True\n\n    else:\n        return False\n</code></pre>"},{"location":"api/main/#app.main.StandardProcedure.standard_test_one_freq","title":"<code>standard_test_one_freq(freq, retest=False)</code>","text":"<p>Test for one frequency</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>int</code> <p>frequency at which hearing is tested</p> required <code>retest</code> <code>bool</code> <p>Is this the retest at the end of step 3 according to DIN. Defaults to False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>test successful</p> Source code in <code>app\\model.py</code> <pre><code>def standard_test_one_freq(self, freq, retest=False):\n    \"\"\"Test for one frequency\n\n    Args:\n        freq (int): frequency at which hearing is tested\n        retest (bool, optional): Is this the retest at the end of step 3 according to DIN. Defaults to False\n\n    Returns:\n        bool: test successful\n    \"\"\"\n    self.tone_heard = False\n    self.frequency = freq\n    self.level = self.startlevel\n\n    # Step 1 (raise tone in 5 dB steps until it is heard)\n    while not self.tone_heard:\n        self.play_tone()\n\n        if self.test_mode == True and self.jump_to_end == True:\n            return True\n\n\n        if not self.tone_heard:\n            self.level += 5\n\n    # Step 2\n    answers = []\n    tries = 0\n\n    while tries &lt; 6:\n        # reduce in 10dB steps until no answer\n        while self.tone_heard:\n            self.level -= 10\n            self.play_tone()\n\n        # raise in 5 dB steps until answer\n        while not self.tone_heard:\n            self.level += 5\n            self.play_tone()\n\n        tries += 1\n        answers.append(self.level)\n        print(f\"Try nr {tries}: level: {self.level}\")\n\n        if answers.count(self.level) &gt;= 2:\n            if retest:\n                if abs(self.level - int(self.get_value_from_csv(str(self.frequency), self.temp_filename, self.side))) &gt; 5:\n                    self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n                    return False\n                else:\n                    self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n                    return True\n\n            # TODO Wenn Streuung mehr als 10 dB: Vermerk im Audiogramm\n            self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n            return True\n\n        # no three same answers in five tries\n        if tries == 3:\n            self.level += 10\n            self.play_tone()\n            answers = []\n\n    print(\"Something went wrong, please try from the beginning again.\")\n    return False\n</code></pre>"},{"location":"api/model/","title":"model Module","text":""},{"location":"api/model/#app.model.Familiarization","title":"<code>Familiarization</code>","text":"<p>               Bases: <code>Procedure</code></p> Source code in <code>app\\model.py</code> <pre><code>class Familiarization(Procedure):\n\n    def __init__(self, startlevel=40, signal_length=1, id=\"\", **additional_data):\n        \"\"\"Familiarization process\n\n        Args:\n            startlevel (int, optional): starting level of procedure in dBHL. Defaults to 40.\n            signal_length (int, optional): length of played signals in seconds. Defaults to 1.\n        \"\"\"\n        super().__init__(startlevel, signal_length)      \n        self.fails = 0 # number of times familiarization failed\n        self.tempfile = self.create_temp_csv(id=id, **additional_data) # create a temporary file to store level at frequencies\n\n\n    def get_temp_csv_filename(self):\n        return self.tempfile\n\n\n    def familiarize(self):\n        \"\"\"Main function\n\n        Returns:\n            bool: familiarization successful\n        \"\"\"\n        while True:\n            self.tone_heard = True\n\n            # first loop (always -20dBHL)\n            while self.tone_heard:\n                self.play_tone()\n\n                if self.jump_to_end == True:\n                    for f in self.freq_bands:\n                        self.add_to_temp_csv(20, f, 'lr', self.get_temp_csv_filename())\n                    return True\n\n                if self.tone_heard:\n                    self.level -= 20\n                else:\n                    self.level += 10\n\n            # second loop (always +10dBHL)\n            while not self.tone_heard:\n                self.play_tone()\n                if not self.tone_heard:\n                    self.level += 10\n\n            # replay tone with same level\n            self.play_tone()\n\n            if not self.tone_heard:\n                self.fails += 1\n                if self.fails &gt;= 2:\n                    print(\"Familiarization unsuccessful. Please read rules and start again.\")\n                    return False\n                else:\n                    self.level = self.startlevel\n\n            else:\n                print(\"Familiarization successful!\")\n                self.add_to_temp_csv(self.level, '1000', 'l', self.tempfile)\n                return True\n</code></pre>"},{"location":"api/model/#app.model.Familiarization.__init__","title":"<code>__init__(startlevel=40, signal_length=1, id='', **additional_data)</code>","text":"<p>Familiarization process</p> <p>Parameters:</p> Name Type Description Default <code>startlevel</code> <code>int</code> <p>starting level of procedure in dBHL. Defaults to 40.</p> <code>40</code> <code>signal_length</code> <code>int</code> <p>length of played signals in seconds. Defaults to 1.</p> <code>1</code> Source code in <code>app\\model.py</code> <pre><code>def __init__(self, startlevel=40, signal_length=1, id=\"\", **additional_data):\n    \"\"\"Familiarization process\n\n    Args:\n        startlevel (int, optional): starting level of procedure in dBHL. Defaults to 40.\n        signal_length (int, optional): length of played signals in seconds. Defaults to 1.\n    \"\"\"\n    super().__init__(startlevel, signal_length)      \n    self.fails = 0 # number of times familiarization failed\n    self.tempfile = self.create_temp_csv(id=id, **additional_data) # create a temporary file to store level at frequencies\n</code></pre>"},{"location":"api/model/#app.model.Familiarization.familiarize","title":"<code>familiarize()</code>","text":"<p>Main function</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>familiarization successful</p> Source code in <code>app\\model.py</code> <pre><code>def familiarize(self):\n    \"\"\"Main function\n\n    Returns:\n        bool: familiarization successful\n    \"\"\"\n    while True:\n        self.tone_heard = True\n\n        # first loop (always -20dBHL)\n        while self.tone_heard:\n            self.play_tone()\n\n            if self.jump_to_end == True:\n                for f in self.freq_bands:\n                    self.add_to_temp_csv(20, f, 'lr', self.get_temp_csv_filename())\n                return True\n\n            if self.tone_heard:\n                self.level -= 20\n            else:\n                self.level += 10\n\n        # second loop (always +10dBHL)\n        while not self.tone_heard:\n            self.play_tone()\n            if not self.tone_heard:\n                self.level += 10\n\n        # replay tone with same level\n        self.play_tone()\n\n        if not self.tone_heard:\n            self.fails += 1\n            if self.fails &gt;= 2:\n                print(\"Familiarization unsuccessful. Please read rules and start again.\")\n                return False\n            else:\n                self.level = self.startlevel\n\n        else:\n            print(\"Familiarization successful!\")\n            self.add_to_temp_csv(self.level, '1000', 'l', self.tempfile)\n            return True\n</code></pre>"},{"location":"api/model/#app.model.Procedure","title":"<code>Procedure</code>","text":"Source code in <code>app\\model.py</code> <pre><code>class Procedure():\n\n    def __init__(self, startlevel, signal_length):\n        \"\"\"The parent class for the familiarization, the main procedure, and the short version\n\n        Args:\n            startlevel (float): starting level of procedure in dBHL\n            signal_length (float): length of played signals in seconds\n        \"\"\"\n        self.ap = AudioPlayer()\n        self.startlevel = startlevel\n        self.level = startlevel\n        self.signal_length = signal_length\n        self.frequency = 1000\n        self.zero_dbhl = 0.00002 # zero_dbhl in absolute numbers. Needs to be calibrated!\n        self.tone_heard = False\n        self.freq_bands = ['125', '250', '500', '1000', '2000', '4000', '8000']\n        self.side = 'l'\n        self.test_mode = True\n        self.jump_to_end = False\n\n\n    def dbhl_to_volume(self, dbhl):\n        \"\"\"Calculate dBHL into absolute numbers\n\n        Args:\n            dbhl (float): value in dBHL\n\n        Returns:\n            float: value in absolute numbers\n        \"\"\"\n        return self.zero_dbhl * 10 ** (dbhl / 10)\n\n\n    def key_press(self, key):\n        if key == keyboard.Key.space:\n            self.tone_heard = True\n            print(\"Tone heard!\")\n        elif self.test_mode and key == keyboard.Key.right:\n            self.jump_to_end = True\n\n\n    def play_tone(self):\n        \"\"\"Set tone_heard to False, play beep, then wait max 4s for keypress.\n        If key is pressed, set tone_heard to True.\n        Then wait for around about 2s (randomized).\n        \"\"\"\n        self.tone_heard = False\n        print(self.frequency, \"Hz - playing tone at\", self.level, \"dBHL.\")\n        self.ap.play_beep(self.frequency, self.dbhl_to_volume(self.level), self.signal_length, self.side)\n        listener = keyboard.Listener(on_press=self.key_press, on_release=None)\n        listener.start()\n        current_wait_time = 0\n        max_wait_time = 4000 # in ms \n        step_size = 50 # in ms\n        while current_wait_time &lt; max_wait_time and not self.tone_heard: # wait for keypress\n            time.sleep(step_size / 1000)\n            current_wait_time += step_size\n        listener.stop()\n        self.ap.stop()\n        if not self.tone_heard:\n            print(\"Tone not heard :(\")\n        else:\n            sleep_time = random.uniform(1, 2.5) # random wait time between 1 and 2.5\n            time.sleep(sleep_time) # wait before next tone is played. #TODO test times\n\n\n    def create_temp_csv(self, id=\"\", **additional_data):\n        \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header\n        and NaN in the second and third line as starting value for each band.\n        (second line: left ear, third line: right ear)\n        ID and additional data will be stored in subsequent lines in the format: key, value.\n\n        Args:\n            id (string, optional): id to be stored, that will later be used for naming exported csv file\n\n        Returns:\n            str: name of temporary file\n        \"\"\"\n        with tfile.NamedTemporaryFile(mode='w+', delete=False, newline='', suffix='.csv') as temp_file:\n            # Define the CSV writer\n            csv_writer = csv.writer(temp_file)\n\n            # Write header\n            csv_writer.writerow(self.freq_bands)\n\n            # Write value NaN for each frequency in second and third row\n            csv_writer.writerow(['NaN' for _ in range(len(self.freq_bands))])\n            csv_writer.writerow(['NaN' for _ in range(len(self.freq_bands))])\n\n            # Write id and additional data\n            if id:\n                csv_writer.writerow([\"id\", id])\n            if additional_data:\n                for key, value in additional_data.items():\n                    csv_writer.writerow([key, value])\n\n            return temp_file.name\n\n\n    def add_to_temp_csv(self, value, frequency, side, temp_filename):\n        \"\"\"Add a value in for a specific frequency to the temporary csv file\n\n        Args:\n            value (str): level in dBHL at specific frequency\n            frequency (str): frequency where value should be added\n            side (str): specify which ear ('l' or 'r')\n            temp_filename (str): name of temporary csv file\n        \"\"\"\n        # Read all rows from the CSV file\n        with open(temp_filename, mode='r', newline='') as temp_file:\n            dict_reader = csv.DictReader(temp_file)\n            rows = list(dict_reader)\n\n        # Update the relevant row based on the side parameter\n        if side == 'l':\n            rows[0][frequency] = value\n        elif side == 'r':\n            rows[1][frequency] = value\n        else:\n            rows[0][frequency] = value\n            rows[1][frequency] = value\n\n        # Write all rows back to the CSV file\n        with open(temp_filename, mode='w', newline='') as temp_file:\n            dict_writer = csv.DictWriter(temp_file, fieldnames=self.freq_bands)\n            dict_writer.writeheader()\n            dict_writer.writerows(rows)\n\n        print(rows[0], rows[1])\n        for row in rows[2:]:\n            print(row['125'], row['250'])\n\n\n    def get_value_from_csv(self, frequency, temp_filename, side='l'):\n        \"\"\"Get the value at a specific frequency from the temporary csv file\n\n        Args:\n            frequency (str): frequency where value is stored\n            temp_filename (str): name of temporary csv file\n            side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'.\n\n        Returns:\n            str: dBHL value at specified frequency\n        \"\"\"\n        with open(temp_filename, mode='r', newline='') as temp_file:\n            dict_reader = csv.DictReader(temp_file)\n            freq_dict = next(dict_reader) # left ear\n            if side == 'r': # go to next line if right side\n                freq_dict = next(dict_reader)    \n            return freq_dict[frequency]\n\n\n    def create_final_csv(self, temp_filename):\n        \"\"\"makes a permanent csv file from the temporary file\n\n        Args:\n            temp_filename (str): name of temporary csv file\n        \"\"\"\n        # read temp file\n        with open(temp_filename, mode='r', newline='') as temp_file:\n            dict_reader = csv.DictReader(temp_file)\n            rows = list(dict_reader)\n        # get date and time    \n        now = datetime.now()\n        date_str = now.strftime(\"%Y%m%d_%H%M%S\")\n        try:\n            id = self.rows[2]['250']\n        except:\n            id = False\n\n        if id:\n            final_filename = id + \"_audiogramm_\" + date_str + \".csv\"\n        else:\n            final_filename = \"missingID_audiogramm_\" + date_str + \".csv\"\n\n\n        with open(final_filename, mode='x', newline='') as final_file:\n            dict_writer = csv.DictWriter(final_file, fieldnames=self.freq_bands)\n            dict_writer.writeheader()\n            dict_writer.writerows(rows)\n\n        print(\"Datei gespeicher als \" + final_filename)\n</code></pre>"},{"location":"api/model/#app.model.Procedure.__init__","title":"<code>__init__(startlevel, signal_length)</code>","text":"<p>The parent class for the familiarization, the main procedure, and the short version</p> <p>Parameters:</p> Name Type Description Default <code>startlevel</code> <code>float</code> <p>starting level of procedure in dBHL</p> required <code>signal_length</code> <code>float</code> <p>length of played signals in seconds</p> required Source code in <code>app\\model.py</code> <pre><code>def __init__(self, startlevel, signal_length):\n    \"\"\"The parent class for the familiarization, the main procedure, and the short version\n\n    Args:\n        startlevel (float): starting level of procedure in dBHL\n        signal_length (float): length of played signals in seconds\n    \"\"\"\n    self.ap = AudioPlayer()\n    self.startlevel = startlevel\n    self.level = startlevel\n    self.signal_length = signal_length\n    self.frequency = 1000\n    self.zero_dbhl = 0.00002 # zero_dbhl in absolute numbers. Needs to be calibrated!\n    self.tone_heard = False\n    self.freq_bands = ['125', '250', '500', '1000', '2000', '4000', '8000']\n    self.side = 'l'\n    self.test_mode = True\n    self.jump_to_end = False\n</code></pre>"},{"location":"api/model/#app.model.Procedure.add_to_temp_csv","title":"<code>add_to_temp_csv(value, frequency, side, temp_filename)</code>","text":"<p>Add a value in for a specific frequency to the temporary csv file</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>level in dBHL at specific frequency</p> required <code>frequency</code> <code>str</code> <p>frequency where value should be added</p> required <code>side</code> <code>str</code> <p>specify which ear ('l' or 'r')</p> required <code>temp_filename</code> <code>str</code> <p>name of temporary csv file</p> required Source code in <code>app\\model.py</code> <pre><code>def add_to_temp_csv(self, value, frequency, side, temp_filename):\n    \"\"\"Add a value in for a specific frequency to the temporary csv file\n\n    Args:\n        value (str): level in dBHL at specific frequency\n        frequency (str): frequency where value should be added\n        side (str): specify which ear ('l' or 'r')\n        temp_filename (str): name of temporary csv file\n    \"\"\"\n    # Read all rows from the CSV file\n    with open(temp_filename, mode='r', newline='') as temp_file:\n        dict_reader = csv.DictReader(temp_file)\n        rows = list(dict_reader)\n\n    # Update the relevant row based on the side parameter\n    if side == 'l':\n        rows[0][frequency] = value\n    elif side == 'r':\n        rows[1][frequency] = value\n    else:\n        rows[0][frequency] = value\n        rows[1][frequency] = value\n\n    # Write all rows back to the CSV file\n    with open(temp_filename, mode='w', newline='') as temp_file:\n        dict_writer = csv.DictWriter(temp_file, fieldnames=self.freq_bands)\n        dict_writer.writeheader()\n        dict_writer.writerows(rows)\n\n    print(rows[0], rows[1])\n    for row in rows[2:]:\n        print(row['125'], row['250'])\n</code></pre>"},{"location":"api/model/#app.model.Procedure.create_final_csv","title":"<code>create_final_csv(temp_filename)</code>","text":"<p>makes a permanent csv file from the temporary file</p> <p>Parameters:</p> Name Type Description Default <code>temp_filename</code> <code>str</code> <p>name of temporary csv file</p> required Source code in <code>app\\model.py</code> <pre><code>def create_final_csv(self, temp_filename):\n    \"\"\"makes a permanent csv file from the temporary file\n\n    Args:\n        temp_filename (str): name of temporary csv file\n    \"\"\"\n    # read temp file\n    with open(temp_filename, mode='r', newline='') as temp_file:\n        dict_reader = csv.DictReader(temp_file)\n        rows = list(dict_reader)\n    # get date and time    \n    now = datetime.now()\n    date_str = now.strftime(\"%Y%m%d_%H%M%S\")\n    try:\n        id = self.rows[2]['250']\n    except:\n        id = False\n\n    if id:\n        final_filename = id + \"_audiogramm_\" + date_str + \".csv\"\n    else:\n        final_filename = \"missingID_audiogramm_\" + date_str + \".csv\"\n\n\n    with open(final_filename, mode='x', newline='') as final_file:\n        dict_writer = csv.DictWriter(final_file, fieldnames=self.freq_bands)\n        dict_writer.writeheader()\n        dict_writer.writerows(rows)\n\n    print(\"Datei gespeicher als \" + final_filename)\n</code></pre>"},{"location":"api/model/#app.model.Procedure.create_temp_csv","title":"<code>create_temp_csv(id='', **additional_data)</code>","text":"<p>Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>string</code> <p>id to be stored, that will later be used for naming exported csv file</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <p>name of temporary file</p> Source code in <code>app\\model.py</code> <pre><code>def create_temp_csv(self, id=\"\", **additional_data):\n    \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header\n    and NaN in the second and third line as starting value for each band.\n    (second line: left ear, third line: right ear)\n    ID and additional data will be stored in subsequent lines in the format: key, value.\n\n    Args:\n        id (string, optional): id to be stored, that will later be used for naming exported csv file\n\n    Returns:\n        str: name of temporary file\n    \"\"\"\n    with tfile.NamedTemporaryFile(mode='w+', delete=False, newline='', suffix='.csv') as temp_file:\n        # Define the CSV writer\n        csv_writer = csv.writer(temp_file)\n\n        # Write header\n        csv_writer.writerow(self.freq_bands)\n\n        # Write value NaN for each frequency in second and third row\n        csv_writer.writerow(['NaN' for _ in range(len(self.freq_bands))])\n        csv_writer.writerow(['NaN' for _ in range(len(self.freq_bands))])\n\n        # Write id and additional data\n        if id:\n            csv_writer.writerow([\"id\", id])\n        if additional_data:\n            for key, value in additional_data.items():\n                csv_writer.writerow([key, value])\n\n        return temp_file.name\n</code></pre>"},{"location":"api/model/#app.model.Procedure.dbhl_to_volume","title":"<code>dbhl_to_volume(dbhl)</code>","text":"<p>Calculate dBHL into absolute numbers</p> <p>Parameters:</p> Name Type Description Default <code>dbhl</code> <code>float</code> <p>value in dBHL</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>value in absolute numbers</p> Source code in <code>app\\model.py</code> <pre><code>def dbhl_to_volume(self, dbhl):\n    \"\"\"Calculate dBHL into absolute numbers\n\n    Args:\n        dbhl (float): value in dBHL\n\n    Returns:\n        float: value in absolute numbers\n    \"\"\"\n    return self.zero_dbhl * 10 ** (dbhl / 10)\n</code></pre>"},{"location":"api/model/#app.model.Procedure.get_value_from_csv","title":"<code>get_value_from_csv(frequency, temp_filename, side='l')</code>","text":"<p>Get the value at a specific frequency from the temporary csv file</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>str</code> <p>frequency where value is stored</p> required <code>temp_filename</code> <code>str</code> <p>name of temporary csv file</p> required <code>side</code> <code>str</code> <p>specify which ear ('l' or 'r'). Defaults to 'l'.</p> <code>'l'</code> <p>Returns:</p> Name Type Description <code>str</code> <p>dBHL value at specified frequency</p> Source code in <code>app\\model.py</code> <pre><code>def get_value_from_csv(self, frequency, temp_filename, side='l'):\n    \"\"\"Get the value at a specific frequency from the temporary csv file\n\n    Args:\n        frequency (str): frequency where value is stored\n        temp_filename (str): name of temporary csv file\n        side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'.\n\n    Returns:\n        str: dBHL value at specified frequency\n    \"\"\"\n    with open(temp_filename, mode='r', newline='') as temp_file:\n        dict_reader = csv.DictReader(temp_file)\n        freq_dict = next(dict_reader) # left ear\n        if side == 'r': # go to next line if right side\n            freq_dict = next(dict_reader)    \n        return freq_dict[frequency]\n</code></pre>"},{"location":"api/model/#app.model.Procedure.play_tone","title":"<code>play_tone()</code>","text":"<p>Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized).</p> Source code in <code>app\\model.py</code> <pre><code>def play_tone(self):\n    \"\"\"Set tone_heard to False, play beep, then wait max 4s for keypress.\n    If key is pressed, set tone_heard to True.\n    Then wait for around about 2s (randomized).\n    \"\"\"\n    self.tone_heard = False\n    print(self.frequency, \"Hz - playing tone at\", self.level, \"dBHL.\")\n    self.ap.play_beep(self.frequency, self.dbhl_to_volume(self.level), self.signal_length, self.side)\n    listener = keyboard.Listener(on_press=self.key_press, on_release=None)\n    listener.start()\n    current_wait_time = 0\n    max_wait_time = 4000 # in ms \n    step_size = 50 # in ms\n    while current_wait_time &lt; max_wait_time and not self.tone_heard: # wait for keypress\n        time.sleep(step_size / 1000)\n        current_wait_time += step_size\n    listener.stop()\n    self.ap.stop()\n    if not self.tone_heard:\n        print(\"Tone not heard :(\")\n    else:\n        sleep_time = random.uniform(1, 2.5) # random wait time between 1 and 2.5\n        time.sleep(sleep_time) # wait before next tone is played. #TODO test times\n</code></pre>"},{"location":"api/model/#app.model.ScreeningProcedure","title":"<code>ScreeningProcedure</code>","text":"<p>               Bases: <code>Procedure</code></p> Source code in <code>app\\model.py</code> <pre><code>class ScreeningProcedure(Procedure):\n    def __init__(self,  temp_filename, signal_length=1):\n        \"\"\"short screening process to check if subject can hear specific frequencies at certain levels\n\n        Args:\n            signal_length (int, optional): length of played signals in seconds. Defaults to 1.\n        \"\"\"\n        super().__init__(startlevel=0, signal_length=signal_length)\n        self.temp_filename = temp_filename\n        self.freq_order = [1000, 2000]#, 4000, 8000, 500, 250, 125]\n\n        #TODO das als default, aber  variabel in der GUI\n        self.freq_levels = {125: 20, 250: 20, 500: 20, 1000: 20, 2000: 20, 4000: 20, 8000: 20}\n\n    def screen_test(self, binaural=False, **additional_data):\n        \"\"\"main functions\n\n        Returns:\n            bool: test successful\n        \"\"\"\n        if not binaural:\n            self.side = 'l'\n            success_l = self.screen_one_ear()\n\n            self.side = 'r'\n            success_r = self.screen_one_ear()\n\n            if success_l and success_r:\n                self.create_final_csv(self.temp_filename)\n                return True\n\n        if binaural:\n            self.side = 'lr'\n            success_lr = self.screen_one_ear()\n\n            if success_lr:\n                self.create_final_csv(self.temp_filename)\n                return True\n\n        return False\n\n\n    def screen_one_ear(self):\n        success = []\n        # test every frequency\n        for f in self.freq_order:\n            print(f\"Testing frequeny {f} Hz\")\n            s = self.screen_one_freq(f)\n            success.append(s)\n\n        if all(success):\n            return True\n\n        else:\n            return False\n\n\n    def screen_one_freq(self, freq):\n        \"\"\"screening for one frequency\n\n        Args:\n            freq (int): frequency to be tested\n            level (int): level at which the frequency is tested\n\n        Returns:\n            bool: tone heard\n        \"\"\"\n        self.frequency = freq\n        self.level = self.freq_levels[freq]\n        self.tone_heard = False\n        self.num_heard = 0\n\n        for i in range(3):\n            self.play_tone()\n\n            if self.tone_heard:\n                self.num_heard += 1\n\n            if self.num_heard &gt;= 2:\n                self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n                return True\n\n        return self.tone_heard\n</code></pre>"},{"location":"api/model/#app.model.ScreeningProcedure.__init__","title":"<code>__init__(temp_filename, signal_length=1)</code>","text":"<p>short screening process to check if subject can hear specific frequencies at certain levels</p> <p>Parameters:</p> Name Type Description Default <code>signal_length</code> <code>int</code> <p>length of played signals in seconds. Defaults to 1.</p> <code>1</code> Source code in <code>app\\model.py</code> <pre><code>def __init__(self,  temp_filename, signal_length=1):\n    \"\"\"short screening process to check if subject can hear specific frequencies at certain levels\n\n    Args:\n        signal_length (int, optional): length of played signals in seconds. Defaults to 1.\n    \"\"\"\n    super().__init__(startlevel=0, signal_length=signal_length)\n    self.temp_filename = temp_filename\n    self.freq_order = [1000, 2000]#, 4000, 8000, 500, 250, 125]\n\n    #TODO das als default, aber  variabel in der GUI\n    self.freq_levels = {125: 20, 250: 20, 500: 20, 1000: 20, 2000: 20, 4000: 20, 8000: 20}\n</code></pre>"},{"location":"api/model/#app.model.ScreeningProcedure.screen_one_freq","title":"<code>screen_one_freq(freq)</code>","text":"<p>screening for one frequency</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>int</code> <p>frequency to be tested</p> required <code>level</code> <code>int</code> <p>level at which the frequency is tested</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>tone heard</p> Source code in <code>app\\model.py</code> <pre><code>def screen_one_freq(self, freq):\n    \"\"\"screening for one frequency\n\n    Args:\n        freq (int): frequency to be tested\n        level (int): level at which the frequency is tested\n\n    Returns:\n        bool: tone heard\n    \"\"\"\n    self.frequency = freq\n    self.level = self.freq_levels[freq]\n    self.tone_heard = False\n    self.num_heard = 0\n\n    for i in range(3):\n        self.play_tone()\n\n        if self.tone_heard:\n            self.num_heard += 1\n\n        if self.num_heard &gt;= 2:\n            self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n            return True\n\n    return self.tone_heard\n</code></pre>"},{"location":"api/model/#app.model.ScreeningProcedure.screen_test","title":"<code>screen_test(binaural=False, **additional_data)</code>","text":"<p>main functions</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>test successful</p> Source code in <code>app\\model.py</code> <pre><code>def screen_test(self, binaural=False, **additional_data):\n    \"\"\"main functions\n\n    Returns:\n        bool: test successful\n    \"\"\"\n    if not binaural:\n        self.side = 'l'\n        success_l = self.screen_one_ear()\n\n        self.side = 'r'\n        success_r = self.screen_one_ear()\n\n        if success_l and success_r:\n            self.create_final_csv(self.temp_filename)\n            return True\n\n    if binaural:\n        self.side = 'lr'\n        success_lr = self.screen_one_ear()\n\n        if success_lr:\n            self.create_final_csv(self.temp_filename)\n            return True\n\n    return False\n</code></pre>"},{"location":"api/model/#app.model.StandardProcedure","title":"<code>StandardProcedure</code>","text":"<p>               Bases: <code>Procedure</code></p> Source code in <code>app\\model.py</code> <pre><code>class StandardProcedure(Procedure):\n\n    def __init__(self, temp_filename, signal_length=1):\n        \"\"\"Standard audiometer process (rising level)\n\n        Args:\n            temp_filename (str): name of temporary csv file where starting level is stored and future values will be stored\n            signal_length (int, optional): length of played signal in seconds. Defaults to 1.\n        \"\"\"\n        startlevel = int(self.get_value_from_csv('1000', temp_filename)) - 10 # 10 dB under level from familiarization\n        super().__init__(startlevel, signal_length)\n        self.temp_filename = temp_filename\n        self.freq_order = [1000]#, 2000, 4000, 8000, 500, 250, 125] # order in which frequencies are tested\n\n\n    def standard_test(self, binaural=False, **additional_data):\n        \"\"\"Main function\n\n        Returns:\n            bool: test successful\n        \"\"\"\n\n        if not binaural:\n            self.side = 'l'\n            success_l = self.standard_test_one_ear()\n\n            if self.test_mode == True and self.jump_to_end == True:\n                self.create_final_csv(self.temp_filename)\n                return True\n\n            self.side = 'r'\n            success_r = self.standard_test_one_ear()\n\n            if success_l and success_r:\n                self.create_final_csv(self.temp_filename)\n                return True\n\n        if binaural:\n            self.side = 'lr'\n            success_lr = self.standard_test_one_ear()\n\n            if self.test_mode == True and self.jump_to_end == True:\n                self.create_final_csv(self.temp_filename)\n                return True\n\n            if success_lr:\n                self.create_final_csv(self.temp_filename)\n                return True\n\n        return False\n\n\n    def standard_test_one_ear(self):\n        \"\"\"Audiometer for one ear\n\n        Returns:\n            bool: test successful\n        \"\"\"\n        success = []\n        # test every frequency\n        for f in self.freq_order:\n            print(f\"Testing frequency {f} Hz\")\n            s = self.standard_test_one_freq(f)\n\n            if self.test_mode == True and self.jump_to_end == True:\n                return True\n\n            success.append(s)\n\n        # retest 1000 Hz (and more frequencies if discrepancy is too high)\n        for f in self.freq_order:\n            print(f\"Retest at frequency {f} Hz\")\n            s = self.standard_test_one_freq(f, retest=True)\n            if s:\n                break\n\n        if all(success):\n            return True\n\n        else:\n            return False\n\n\n    def standard_test_one_freq(self, freq, retest=False):\n        \"\"\"Test for one frequency\n\n        Args:\n            freq (int): frequency at which hearing is tested\n            retest (bool, optional): Is this the retest at the end of step 3 according to DIN. Defaults to False\n\n        Returns:\n            bool: test successful\n        \"\"\"\n        self.tone_heard = False\n        self.frequency = freq\n        self.level = self.startlevel\n\n        # Step 1 (raise tone in 5 dB steps until it is heard)\n        while not self.tone_heard:\n            self.play_tone()\n\n            if self.test_mode == True and self.jump_to_end == True:\n                return True\n\n\n            if not self.tone_heard:\n                self.level += 5\n\n        # Step 2\n        answers = []\n        tries = 0\n\n        while tries &lt; 6:\n            # reduce in 10dB steps until no answer\n            while self.tone_heard:\n                self.level -= 10\n                self.play_tone()\n\n            # raise in 5 dB steps until answer\n            while not self.tone_heard:\n                self.level += 5\n                self.play_tone()\n\n            tries += 1\n            answers.append(self.level)\n            print(f\"Try nr {tries}: level: {self.level}\")\n\n            if answers.count(self.level) &gt;= 2:\n                if retest:\n                    if abs(self.level - int(self.get_value_from_csv(str(self.frequency), self.temp_filename, self.side))) &gt; 5:\n                        self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n                        return False\n                    else:\n                        self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n                        return True\n\n                # TODO Wenn Streuung mehr als 10 dB: Vermerk im Audiogramm\n                self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n                return True\n\n            # no three same answers in five tries\n            if tries == 3:\n                self.level += 10\n                self.play_tone()\n                answers = []\n\n        print(\"Something went wrong, please try from the beginning again.\")\n        return False\n</code></pre>"},{"location":"api/model/#app.model.StandardProcedure.__init__","title":"<code>__init__(temp_filename, signal_length=1)</code>","text":"<p>Standard audiometer process (rising level)</p> <p>Parameters:</p> Name Type Description Default <code>temp_filename</code> <code>str</code> <p>name of temporary csv file where starting level is stored and future values will be stored</p> required <code>signal_length</code> <code>int</code> <p>length of played signal in seconds. Defaults to 1.</p> <code>1</code> Source code in <code>app\\model.py</code> <pre><code>def __init__(self, temp_filename, signal_length=1):\n    \"\"\"Standard audiometer process (rising level)\n\n    Args:\n        temp_filename (str): name of temporary csv file where starting level is stored and future values will be stored\n        signal_length (int, optional): length of played signal in seconds. Defaults to 1.\n    \"\"\"\n    startlevel = int(self.get_value_from_csv('1000', temp_filename)) - 10 # 10 dB under level from familiarization\n    super().__init__(startlevel, signal_length)\n    self.temp_filename = temp_filename\n    self.freq_order = [1000]#, 2000, 4000, 8000, 500, 250, 125] # order in which frequencies are tested\n</code></pre>"},{"location":"api/model/#app.model.StandardProcedure.standard_test","title":"<code>standard_test(binaural=False, **additional_data)</code>","text":"<p>Main function</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>test successful</p> Source code in <code>app\\model.py</code> <pre><code>def standard_test(self, binaural=False, **additional_data):\n    \"\"\"Main function\n\n    Returns:\n        bool: test successful\n    \"\"\"\n\n    if not binaural:\n        self.side = 'l'\n        success_l = self.standard_test_one_ear()\n\n        if self.test_mode == True and self.jump_to_end == True:\n            self.create_final_csv(self.temp_filename)\n            return True\n\n        self.side = 'r'\n        success_r = self.standard_test_one_ear()\n\n        if success_l and success_r:\n            self.create_final_csv(self.temp_filename)\n            return True\n\n    if binaural:\n        self.side = 'lr'\n        success_lr = self.standard_test_one_ear()\n\n        if self.test_mode == True and self.jump_to_end == True:\n            self.create_final_csv(self.temp_filename)\n            return True\n\n        if success_lr:\n            self.create_final_csv(self.temp_filename)\n            return True\n\n    return False\n</code></pre>"},{"location":"api/model/#app.model.StandardProcedure.standard_test_one_ear","title":"<code>standard_test_one_ear()</code>","text":"<p>Audiometer for one ear</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>test successful</p> Source code in <code>app\\model.py</code> <pre><code>def standard_test_one_ear(self):\n    \"\"\"Audiometer for one ear\n\n    Returns:\n        bool: test successful\n    \"\"\"\n    success = []\n    # test every frequency\n    for f in self.freq_order:\n        print(f\"Testing frequency {f} Hz\")\n        s = self.standard_test_one_freq(f)\n\n        if self.test_mode == True and self.jump_to_end == True:\n            return True\n\n        success.append(s)\n\n    # retest 1000 Hz (and more frequencies if discrepancy is too high)\n    for f in self.freq_order:\n        print(f\"Retest at frequency {f} Hz\")\n        s = self.standard_test_one_freq(f, retest=True)\n        if s:\n            break\n\n    if all(success):\n        return True\n\n    else:\n        return False\n</code></pre>"},{"location":"api/model/#app.model.StandardProcedure.standard_test_one_freq","title":"<code>standard_test_one_freq(freq, retest=False)</code>","text":"<p>Test for one frequency</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>int</code> <p>frequency at which hearing is tested</p> required <code>retest</code> <code>bool</code> <p>Is this the retest at the end of step 3 according to DIN. Defaults to False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>test successful</p> Source code in <code>app\\model.py</code> <pre><code>def standard_test_one_freq(self, freq, retest=False):\n    \"\"\"Test for one frequency\n\n    Args:\n        freq (int): frequency at which hearing is tested\n        retest (bool, optional): Is this the retest at the end of step 3 according to DIN. Defaults to False\n\n    Returns:\n        bool: test successful\n    \"\"\"\n    self.tone_heard = False\n    self.frequency = freq\n    self.level = self.startlevel\n\n    # Step 1 (raise tone in 5 dB steps until it is heard)\n    while not self.tone_heard:\n        self.play_tone()\n\n        if self.test_mode == True and self.jump_to_end == True:\n            return True\n\n\n        if not self.tone_heard:\n            self.level += 5\n\n    # Step 2\n    answers = []\n    tries = 0\n\n    while tries &lt; 6:\n        # reduce in 10dB steps until no answer\n        while self.tone_heard:\n            self.level -= 10\n            self.play_tone()\n\n        # raise in 5 dB steps until answer\n        while not self.tone_heard:\n            self.level += 5\n            self.play_tone()\n\n        tries += 1\n        answers.append(self.level)\n        print(f\"Try nr {tries}: level: {self.level}\")\n\n        if answers.count(self.level) &gt;= 2:\n            if retest:\n                if abs(self.level - int(self.get_value_from_csv(str(self.frequency), self.temp_filename, self.side))) &gt; 5:\n                    self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n                    return False\n                else:\n                    self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n                    return True\n\n            # TODO Wenn Streuung mehr als 10 dB: Vermerk im Audiogramm\n            self.add_to_temp_csv(str(self.level), str(self.frequency), self.side, self.temp_filename)\n            return True\n\n        # no three same answers in five tries\n        if tries == 3:\n            self.level += 10\n            self.play_tone()\n            answers = []\n\n    print(\"Something went wrong, please try from the beginning again.\")\n    return False\n</code></pre>"},{"location":"api/ui/","title":"ui Module","text":""},{"location":"api/ui/#app.ui.App","title":"<code>App</code>","text":"<p>               Bases: <code>Window</code></p> Source code in <code>app\\ui.py</code> <pre><code>class App(tb.Window):\n\n    def __init__(self, familiarization_func, program_funcs:dict):\n        \"\"\"Main application window. Contains all pages and controls the flow of the program.\n\n        Args:\n            familiarization_func (function): function to be called for familiarization\n            *program_funcs (function): function(s) to be called for the main program\n        \"\"\"\n        super().__init__(themename=\"superhero\")  # Set/change the theme Link: https://ttkbootstrap.readthedocs.io/en/latest/themes/dark/\n\n        # General theme settings\n        self.title(\"Sound Player\")\n        self.geometry(\"800x800\")\n        self.minsize(650,650)\n        self.attributes('-fullscreen', True)  #for fullscreen mode\n        self.bind(\"&lt;Escape&gt;\", self.exit_fullscreen)\n\n        #self.set_icon(\"app/00_TUBerlin_Logo_rot.jpg\") change the icon maybe? #TODO\n\n        #this might solve the different GUI on macOS LINUX and WINDOWS problem... #TODO\n        self.tk.call('tk', 'scaling', 2.0)  # Adjust for high-DPI displays\n        '''\n        # Set explicit fonts\n        self.style = ttk.Style()\n        self.style.configure('TLabel', font=('Arial', 12))\n        self.style.configure('TButton', font=('Arial', 12))\n        self.style.configure('TCombobox', font=('Arial', 12))\n        '''\n\n        # Dictionary to store all pages\n        self.program_funcs = program_funcs\n        self.frames = {}\n        self.binaural_test = False\n\n        # Pages, where the user can interact\n        for F in (MainMenu, FamiliarizationPage, ProgramPage, ResultPage):\n            frame = F(self)\n            self.frames[F] = frame\n            frame.grid(row=0, column=0, sticky=\"nsew\")\n\n        # View during familiarization\n        frame = DuringFamiliarizationView(self, familiarization_func)\n        self.frames[DuringFamiliarizationView] = frame\n        frame.grid(row=0, column=0, sticky=\"nsew\")\n\n        # View during programs\n        for name, program_func in program_funcs.items():\n            frame = DuringProcedureView(self, \n                                        program_func,\n                                        text=\"Programm l\u00e4uft...\")\n            self.frames[name] = frame\n            frame.grid(row=0, column=0, sticky=\"nsew\")\n\n        # Show MainMenu first\n        self.show_frame(MainMenu)\n\n        # Create menubar\n        self.create_menubar()\n\n        # Override the close button protocol\n        self.protocol(\"WM_DELETE_WINDOW\", self.on_closing)\n\n        self.grid_rowconfigure(0, weight=1)\n        self.grid_columnconfigure(0, weight=1)\n\n    def create_menubar(self):\n        menubar = tk.Menu(self)\n        self.config(menu=menubar)\n\n        file_menu = tk.Menu(menubar, tearoff=0)\n        file_menu.add_command(label=\"Startseite\", command=lambda: self.show_frame(MainMenu))\n\n        # Settings for chaning the theme ##i've randomly selected 4 themes (2 dark and 2 lighthttps://ttkbootstrap.readthedocs.io/en/latest/themes/dark/\n        ChangeTheme = tk.Menu(file_menu, tearoff=0)\n        ChangeTheme.add_command(label=\"theme 1\", command=lambda: self.change_theme(\"superhero\"))\n        ChangeTheme.add_command(label=\"theme 2\", command=lambda: self.change_theme(\"solar\"))\n        ChangeTheme.add_command(label=\"theme 3\", command=lambda: self.change_theme(\"cosmo\"))\n        ChangeTheme.add_command(label=\"theme 4\", command=lambda: self.change_theme(\"sandstone\"))\n        file_menu.add_cascade(label=\"change theme\", menu=ChangeTheme)\n\n        file_menu.add_separator()\n        file_menu.add_command(label=\"Exit\", command=self.on_closing)\n        menubar.add_cascade(label=\"File\", menu=file_menu)\n\n    def change_theme(self, theme_name):\n        \"\"\"Change to the specified theme\"\"\"\n        current_theme = self.style.theme_use()\n\n        if current_theme == theme_name:\n            messagebox.showwarning(\"Ops..\", \"This theme is already in use.\")\n        else:\n            self.style.theme_use(theme_name)\n\n    def exit_fullscreen(self, event=None):\n        self.attributes('-fullscreen', False)\n\n    def set_icon(self, path):\n        \"\"\"Set the window icon using Pillow\"\"\"\n        img = Image.open(path)\n        photo = ImageTk.PhotoImage(img)\n        self.iconphoto(False, photo)          \n\n    def show_frame(self, page):\n        \"\"\"Show a frame for the given page name\n\n        Args:\n            page(class): class of the page to be shown\n        \"\"\"\n        frame = self.frames[page]\n        frame.tkraise()\n\n    def wait_for_process(self, process, callback):\n        \"\"\"Starts a process in a new thread and calls a callback function when the process is done\n\n        Args:\n            process (function): function to be called\n            callback (function): function to be called when process is done\n        \"\"\"\n        threading.Thread(target=self.run_process, args=(process, callback)).start()\n\n    def run_process(self, process, callback):\n        \"\"\"Runs a process and calls a callback function when the process is done\n\n        Args:\n            process (function): function to be called\n            callback (function): function to be called when process is done\n        \"\"\"\n        process()\n        self.after(0, callback)\n\n    def on_closing(self):\n        if messagebox.askyesno(title=\"Quit\", message=\"M\u00f6chten Sie wirklich das Programm beenden?\"):\n            self.destroy()\n</code></pre>"},{"location":"api/ui/#app.ui.App.__init__","title":"<code>__init__(familiarization_func, program_funcs)</code>","text":"<p>Main application window. Contains all pages and controls the flow of the program.</p> <p>Parameters:</p> Name Type Description Default <code>familiarization_func</code> <code>function</code> <p>function to be called for familiarization</p> required <code>*program_funcs</code> <code>function</code> <p>function(s) to be called for the main program</p> required Source code in <code>app\\ui.py</code> <pre><code>def __init__(self, familiarization_func, program_funcs:dict):\n    \"\"\"Main application window. Contains all pages and controls the flow of the program.\n\n    Args:\n        familiarization_func (function): function to be called for familiarization\n        *program_funcs (function): function(s) to be called for the main program\n    \"\"\"\n    super().__init__(themename=\"superhero\")  # Set/change the theme Link: https://ttkbootstrap.readthedocs.io/en/latest/themes/dark/\n\n    # General theme settings\n    self.title(\"Sound Player\")\n    self.geometry(\"800x800\")\n    self.minsize(650,650)\n    self.attributes('-fullscreen', True)  #for fullscreen mode\n    self.bind(\"&lt;Escape&gt;\", self.exit_fullscreen)\n\n    #self.set_icon(\"app/00_TUBerlin_Logo_rot.jpg\") change the icon maybe? #TODO\n\n    #this might solve the different GUI on macOS LINUX and WINDOWS problem... #TODO\n    self.tk.call('tk', 'scaling', 2.0)  # Adjust for high-DPI displays\n    '''\n    # Set explicit fonts\n    self.style = ttk.Style()\n    self.style.configure('TLabel', font=('Arial', 12))\n    self.style.configure('TButton', font=('Arial', 12))\n    self.style.configure('TCombobox', font=('Arial', 12))\n    '''\n\n    # Dictionary to store all pages\n    self.program_funcs = program_funcs\n    self.frames = {}\n    self.binaural_test = False\n\n    # Pages, where the user can interact\n    for F in (MainMenu, FamiliarizationPage, ProgramPage, ResultPage):\n        frame = F(self)\n        self.frames[F] = frame\n        frame.grid(row=0, column=0, sticky=\"nsew\")\n\n    # View during familiarization\n    frame = DuringFamiliarizationView(self, familiarization_func)\n    self.frames[DuringFamiliarizationView] = frame\n    frame.grid(row=0, column=0, sticky=\"nsew\")\n\n    # View during programs\n    for name, program_func in program_funcs.items():\n        frame = DuringProcedureView(self, \n                                    program_func,\n                                    text=\"Programm l\u00e4uft...\")\n        self.frames[name] = frame\n        frame.grid(row=0, column=0, sticky=\"nsew\")\n\n    # Show MainMenu first\n    self.show_frame(MainMenu)\n\n    # Create menubar\n    self.create_menubar()\n\n    # Override the close button protocol\n    self.protocol(\"WM_DELETE_WINDOW\", self.on_closing)\n\n    self.grid_rowconfigure(0, weight=1)\n    self.grid_columnconfigure(0, weight=1)\n</code></pre>"},{"location":"api/ui/#app.ui.App.change_theme","title":"<code>change_theme(theme_name)</code>","text":"<p>Change to the specified theme</p> Source code in <code>app\\ui.py</code> <pre><code>def change_theme(self, theme_name):\n    \"\"\"Change to the specified theme\"\"\"\n    current_theme = self.style.theme_use()\n\n    if current_theme == theme_name:\n        messagebox.showwarning(\"Ops..\", \"This theme is already in use.\")\n    else:\n        self.style.theme_use(theme_name)\n</code></pre>"},{"location":"api/ui/#app.ui.App.run_process","title":"<code>run_process(process, callback)</code>","text":"<p>Runs a process and calls a callback function when the process is done</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>function</code> <p>function to be called</p> required <code>callback</code> <code>function</code> <p>function to be called when process is done</p> required Source code in <code>app\\ui.py</code> <pre><code>def run_process(self, process, callback):\n    \"\"\"Runs a process and calls a callback function when the process is done\n\n    Args:\n        process (function): function to be called\n        callback (function): function to be called when process is done\n    \"\"\"\n    process()\n    self.after(0, callback)\n</code></pre>"},{"location":"api/ui/#app.ui.App.set_icon","title":"<code>set_icon(path)</code>","text":"<p>Set the window icon using Pillow</p> Source code in <code>app\\ui.py</code> <pre><code>def set_icon(self, path):\n    \"\"\"Set the window icon using Pillow\"\"\"\n    img = Image.open(path)\n    photo = ImageTk.PhotoImage(img)\n    self.iconphoto(False, photo)          \n</code></pre>"},{"location":"api/ui/#app.ui.App.show_frame","title":"<code>show_frame(page)</code>","text":"<p>Show a frame for the given page name</p> <p>Parameters:</p> Name Type Description Default <code>page(class)</code> <p>class of the page to be shown</p> required Source code in <code>app\\ui.py</code> <pre><code>def show_frame(self, page):\n    \"\"\"Show a frame for the given page name\n\n    Args:\n        page(class): class of the page to be shown\n    \"\"\"\n    frame = self.frames[page]\n    frame.tkraise()\n</code></pre>"},{"location":"api/ui/#app.ui.App.wait_for_process","title":"<code>wait_for_process(process, callback)</code>","text":"<p>Starts a process in a new thread and calls a callback function when the process is done</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>function</code> <p>function to be called</p> required <code>callback</code> <code>function</code> <p>function to be called when process is done</p> required Source code in <code>app\\ui.py</code> <pre><code>def wait_for_process(self, process, callback):\n    \"\"\"Starts a process in a new thread and calls a callback function when the process is done\n\n    Args:\n        process (function): function to be called\n        callback (function): function to be called when process is done\n    \"\"\"\n    threading.Thread(target=self.run_process, args=(process, callback)).start()\n</code></pre>"},{"location":"api/ui/#app.ui.DuringFamiliarizationView","title":"<code>DuringFamiliarizationView</code>","text":"<p>               Bases: <code>Frame</code></p> Source code in <code>app\\ui.py</code> <pre><code>class DuringFamiliarizationView(ttk.Frame):\n\n    def __init__(self, parent, familiarization_func):\n        \"\"\"View during familiarization process\n\n        Args:\n            parent (App): parent application\n            familiarization_func (function): function to be called for familiarization\"\"\"\n        super().__init__(parent)\n        self.parent = parent\n        self.program = familiarization_func \n        self.text = \"Eingew\u00f6hnung l\u00e4uft...\"\n        self.create_widgets()\n\n    def create_widgets(self):\n        \"\"\"Creates the widgets for the view\n        \"\"\"\n        self.info = ttk.Label(self, text=self.text)\n        self.info.grid(row=0, column=0, padx=10, pady=10)\n</code></pre>"},{"location":"api/ui/#app.ui.DuringFamiliarizationView.__init__","title":"<code>__init__(parent, familiarization_func)</code>","text":"<p>View during familiarization process</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>App</code> <p>parent application</p> required <code>familiarization_func</code> <code>function</code> <p>function to be called for familiarization</p> required Source code in <code>app\\ui.py</code> <pre><code>def __init__(self, parent, familiarization_func):\n    \"\"\"View during familiarization process\n\n    Args:\n        parent (App): parent application\n        familiarization_func (function): function to be called for familiarization\"\"\"\n    super().__init__(parent)\n    self.parent = parent\n    self.program = familiarization_func \n    self.text = \"Eingew\u00f6hnung l\u00e4uft...\"\n    self.create_widgets()\n</code></pre>"},{"location":"api/ui/#app.ui.DuringFamiliarizationView.create_widgets","title":"<code>create_widgets()</code>","text":"<p>Creates the widgets for the view</p> Source code in <code>app\\ui.py</code> <pre><code>def create_widgets(self):\n    \"\"\"Creates the widgets for the view\n    \"\"\"\n    self.info = ttk.Label(self, text=self.text)\n    self.info.grid(row=0, column=0, padx=10, pady=10)\n</code></pre>"},{"location":"api/ui/#app.ui.DuringProcedureView","title":"<code>DuringProcedureView</code>","text":"<p>               Bases: <code>Frame</code></p> Source code in <code>app\\ui.py</code> <pre><code>class DuringProcedureView(ttk.Frame):\n\n    def __init__(self, parent, program_func, text):\n        \"\"\"View during main program\n\n        Args:\n            parent (App): parent application\n            program_func (function): function to be called for the main program\n            text (str): text to be displayed\n        \"\"\"\n        super().__init__(parent)\n        self.parent = parent\n        self.program = program_func \n        self.text = text\n        self.create_widgets()\n\n    def create_widgets(self):\n        \"\"\"Creates the widgets for the view\n        \"\"\"\n        self.info = ttk.Label(self, text=self.text)\n        self.info.grid(row=0, column=0, padx=10, pady=10)\n</code></pre>"},{"location":"api/ui/#app.ui.DuringProcedureView.__init__","title":"<code>__init__(parent, program_func, text)</code>","text":"<p>View during main program</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>App</code> <p>parent application</p> required <code>program_func</code> <code>function</code> <p>function to be called for the main program</p> required <code>text</code> <code>str</code> <p>text to be displayed</p> required Source code in <code>app\\ui.py</code> <pre><code>def __init__(self, parent, program_func, text):\n    \"\"\"View during main program\n\n    Args:\n        parent (App): parent application\n        program_func (function): function to be called for the main program\n        text (str): text to be displayed\n    \"\"\"\n    super().__init__(parent)\n    self.parent = parent\n    self.program = program_func \n    self.text = text\n    self.create_widgets()\n</code></pre>"},{"location":"api/ui/#app.ui.DuringProcedureView.create_widgets","title":"<code>create_widgets()</code>","text":"<p>Creates the widgets for the view</p> Source code in <code>app\\ui.py</code> <pre><code>def create_widgets(self):\n    \"\"\"Creates the widgets for the view\n    \"\"\"\n    self.info = ttk.Label(self, text=self.text)\n    self.info.grid(row=0, column=0, padx=10, pady=10)\n</code></pre>"},{"location":"api/ui/#app.ui.FamiliarizationPage","title":"<code>FamiliarizationPage</code>","text":"<p>               Bases: <code>Frame</code></p> Source code in <code>app\\ui.py</code> <pre><code>class FamiliarizationPage(ttk.Frame):\n\n    def __init__(self, parent):\n        \"\"\"Page for starting the familiarization process\n\n        Args:\n            parent (App): parent application\n        \"\"\"\n        super().__init__(parent)\n        self.parent = parent\n        self.create_widgets()\n\n    def create_widgets(self):\n        \"\"\"Creates the widgets for the page\n        \"\"\"\n        button_width = 25 \n\n        self.label = ttk.Label(self, text=text_Familiarization, font=('Arial', 16))\n        self.label.pack(padx=10, pady=10)\n        self.play_button = ttk.Button(self, \n                                      text=\"Starte Eingew\u00f6hnung\", \n                                      command=self.run_familiarization, \n                                      width=button_width)\n        self.play_button.pack(padx=10, pady=10)\n        self.go_back_button = ttk.Button(self, \n                                         text=\"zur\u00fcck\", \n                                         command=lambda: self.parent.show_frame(MainMenu), \n                                         width=button_width)\n        self.go_back_button.pack(padx=10, pady=10)\n\n        for widget in self.winfo_children():\n            widget.pack_configure(anchor='center')\n\n    def run_familiarization(self):\n        \"\"\"Runs the familiarization process\n        \"\"\"\n        self.parent.show_frame(DuringFamiliarizationView)\n        self.parent.wait_for_process(self.parent.frames[DuringFamiliarizationView].program, \n                                     lambda: self.parent.show_frame(ProgramPage))\n</code></pre>"},{"location":"api/ui/#app.ui.FamiliarizationPage.__init__","title":"<code>__init__(parent)</code>","text":"<p>Page for starting the familiarization process</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>App</code> <p>parent application</p> required Source code in <code>app\\ui.py</code> <pre><code>def __init__(self, parent):\n    \"\"\"Page for starting the familiarization process\n\n    Args:\n        parent (App): parent application\n    \"\"\"\n    super().__init__(parent)\n    self.parent = parent\n    self.create_widgets()\n</code></pre>"},{"location":"api/ui/#app.ui.FamiliarizationPage.create_widgets","title":"<code>create_widgets()</code>","text":"<p>Creates the widgets for the page</p> Source code in <code>app\\ui.py</code> <pre><code>def create_widgets(self):\n    \"\"\"Creates the widgets for the page\n    \"\"\"\n    button_width = 25 \n\n    self.label = ttk.Label(self, text=text_Familiarization, font=('Arial', 16))\n    self.label.pack(padx=10, pady=10)\n    self.play_button = ttk.Button(self, \n                                  text=\"Starte Eingew\u00f6hnung\", \n                                  command=self.run_familiarization, \n                                  width=button_width)\n    self.play_button.pack(padx=10, pady=10)\n    self.go_back_button = ttk.Button(self, \n                                     text=\"zur\u00fcck\", \n                                     command=lambda: self.parent.show_frame(MainMenu), \n                                     width=button_width)\n    self.go_back_button.pack(padx=10, pady=10)\n\n    for widget in self.winfo_children():\n        widget.pack_configure(anchor='center')\n</code></pre>"},{"location":"api/ui/#app.ui.FamiliarizationPage.run_familiarization","title":"<code>run_familiarization()</code>","text":"<p>Runs the familiarization process</p> Source code in <code>app\\ui.py</code> <pre><code>def run_familiarization(self):\n    \"\"\"Runs the familiarization process\n    \"\"\"\n    self.parent.show_frame(DuringFamiliarizationView)\n    self.parent.wait_for_process(self.parent.frames[DuringFamiliarizationView].program, \n                                 lambda: self.parent.show_frame(ProgramPage))\n</code></pre>"},{"location":"api/ui/#app.ui.ProgramPage","title":"<code>ProgramPage</code>","text":"<p>               Bases: <code>Frame</code></p> Source code in <code>app\\ui.py</code> <pre><code>class ProgramPage(ttk.Frame):\n\n    def __init__(self, parent):\n        \"\"\"Page for starting the main program\n\n        Args:\n            parent (App): parent application\n        \"\"\"\n        super().__init__(parent)\n        self.parent = parent\n        self.selected_option = None \n        self.create_widgets()\n\n    def create_widgets(self):\n        \"\"\"Creates the widgets for the page\n        \"\"\"\n        self.start_button = ttk.Button(self, text=\"Starte Prozess\", command=self.run_program)\n        self.start_button.pack(padx=10, pady=200)\n\n        for widget in self.winfo_children():\n            widget.pack_configure(anchor='center')\n\n    def run_program(self):\n        \"\"\"Runs the main program\n        \"\"\"\n        self.selected_option = self.parent.frames[MainMenu].selected_option\n        self.binaural_test = self.parent.frames[MainMenu].binaural_test.get()\n        self.parent.show_frame(self.selected_option)\n        self.parent.wait_for_process(lambda: self.parent.frames[self.selected_option].program(self.binaural_test),\n                                     lambda: self.parent.show_frame(ResultPage))\n</code></pre>"},{"location":"api/ui/#app.ui.ProgramPage.__init__","title":"<code>__init__(parent)</code>","text":"<p>Page for starting the main program</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>App</code> <p>parent application</p> required Source code in <code>app\\ui.py</code> <pre><code>def __init__(self, parent):\n    \"\"\"Page for starting the main program\n\n    Args:\n        parent (App): parent application\n    \"\"\"\n    super().__init__(parent)\n    self.parent = parent\n    self.selected_option = None \n    self.create_widgets()\n</code></pre>"},{"location":"api/ui/#app.ui.ProgramPage.create_widgets","title":"<code>create_widgets()</code>","text":"<p>Creates the widgets for the page</p> Source code in <code>app\\ui.py</code> <pre><code>def create_widgets(self):\n    \"\"\"Creates the widgets for the page\n    \"\"\"\n    self.start_button = ttk.Button(self, text=\"Starte Prozess\", command=self.run_program)\n    self.start_button.pack(padx=10, pady=200)\n\n    for widget in self.winfo_children():\n        widget.pack_configure(anchor='center')\n</code></pre>"},{"location":"api/ui/#app.ui.ProgramPage.run_program","title":"<code>run_program()</code>","text":"<p>Runs the main program</p> Source code in <code>app\\ui.py</code> <pre><code>def run_program(self):\n    \"\"\"Runs the main program\n    \"\"\"\n    self.selected_option = self.parent.frames[MainMenu].selected_option\n    self.binaural_test = self.parent.frames[MainMenu].binaural_test.get()\n    self.parent.show_frame(self.selected_option)\n    self.parent.wait_for_process(lambda: self.parent.frames[self.selected_option].program(self.binaural_test),\n                                 lambda: self.parent.show_frame(ResultPage))\n</code></pre>"},{"location":"api/ui/#app.ui.ResultPage","title":"<code>ResultPage</code>","text":"<p>               Bases: <code>Frame</code></p> Source code in <code>app\\ui.py</code> <pre><code>class ResultPage(ttk.Frame):\n\n    def __init__(self, parent):\n        \"\"\"Page for showing the results of the program\n\n        Args:\n            parent (App): parent application\"\"\"\n\n        super().__init__(parent)\n        self.parent = parent\n\n        freq = [125, 250, 500, 1000, 2000, 4000, 8000]\n        dummy_right = [15, 20, 25, 30, 35, 40, 45]\n        dummy_left = [10, 15, 20, 25, 30, 35, 40]\n\n        # Create audiogram plot\n        fig = create_audiogram(freq, dummy_right, dummy_left)\n\n        # Create widgets\n        self.create_widgets(fig)\n\n    def create_widgets(self,fig):\n        \"\"\"Creates the widgets for the view`\n        \"\"\"\n        self.info = ttk.Label(self, text=\"Ergebnisse\", font=('Arial', 18))\n        self.info.pack(padx=10, pady=10)\n\n        # Set the title on the parent window\n        self.parent.title(\"Audiogram\")\n\n        # Display the plot\n        canvas = FigureCanvasTkAgg(fig, self)\n        canvas.draw()\n        canvas.get_tk_widget().pack(side=tk.TOP, expand=0)\n\n        self.BackToMainMenu = ttk.Button(self, text=\"Zur\u00fcck zur Startseite\", command=lambda: self.parent.show_frame(MainMenu))\n        self.BackToMainMenu.pack(padx=10, pady=10)\n\n    def back_to_MainMenu(self):\n        self.parent.show_frame(MainMenu)\n</code></pre>"},{"location":"api/ui/#app.ui.ResultPage.__init__","title":"<code>__init__(parent)</code>","text":"<p>Page for showing the results of the program</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>App</code> <p>parent application</p> required Source code in <code>app\\ui.py</code> <pre><code>def __init__(self, parent):\n    \"\"\"Page for showing the results of the program\n\n    Args:\n        parent (App): parent application\"\"\"\n\n    super().__init__(parent)\n    self.parent = parent\n\n    freq = [125, 250, 500, 1000, 2000, 4000, 8000]\n    dummy_right = [15, 20, 25, 30, 35, 40, 45]\n    dummy_left = [10, 15, 20, 25, 30, 35, 40]\n\n    # Create audiogram plot\n    fig = create_audiogram(freq, dummy_right, dummy_left)\n\n    # Create widgets\n    self.create_widgets(fig)\n</code></pre>"},{"location":"api/ui/#app.ui.ResultPage.create_widgets","title":"<code>create_widgets(fig)</code>","text":"<p>Creates the widgets for the view`</p> Source code in <code>app\\ui.py</code> <pre><code>def create_widgets(self,fig):\n    \"\"\"Creates the widgets for the view`\n    \"\"\"\n    self.info = ttk.Label(self, text=\"Ergebnisse\", font=('Arial', 18))\n    self.info.pack(padx=10, pady=10)\n\n    # Set the title on the parent window\n    self.parent.title(\"Audiogram\")\n\n    # Display the plot\n    canvas = FigureCanvasTkAgg(fig, self)\n    canvas.draw()\n    canvas.get_tk_widget().pack(side=tk.TOP, expand=0)\n\n    self.BackToMainMenu = ttk.Button(self, text=\"Zur\u00fcck zur Startseite\", command=lambda: self.parent.show_frame(MainMenu))\n    self.BackToMainMenu.pack(padx=10, pady=10)\n</code></pre>"},{"location":"user_guide/hardware/","title":"Hardware Requirements","text":""},{"location":"user_guide/installation/","title":"Installation","text":"<p>To install the Audiometer, run:</p>"},{"location":"user_guide/intro/","title":"Introduction","text":"<p>This is the introduction to the Audiometer user guide.</p> <p>Installation</p> <p>Hardware Requirements</p>"}]}