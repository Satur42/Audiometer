{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Willkommen zur Audiometer-Dokumentation \u00b6 Willkommen zur Audiometer-Dokumentation! Hier finden Sie alle Informationen zur Nutzung und den Funktionen der Audiometer-Anwendung. Diese Dokumentation enth\u00e4lt Anleitungen zur Installation, Nutzung und Fehlerbehebung. Kapitel \u00b6 Benutzerhandbuch Reference Manual \u00dcber Audiometer Welcome to Documentation of Audiometer \u00b6 Welcome to the documentation of Audiometer! Here you will find all information on the use and functions of the Audiometer application. This documentation contains instructions for installation, use and troubleshooting. Sections \u00b6 User Guide Reference Manual About","title":"Start"},{"location":"#willkommen-zur-audiometer-dokumentation","text":"Willkommen zur Audiometer-Dokumentation! Hier finden Sie alle Informationen zur Nutzung und den Funktionen der Audiometer-Anwendung. Diese Dokumentation enth\u00e4lt Anleitungen zur Installation, Nutzung und Fehlerbehebung.","title":"Willkommen zur Audiometer-Dokumentation"},{"location":"#kapitel","text":"Benutzerhandbuch Reference Manual \u00dcber Audiometer","title":"Kapitel"},{"location":"#welcome-to-documentation-of-audiometer","text":"Welcome to the documentation of Audiometer! Here you will find all information on the use and functions of the Audiometer application. This documentation contains instructions for installation, use and troubleshooting.","title":"Welcome to Documentation of Audiometer"},{"location":"#sections","text":"User Guide Reference Manual About","title":"Sections"},{"location":"about/","text":"Technische Universit\u00e4t Berlin Dieses Repository wurde im Rahmen des Projektes \"Python und Akustik\" im Sommersemester 2024 erstellt. Fakult\u00e4t V - Verkehrs- und Maschinensysteme Institut f\u00fcr Str\u00f6mungsmechanik und Technische Akustik Projekt Python und Akustik Stra\u00dfe des 17. Juni 135 10623 Berlin","title":"\u00dcber Audiometer (About)"},{"location":"api/audio_player/","text":"audio_player Module \u00b6 This module is used to play audio tones with a specified frequency, volume and duration. AudioPlayer \u00b6 Source code in app\\audio_player.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class AudioPlayer : def __init__ ( self ): \"\"\"Creates an audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False def generate_tone ( self ) -> np . array : \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone def play_beep ( self , frequency : int , volume : float , duration : int , channel : str = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs ) def stop ( self ): \"\"\"Stops the current playback. \"\"\" sd . stop () def int_or_str ( self , text : str ) -> int : \"\"\"Helper function for argument parsing. \"\"\" try : return int ( text ) except ValueError : return text def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ] __init__ \u00b6 __init__ () Creates an audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. Source code in app\\audio_player.py 8 9 10 11 12 13 14 15 16 17 def __init__ ( self ): \"\"\"Creates an audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False generate_tone \u00b6 generate_tone () Generates a sine tone with current audio player settings. Returns: array ( array ) \u2013 sine wave as numpy array Source code in app\\audio_player.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def generate_tone ( self ) -> np . array : \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone get_device_samplerate \u00b6 get_device_samplerate () Gets current samplerate from the selected audio output device. Returns: float \u2013 samplerate of current sound device Source code in app\\audio_player.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ] int_or_str \u00b6 int_or_str ( text ) Helper function for argument parsing. Source code in app\\audio_player.py 68 69 70 71 72 73 74 def int_or_str ( self , text : str ) -> int : \"\"\"Helper function for argument parsing. \"\"\" try : return int ( text ) except ValueError : return text play_beep \u00b6 play_beep ( frequency , volume , duration , channel = 'lr' ) Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Parameters: frequency ( int ) \u2013 frequency in Hz volume ( float ) \u2013 volume multiplier (between 0 and 1) duration ( int ) \u2013 duration of the beep in seconds channel ( string , default: 'lr' ) \u2013 'l', 'r' or 'lr' for only left, only right or both channels respectively Source code in app\\audio_player.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def play_beep ( self , frequency : int , volume : float , duration : int , channel : str = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs ) stop \u00b6 stop () Stops the current playback. Source code in app\\audio_player.py 63 64 65 66 def stop ( self ): \"\"\"Stops the current playback. \"\"\" sd . stop ()","title":"audio_player"},{"location":"api/audio_player/#audio_player-module","text":"This module is used to play audio tones with a specified frequency, volume and duration.","title":"audio_player Module"},{"location":"api/audio_player/#app.audio_player.AudioPlayer","text":"Source code in app\\audio_player.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class AudioPlayer : def __init__ ( self ): \"\"\"Creates an audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False def generate_tone ( self ) -> np . array : \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone def play_beep ( self , frequency : int , volume : float , duration : int , channel : str = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs ) def stop ( self ): \"\"\"Stops the current playback. \"\"\" sd . stop () def int_or_str ( self , text : str ) -> int : \"\"\"Helper function for argument parsing. \"\"\" try : return int ( text ) except ValueError : return text def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ]","title":"AudioPlayer"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.__init__","text":"__init__ () Creates an audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. Source code in app\\audio_player.py 8 9 10 11 12 13 14 15 16 17 def __init__ ( self ): \"\"\"Creates an audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False","title":"__init__"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.generate_tone","text":"generate_tone () Generates a sine tone with current audio player settings. Returns: array ( array ) \u2013 sine wave as numpy array Source code in app\\audio_player.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def generate_tone ( self ) -> np . array : \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone","title":"generate_tone"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.get_device_samplerate","text":"get_device_samplerate () Gets current samplerate from the selected audio output device. Returns: float \u2013 samplerate of current sound device Source code in app\\audio_player.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ]","title":"get_device_samplerate"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.int_or_str","text":"int_or_str ( text ) Helper function for argument parsing. Source code in app\\audio_player.py 68 69 70 71 72 73 74 def int_or_str ( self , text : str ) -> int : \"\"\"Helper function for argument parsing. \"\"\" try : return int ( text ) except ValueError : return text","title":"int_or_str"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.play_beep","text":"play_beep ( frequency , volume , duration , channel = 'lr' ) Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Parameters: frequency ( int ) \u2013 frequency in Hz volume ( float ) \u2013 volume multiplier (between 0 and 1) duration ( int ) \u2013 duration of the beep in seconds channel ( string , default: 'lr' ) \u2013 'l', 'r' or 'lr' for only left, only right or both channels respectively Source code in app\\audio_player.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def play_beep ( self , frequency : int , volume : float , duration : int , channel : str = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs )","title":"play_beep"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.stop","text":"stop () Stops the current playback. Source code in app\\audio_player.py 63 64 65 66 def stop ( self ): \"\"\"Stops the current playback. \"\"\" sd . stop ()","title":"stop"},{"location":"api/audiogram/","text":"audiogram Module \u00b6 This module contains the function create_audiogram, which creates an audiogram based on the given frequencies and hearing threshold values with custom x-axis labels. create_audiogram \u00b6 create_audiogram ( freqs , left_values = None , right_values = None , binaural = False , name = 'audiogram.png' , freq_levels = freq_levels , subtitle = None ) Creates an audiogram based on the given frequencies and hearing threshold values with custom x-axis labels. Parameters: freqs ( list of int ) \u2013 A list of frequencies in Hz. left_values ( list of int , default: None ) \u2013 A list of hearing thresholds in dB HL for the left ear. Defaults to None. right_values ( list of int , default: None ) \u2013 A list of hearing thresholds in dB HL for the right ear. Defaults to None. binaural ( bool , default: False ) \u2013 Whether the audiogram is made from binaural test values. Defaults to False. name ( str , default: 'audiogram.png' ) \u2013 The name of the saved audiogram file. Defaults to \"audiogram.png\". freq_levels ( dict , default: freq_levels ) \u2013 A dictionary mapping frequencies to their target values. Defaults to freq_levels. subtitle ( str , default: None ) \u2013 A subtitle for the audiogram. Defaults to None. Source code in app\\audiogram.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def create_audiogram ( freqs : list , left_values : list = None , right_values : list = None , binaural : bool = False , name : str = \"audiogram.png\" , freq_levels : dict = freq_levels , subtitle : str = None ): \"\"\" Creates an audiogram based on the given frequencies and hearing threshold values with custom x-axis labels. Args: freqs (list of int): A list of frequencies in Hz. left_values (list of int, optional): A list of hearing thresholds in dB HL for the left ear. Defaults to None. right_values (list of int, optional): A list of hearing thresholds in dB HL for the right ear. Defaults to None. binaural (bool, optional): Whether the audiogram is made from binaural test values. Defaults to False. name (str, optional): The name of the saved audiogram file. Defaults to \"audiogram.png\". freq_levels (dict, optional): A dictionary mapping frequencies to their target values. Defaults to freq_levels. subtitle (str, optional): A subtitle for the audiogram. Defaults to None. \"\"\" print ( \"Creating audiogram with frequencies:\" , freqs ) print ( \"Left ear values:\" , left_values ) print ( \"Right ear values:\" , right_values ) fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . axhspan ( - 10 , 20 , facecolor = 'lightgreen' , alpha = 0.2 ) ax . axhspan ( 20 , 40 , facecolor = 'lightskyblue' , alpha = 0.2 ) ax . axhspan ( 40 , 70 , facecolor = 'yellow' , alpha = 0.2 ) ax . axhspan ( 70 , 90 , facecolor = 'orange' , alpha = 0.2 ) ax . axhspan ( 90 , 120 , facecolor = 'red' , alpha = 0.2 ) t1 = ax . text ( 6.4 , 5 , 'Normalh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t2 = ax . text ( 6.4 , 30 , 'Leichte \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t3 = ax . text ( 6.4 , 55 , 'Mittlere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t4 = ax . text ( 6.4 , 80 , 'Schwere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t5 = ax . text ( 6.4 , 105 , 'Hochgradige \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) x_vals = range ( len ( freqs )) target_values = np . array ( list ( freq_levels . values ())) nan_freqs_left = [ freq for i , freq in zip ( left_values , freqs ) if i == 'NaN' ] nan_freqs_right = [ freq for i , freq in zip ( right_values , freqs ) if i == 'NaN' ] nan_text = \"\" nan_t = False if 'NH' in left_values or 'NH' in right_values : heard_i_left , heard_level_left , not_heard_i_left , not_heard_level_left = split_values ( x_vals , left_values , target_values ) heard_i_right , heard_level_right , not_heard_i_right , not_heard_level_right = split_values ( x_vals , right_values , target_values ) if binaural : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_BINAURAL ) ax . plot ( heard_i_left , heard_level_left , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left , marker = NOT_HEARD_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'nicht geh\u00f6rt' ) else : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_RIGHT ) ax . plot ( heard_i_right , heard_level_right , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markerfacecolor = 'none' , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts geh\u00f6rt' ) ax . plot ( not_heard_i_right , not_heard_level_right , marker = NOT_HEARD_RIGHT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts nicht geh\u00f6rt' ) ax . plot ( x_vals , target_values + SHIFT , linestyle = '-' , color = COLOR_LEFT ) ax . plot ( heard_i_left , heard_level_left + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left + SHIFT , marker = NOT_HEARD_LEFT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links nicht geh\u00f6rt' ) else : x_vals_left , left_values = filter_none ( x_vals , left_values ) x_vals_right , right_values = filter_none ( x_vals , right_values ) if binaural : ax . plot ( x_vals_left , left_values , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = '-' , color = COLOR_BINAURAL , label = 'binaural' ) else : ax . plot ( x_vals_right , right_values , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , markerfacecolor = 'none' , label = 'rechtes Ohr' ) ax . plot ( x_vals_left , left_values + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'linkes Ohr' ) if nan_freqs_left or nan_freqs_right : and_str = \"\" nan_text = \"Bei folgenden Frequenzen konnte kein Wert ermittelt werden: \\n \" print ( nan_freqs_left , nan_freqs_right ) if nan_freqs_left : nan_text += f \"links: { ', ' . join ( map ( str , nan_freqs_left )) } \" and_str = \"und \" if nan_freqs_right : nan_text += f \" { and_str } rechts: { ', ' . join ( map ( str , nan_freqs_right )) } \" nan_t = ax . text ( 0.05 , - 0.2 , nan_text , transform = ax . transAxes , fontsize = TEXT_FONT_SIZE , ha = 'left' , va = 'top' , bbox = dict ( facecolor = 'None' , edgecolor = 'None' )) ax . invert_yaxis () if subtitle : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE , y = 1.02 ) ax . set_title ( subtitle , fontsize = LABEL_FONT_SIZE , pad = 20 ) else : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE ) ax . set_xlabel ( 'Frequenzen (Hz)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylabel ( 'H\u00f6rschwelle (dB HL)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylim ( 120 , - 10 ) ax . set_xticks ( range ( len ( freqs ))) ax . set_xticklabels ([ f \" { int ( freq ) } \" for freq in freqs ], fontsize = TICK_FONT_SIZE ) ax . set_yticks ( np . arange ( 0 , 121 , 10 )) ax . set_yticklabels ( np . arange ( 0 , 121 , 10 ), fontsize = TICK_FONT_SIZE ) ax . grid ( True , which = 'both' , linestyle = '--' , linewidth = 0.5 ) lgd = ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1.15 , 0.205 ), fontsize = LEGEND_FONT_SIZE , frameon = False , labelspacing = 1 ) if nan_t : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 , nan_t ), bbox_inches = 'tight' ) else : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 ), bbox_inches = 'tight' ) plt . close ( fig ) filter_none \u00b6 filter_none ( x_vals , values ) Helper function. Removes None or NaN values from list. Parameters: x_vals ( list of int ) \u2013 indices of values values ( list of float ) \u2013 list of hearing levels Returns: tuple \u2013 np.array: indices of values tuple \u2013 np.array: array of hearing levels Source code in app\\audiogram.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def filter_none ( x_vals : list , values : list ) -> tuple : \"\"\"Helper function. Removes None or NaN values from list. Args: x_vals (list of int): indices of values values (list of float): list of hearing levels Returns: np.array: indices of values np.array: array of hearing levels \"\"\" filtered = np . array ([[ i , v ] for i , v in zip ( x_vals , values ) if v not in ( None , \"NaN\" )]) . T if len ( filtered ) == 0 : return np . array ([], dtype = int ), np . array ([], dtype = int ) i_vals , v_vals = filtered return np . array ( i_vals , dtype = int ), np . array ( v_vals , dtype = int ) split_values \u00b6 split_values ( x_vals , values , target_values ) Helper function. Splits values into \"heard\" and \"not heard\" arrays. Parameters: x_vals ( list of int ) \u2013 indices of values values ( list of float and str ) \u2013 list of hearing levels and 'NH' if a sound was not heard target_values ( array ) \u2013 target value for \"not heard\" array Returns: tuple \u2013 np.array: indices of heard array tuple \u2013 np.array: values of heard array tuple \u2013 np.array: indices of \"not heard\" array tuple \u2013 np.array: values of \"not heard\" array Source code in app\\audiogram.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def split_values ( x_vals : list , values : list , target_values : np . array ) -> tuple : \"\"\"Helper function. Splits values into \"heard\" and \"not heard\" arrays. Args: x_vals (list of int): indices of values values (list of float and str): list of hearing levels and 'NH' if a sound was not heard target_values (np.array): target value for \"not heard\" array Returns: np.array: indices of heard array np.array: values of heard array np.array: indices of \"not heard\" array np.array: values of \"not heard\" array \"\"\" heard = np . array ([[ i , int ( v )] for i , v in zip ( x_vals , values ) if v != 'NH' and v != None ]) . T if len ( heard ) == 0 : heard_i , heard_level = [], [] else : heard_i , heard_level = heard not_heard = np . array ([[ i , t ] for i , v , t in zip ( x_vals , values , target_values ) if v == 'NH' and v != None ]) . T if len ( not_heard ) == 0 : not_heard_i , not_heard_level = [], [] else : not_heard_i , not_heard_level = not_heard return np . array ( heard_i , dtype = int ), np . array ( heard_level , dtype = int ), np . array ( not_heard_i , dtype = int ), np . array ( not_heard_level , dtype = int )","title":"audiogram"},{"location":"api/audiogram/#audiogram-module","text":"This module contains the function create_audiogram, which creates an audiogram based on the given frequencies and hearing threshold values with custom x-axis labels.","title":"audiogram Module"},{"location":"api/audiogram/#app.audiogram.create_audiogram","text":"create_audiogram ( freqs , left_values = None , right_values = None , binaural = False , name = 'audiogram.png' , freq_levels = freq_levels , subtitle = None ) Creates an audiogram based on the given frequencies and hearing threshold values with custom x-axis labels. Parameters: freqs ( list of int ) \u2013 A list of frequencies in Hz. left_values ( list of int , default: None ) \u2013 A list of hearing thresholds in dB HL for the left ear. Defaults to None. right_values ( list of int , default: None ) \u2013 A list of hearing thresholds in dB HL for the right ear. Defaults to None. binaural ( bool , default: False ) \u2013 Whether the audiogram is made from binaural test values. Defaults to False. name ( str , default: 'audiogram.png' ) \u2013 The name of the saved audiogram file. Defaults to \"audiogram.png\". freq_levels ( dict , default: freq_levels ) \u2013 A dictionary mapping frequencies to their target values. Defaults to freq_levels. subtitle ( str , default: None ) \u2013 A subtitle for the audiogram. Defaults to None. Source code in app\\audiogram.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def create_audiogram ( freqs : list , left_values : list = None , right_values : list = None , binaural : bool = False , name : str = \"audiogram.png\" , freq_levels : dict = freq_levels , subtitle : str = None ): \"\"\" Creates an audiogram based on the given frequencies and hearing threshold values with custom x-axis labels. Args: freqs (list of int): A list of frequencies in Hz. left_values (list of int, optional): A list of hearing thresholds in dB HL for the left ear. Defaults to None. right_values (list of int, optional): A list of hearing thresholds in dB HL for the right ear. Defaults to None. binaural (bool, optional): Whether the audiogram is made from binaural test values. Defaults to False. name (str, optional): The name of the saved audiogram file. Defaults to \"audiogram.png\". freq_levels (dict, optional): A dictionary mapping frequencies to their target values. Defaults to freq_levels. subtitle (str, optional): A subtitle for the audiogram. Defaults to None. \"\"\" print ( \"Creating audiogram with frequencies:\" , freqs ) print ( \"Left ear values:\" , left_values ) print ( \"Right ear values:\" , right_values ) fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . axhspan ( - 10 , 20 , facecolor = 'lightgreen' , alpha = 0.2 ) ax . axhspan ( 20 , 40 , facecolor = 'lightskyblue' , alpha = 0.2 ) ax . axhspan ( 40 , 70 , facecolor = 'yellow' , alpha = 0.2 ) ax . axhspan ( 70 , 90 , facecolor = 'orange' , alpha = 0.2 ) ax . axhspan ( 90 , 120 , facecolor = 'red' , alpha = 0.2 ) t1 = ax . text ( 6.4 , 5 , 'Normalh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t2 = ax . text ( 6.4 , 30 , 'Leichte \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t3 = ax . text ( 6.4 , 55 , 'Mittlere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t4 = ax . text ( 6.4 , 80 , 'Schwere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t5 = ax . text ( 6.4 , 105 , 'Hochgradige \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) x_vals = range ( len ( freqs )) target_values = np . array ( list ( freq_levels . values ())) nan_freqs_left = [ freq for i , freq in zip ( left_values , freqs ) if i == 'NaN' ] nan_freqs_right = [ freq for i , freq in zip ( right_values , freqs ) if i == 'NaN' ] nan_text = \"\" nan_t = False if 'NH' in left_values or 'NH' in right_values : heard_i_left , heard_level_left , not_heard_i_left , not_heard_level_left = split_values ( x_vals , left_values , target_values ) heard_i_right , heard_level_right , not_heard_i_right , not_heard_level_right = split_values ( x_vals , right_values , target_values ) if binaural : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_BINAURAL ) ax . plot ( heard_i_left , heard_level_left , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left , marker = NOT_HEARD_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'nicht geh\u00f6rt' ) else : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_RIGHT ) ax . plot ( heard_i_right , heard_level_right , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markerfacecolor = 'none' , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts geh\u00f6rt' ) ax . plot ( not_heard_i_right , not_heard_level_right , marker = NOT_HEARD_RIGHT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts nicht geh\u00f6rt' ) ax . plot ( x_vals , target_values + SHIFT , linestyle = '-' , color = COLOR_LEFT ) ax . plot ( heard_i_left , heard_level_left + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left + SHIFT , marker = NOT_HEARD_LEFT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links nicht geh\u00f6rt' ) else : x_vals_left , left_values = filter_none ( x_vals , left_values ) x_vals_right , right_values = filter_none ( x_vals , right_values ) if binaural : ax . plot ( x_vals_left , left_values , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = '-' , color = COLOR_BINAURAL , label = 'binaural' ) else : ax . plot ( x_vals_right , right_values , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , markerfacecolor = 'none' , label = 'rechtes Ohr' ) ax . plot ( x_vals_left , left_values + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'linkes Ohr' ) if nan_freqs_left or nan_freqs_right : and_str = \"\" nan_text = \"Bei folgenden Frequenzen konnte kein Wert ermittelt werden: \\n \" print ( nan_freqs_left , nan_freqs_right ) if nan_freqs_left : nan_text += f \"links: { ', ' . join ( map ( str , nan_freqs_left )) } \" and_str = \"und \" if nan_freqs_right : nan_text += f \" { and_str } rechts: { ', ' . join ( map ( str , nan_freqs_right )) } \" nan_t = ax . text ( 0.05 , - 0.2 , nan_text , transform = ax . transAxes , fontsize = TEXT_FONT_SIZE , ha = 'left' , va = 'top' , bbox = dict ( facecolor = 'None' , edgecolor = 'None' )) ax . invert_yaxis () if subtitle : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE , y = 1.02 ) ax . set_title ( subtitle , fontsize = LABEL_FONT_SIZE , pad = 20 ) else : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE ) ax . set_xlabel ( 'Frequenzen (Hz)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylabel ( 'H\u00f6rschwelle (dB HL)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylim ( 120 , - 10 ) ax . set_xticks ( range ( len ( freqs ))) ax . set_xticklabels ([ f \" { int ( freq ) } \" for freq in freqs ], fontsize = TICK_FONT_SIZE ) ax . set_yticks ( np . arange ( 0 , 121 , 10 )) ax . set_yticklabels ( np . arange ( 0 , 121 , 10 ), fontsize = TICK_FONT_SIZE ) ax . grid ( True , which = 'both' , linestyle = '--' , linewidth = 0.5 ) lgd = ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1.15 , 0.205 ), fontsize = LEGEND_FONT_SIZE , frameon = False , labelspacing = 1 ) if nan_t : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 , nan_t ), bbox_inches = 'tight' ) else : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 ), bbox_inches = 'tight' ) plt . close ( fig )","title":"create_audiogram"},{"location":"api/audiogram/#app.audiogram.filter_none","text":"filter_none ( x_vals , values ) Helper function. Removes None or NaN values from list. Parameters: x_vals ( list of int ) \u2013 indices of values values ( list of float ) \u2013 list of hearing levels Returns: tuple \u2013 np.array: indices of values tuple \u2013 np.array: array of hearing levels Source code in app\\audiogram.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def filter_none ( x_vals : list , values : list ) -> tuple : \"\"\"Helper function. Removes None or NaN values from list. Args: x_vals (list of int): indices of values values (list of float): list of hearing levels Returns: np.array: indices of values np.array: array of hearing levels \"\"\" filtered = np . array ([[ i , v ] for i , v in zip ( x_vals , values ) if v not in ( None , \"NaN\" )]) . T if len ( filtered ) == 0 : return np . array ([], dtype = int ), np . array ([], dtype = int ) i_vals , v_vals = filtered return np . array ( i_vals , dtype = int ), np . array ( v_vals , dtype = int )","title":"filter_none"},{"location":"api/audiogram/#app.audiogram.split_values","text":"split_values ( x_vals , values , target_values ) Helper function. Splits values into \"heard\" and \"not heard\" arrays. Parameters: x_vals ( list of int ) \u2013 indices of values values ( list of float and str ) \u2013 list of hearing levels and 'NH' if a sound was not heard target_values ( array ) \u2013 target value for \"not heard\" array Returns: tuple \u2013 np.array: indices of heard array tuple \u2013 np.array: values of heard array tuple \u2013 np.array: indices of \"not heard\" array tuple \u2013 np.array: values of \"not heard\" array Source code in app\\audiogram.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def split_values ( x_vals : list , values : list , target_values : np . array ) -> tuple : \"\"\"Helper function. Splits values into \"heard\" and \"not heard\" arrays. Args: x_vals (list of int): indices of values values (list of float and str): list of hearing levels and 'NH' if a sound was not heard target_values (np.array): target value for \"not heard\" array Returns: np.array: indices of heard array np.array: values of heard array np.array: indices of \"not heard\" array np.array: values of \"not heard\" array \"\"\" heard = np . array ([[ i , int ( v )] for i , v in zip ( x_vals , values ) if v != 'NH' and v != None ]) . T if len ( heard ) == 0 : heard_i , heard_level = [], [] else : heard_i , heard_level = heard not_heard = np . array ([[ i , t ] for i , v , t in zip ( x_vals , values , target_values ) if v == 'NH' and v != None ]) . T if len ( not_heard ) == 0 : not_heard_i , not_heard_level = [], [] else : not_heard_i , not_heard_level = not_heard return np . array ( heard_i , dtype = int ), np . array ( heard_level , dtype = int ), np . array ( not_heard_i , dtype = int ), np . array ( not_heard_level , dtype = int )","title":"split_values"},{"location":"api/main/","text":"main Module \u00b6 Main module of the Audiometer application that combines the model and view of the application. AudioPlayer \u00b6 Source code in app\\audio_player.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class AudioPlayer : def __init__ ( self ): \"\"\"Creates an audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False def generate_tone ( self ) -> np . array : \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone def play_beep ( self , frequency : int , volume : float , duration : int , channel : str = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs ) def stop ( self ): \"\"\"Stops the current playback. \"\"\" sd . stop () def int_or_str ( self , text : str ) -> int : \"\"\"Helper function for argument parsing. \"\"\" try : return int ( text ) except ValueError : return text def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ] __init__ \u00b6 __init__ () Creates an audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. Source code in app\\audio_player.py 8 9 10 11 12 13 14 15 16 17 def __init__ ( self ): \"\"\"Creates an audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False generate_tone \u00b6 generate_tone () Generates a sine tone with current audio player settings. Returns: array ( array ) \u2013 sine wave as numpy array Source code in app\\audio_player.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def generate_tone ( self ) -> np . array : \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone get_device_samplerate \u00b6 get_device_samplerate () Gets current samplerate from the selected audio output device. Returns: float \u2013 samplerate of current sound device Source code in app\\audio_player.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ] int_or_str \u00b6 int_or_str ( text ) Helper function for argument parsing. Source code in app\\audio_player.py 68 69 70 71 72 73 74 def int_or_str ( self , text : str ) -> int : \"\"\"Helper function for argument parsing. \"\"\" try : return int ( text ) except ValueError : return text play_beep \u00b6 play_beep ( frequency , volume , duration , channel = 'lr' ) Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Parameters: frequency ( int ) \u2013 frequency in Hz volume ( float ) \u2013 volume multiplier (between 0 and 1) duration ( int ) \u2013 duration of the beep in seconds channel ( string , default: 'lr' ) \u2013 'l', 'r' or 'lr' for only left, only right or both channels respectively Source code in app\\audio_player.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def play_beep ( self , frequency : int , volume : float , duration : int , channel : str = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs ) stop \u00b6 stop () Stops the current playback. Source code in app\\audio_player.py 63 64 65 66 def stop ( self ): \"\"\"Stops the current playback. \"\"\" sd . stop () Calibration \u00b6 Bases: Procedure Source code in app\\model.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 class Calibration ( Procedure ): def __init__ ( self , startlevel : int = 60 , signal_length : int = 10 , headphone_name : str = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ] def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2 def play_one_freq ( self ) -> tuple : \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) def set_calibration_value ( self , measured_value : float ): \"\"\"Rights the given calibration value into temporary CSV file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile ) def finish_calibration ( self ): \"\"\"Makes a permanent CSV file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary CSV file \"\"\" self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename ) def stop_playing ( self ): \"\"\"Stops the audio player. \"\"\" self . ap . stop () __init__ \u00b6 __init__ ( startlevel = 60 , signal_length = 10 , headphone_name = 'Sennheiser_HDA200' , ** additional_data ) Process for calibrating system. Parameters: startlevel ( int , default: 60 ) \u2013 starting level of procedure in dB HL. Defaults to 60. signal_length ( int , default: 10 ) \u2013 length of played signals in seconds. Defaults to 10. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Source code in app\\model.py 695 696 697 698 699 700 701 702 703 704 705 706 707 def __init__ ( self , startlevel : int = 60 , signal_length : int = 10 , headphone_name : str = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ] finish_calibration \u00b6 finish_calibration () Makes a permanent CSV file from the temporary file that overwrites calibration.csv. Parameters: temp_filename ( str ) \u2013 name of temporary CSV file Source code in app\\model.py 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 def finish_calibration ( self ): \"\"\"Makes a permanent CSV file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary CSV file \"\"\" self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename ) get_next_freq \u00b6 get_next_freq () Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int \u2013 frequency Source code in app\\model.py 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2 play_one_freq \u00b6 play_one_freq () Get the next frequency and play it. Returns: bool ( tuple ) \u2013 False if no more frequencies left int ( tuple ) \u2013 current frequency float ( tuple ) \u2013 expected SPL value in dB Source code in app\\model.py 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 def play_one_freq ( self ) -> tuple : \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl repeat_freq \u00b6 repeat_freq () Repeats the last played frequency. Source code in app\\model.py 751 752 753 754 755 756 def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) set_calibration_value \u00b6 set_calibration_value ( measured_value ) Rights the given calibration value into temporary CSV file Parameters: measured_value ( float ) \u2013 measured SPL value in dB Source code in app\\model.py 758 759 760 761 762 763 764 765 def set_calibration_value ( self , measured_value : float ): \"\"\"Rights the given calibration value into temporary CSV file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile ) stop_playing \u00b6 stop_playing () Stops the audio player. Source code in app\\model.py 788 789 790 791 def stop_playing ( self ): \"\"\"Stops the audio player. \"\"\" self . ap . stop () Controller \u00b6 Source code in app\\main.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 class Controller (): def __init__ ( self ): \"\"\"Controller class (MVC architecture) that combines model and view of the Audiometer. \"\"\" self . selected_program = \"\" program_functions = { \"Klassisches Audiogramm\" : self . start_standard_procedure , \"Kurzes Screening\" : self . start_screen_procedure , \"Kalibrierung\" : self . start_calibration } self . calibration_funcs = [ self . start_calibration , self . calibration_next_freq , self . calibration_repeat_freq , self . stop_sound , self . calibration_set_level ] self . view = setup_ui ( self . start_familiarization , program_functions , self . calibration_funcs , self . get_progress ) # helper variable for calibration self . button_changed = False def run_app ( self ): \"\"\"Starts the app by running the tkinter mainloop of the view. \"\"\" self . view . mainloop () def start_familiarization ( self , id : str = \"\" , headphone : str = \"Sennheiser_HDA200\" , calibrate : bool = True , ** additional_data ) -> bool : \"\"\"Creates a Familiarization object and uses it to start the familiarization process. Args: id (str, optional): ID of test subject. Defaults to \"\". headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate (bool, optional): Whether to use calibration file. Defaults to True. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done Returns: bool: Whether familiarization was successful \"\"\" self . selected_program = \"familiarization\" self . familiarization = Familiarization ( id = id , headphone_name = headphone , calibrate = calibrate , ** additional_data ) return self . familiarization . familiarize () def start_standard_procedure ( self , binaural : bool = False , headphone : str = \"Sennheiser_HDA200\" , calibrate : bool = True , ** additional_data ): \"\"\"Creates a StandardProcedure object and uses it to start the standard procedure. Args: binaural (bool, optional): Whether to test both ears at the same time. Defaults to False. headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate (bool, optional): Whether to use calibration file. Defaults to True. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" self . selected_program = \"standard\" self . standard_procedure = StandardProcedure ( self . familiarization . get_temp_csv_filename (), headphone_name = headphone , calibrate = calibrate , ** additional_data ) self . standard_procedure . standard_test ( binaural ) def start_screen_procedure ( self , binaural : bool = False , headphone : str = \"Sennheiser_HDA200\" , calibrate : bool = True , ** additional_data ): \"\"\"Creates a ScreeningProcedure object and uses it to start the screening procedure. Args: binaural (bool, optional): Whether to test both ears at the same time. Defaults to False. headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate (bool, optional): Whether to use calibration file. Defaults to True. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" self . selected_program = \"screening\" self . screen_procedure = ScreeningProcedure ( self . familiarization . get_temp_csv_filename (), headphone_name = headphone , calibrate = calibrate , ** additional_data ) self . screen_procedure . screen_test ( binaural ) def start_calibration ( self , level : int , headphone : str = \"Sennheiser_HDA200\" ) -> tuple : \"\"\"Creates a Calibration object and uses it to start calibration. Args: level (int): Level of calibration in dB HL. headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". \"\"\" self . selected_program = \"calibration\" self . calibration = Calibration ( startlevel = level , headphone_name = headphone ) _ , current_freq , current_spl = self . calibration_next_freq () return current_freq , current_spl def calibration_next_freq ( self ) -> tuple : \"\"\"Goes to next frequency in calibration process and play it. Returns: bool: Whether there are more frequencies left after this one. int: current frequency float: expected SPL value in dB \"\"\" more_freqs , current_freq , current_spl = self . calibration . play_one_freq () if more_freqs : return True , current_freq , current_spl elif self . button_changed == False : self . button_changed = True return False , current_freq , current_spl else : self . calibration . finish_calibration () return False , current_freq , current_spl def calibration_repeat_freq ( self ): \"\"\"Repeats the current frequency during calibration process. \"\"\" self . calibration . repeat_freq () def calibration_set_level ( self , spl : float ): \"\"\"Sets the measured level in dB during calbration process. Args: spl (float): Sound pressure level that was measured in dB \"\"\" self . calibration . set_calibration_value ( spl ) def stop_sound ( self ): \"\"\"Stops the sound during calibration process. \"\"\" self . calibration . stop_playing () def get_progress ( self ) -> float : \"\"\"Gets current progress in curent procedure for progress bar. Returns: float: progress value between 0.0 and 1.0 \"\"\" if self . selected_program == \"familiarization\" : return self . familiarization . get_progress () elif self . selected_program == \"standard\" : return self . standard_procedure . get_progress () elif self . selected_program == \"screening\" : return self . screen_procedure . get_progress () elif self . selected_program == \"calibration\" : return 0.0 else : return 0.0 __init__ \u00b6 __init__ () Controller class (MVC architecture) that combines model and view of the Audiometer. Source code in app\\main.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def __init__ ( self ): \"\"\"Controller class (MVC architecture) that combines model and view of the Audiometer. \"\"\" self . selected_program = \"\" program_functions = { \"Klassisches Audiogramm\" : self . start_standard_procedure , \"Kurzes Screening\" : self . start_screen_procedure , \"Kalibrierung\" : self . start_calibration } self . calibration_funcs = [ self . start_calibration , self . calibration_next_freq , self . calibration_repeat_freq , self . stop_sound , self . calibration_set_level ] self . view = setup_ui ( self . start_familiarization , program_functions , self . calibration_funcs , self . get_progress ) # helper variable for calibration self . button_changed = False calibration_next_freq \u00b6 calibration_next_freq () Goes to next frequency in calibration process and play it. Returns: bool ( tuple ) \u2013 Whether there are more frequencies left after this one. int ( tuple ) \u2013 current frequency float ( tuple ) \u2013 expected SPL value in dB Source code in app\\main.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def calibration_next_freq ( self ) -> tuple : \"\"\"Goes to next frequency in calibration process and play it. Returns: bool: Whether there are more frequencies left after this one. int: current frequency float: expected SPL value in dB \"\"\" more_freqs , current_freq , current_spl = self . calibration . play_one_freq () if more_freqs : return True , current_freq , current_spl elif self . button_changed == False : self . button_changed = True return False , current_freq , current_spl else : self . calibration . finish_calibration () return False , current_freq , current_spl calibration_repeat_freq \u00b6 calibration_repeat_freq () Repeats the current frequency during calibration process. Source code in app\\main.py 99 100 101 102 def calibration_repeat_freq ( self ): \"\"\"Repeats the current frequency during calibration process. \"\"\" self . calibration . repeat_freq () calibration_set_level \u00b6 calibration_set_level ( spl ) Sets the measured level in dB during calbration process. Parameters: spl ( float ) \u2013 Sound pressure level that was measured in dB Source code in app\\main.py 104 105 106 107 108 109 110 def calibration_set_level ( self , spl : float ): \"\"\"Sets the measured level in dB during calbration process. Args: spl (float): Sound pressure level that was measured in dB \"\"\" self . calibration . set_calibration_value ( spl ) get_progress \u00b6 get_progress () Gets current progress in curent procedure for progress bar. Returns: float ( float ) \u2013 progress value between 0.0 and 1.0 Source code in app\\main.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def get_progress ( self ) -> float : \"\"\"Gets current progress in curent procedure for progress bar. Returns: float: progress value between 0.0 and 1.0 \"\"\" if self . selected_program == \"familiarization\" : return self . familiarization . get_progress () elif self . selected_program == \"standard\" : return self . standard_procedure . get_progress () elif self . selected_program == \"screening\" : return self . screen_procedure . get_progress () elif self . selected_program == \"calibration\" : return 0.0 else : return 0.0 run_app \u00b6 run_app () Starts the app by running the tkinter mainloop of the view. Source code in app\\main.py 22 23 24 25 def run_app ( self ): \"\"\"Starts the app by running the tkinter mainloop of the view. \"\"\" self . view . mainloop () start_calibration \u00b6 start_calibration ( level , headphone = 'Sennheiser_HDA200' ) Creates a Calibration object and uses it to start calibration. Parameters: level ( int ) \u2013 Level of calibration in dB HL. headphone ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". Source code in app\\main.py 69 70 71 72 73 74 75 76 77 78 79 def start_calibration ( self , level : int , headphone : str = \"Sennheiser_HDA200\" ) -> tuple : \"\"\"Creates a Calibration object and uses it to start calibration. Args: level (int): Level of calibration in dB HL. headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". \"\"\" self . selected_program = \"calibration\" self . calibration = Calibration ( startlevel = level , headphone_name = headphone ) _ , current_freq , current_spl = self . calibration_next_freq () return current_freq , current_spl start_familiarization \u00b6 start_familiarization ( id = '' , headphone = 'Sennheiser_HDA200' , calibrate = True , ** additional_data ) Creates a Familiarization object and uses it to start the familiarization process. Parameters: id ( str , default: '' ) \u2013 ID of test subject. Defaults to \"\". headphone ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate ( bool , default: True ) \u2013 Whether to use calibration file. Defaults to True. **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Returns: bool ( bool ) \u2013 Whether familiarization was successful Source code in app\\main.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def start_familiarization ( self , id : str = \"\" , headphone : str = \"Sennheiser_HDA200\" , calibrate : bool = True , ** additional_data ) -> bool : \"\"\"Creates a Familiarization object and uses it to start the familiarization process. Args: id (str, optional): ID of test subject. Defaults to \"\". headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate (bool, optional): Whether to use calibration file. Defaults to True. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done Returns: bool: Whether familiarization was successful \"\"\" self . selected_program = \"familiarization\" self . familiarization = Familiarization ( id = id , headphone_name = headphone , calibrate = calibrate , ** additional_data ) return self . familiarization . familiarize () start_screen_procedure \u00b6 start_screen_procedure ( binaural = False , headphone = 'Sennheiser_HDA200' , calibrate = True , ** additional_data ) Creates a ScreeningProcedure object and uses it to start the screening procedure. Parameters: binaural ( bool , default: False ) \u2013 Whether to test both ears at the same time. Defaults to False. headphone ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate ( bool , default: True ) \u2013 Whether to use calibration file. Defaults to True. **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Source code in app\\main.py 56 57 58 59 60 61 62 63 64 65 66 67 def start_screen_procedure ( self , binaural : bool = False , headphone : str = \"Sennheiser_HDA200\" , calibrate : bool = True , ** additional_data ): \"\"\"Creates a ScreeningProcedure object and uses it to start the screening procedure. Args: binaural (bool, optional): Whether to test both ears at the same time. Defaults to False. headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate (bool, optional): Whether to use calibration file. Defaults to True. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" self . selected_program = \"screening\" self . screen_procedure = ScreeningProcedure ( self . familiarization . get_temp_csv_filename (), headphone_name = headphone , calibrate = calibrate , ** additional_data ) self . screen_procedure . screen_test ( binaural ) start_standard_procedure \u00b6 start_standard_procedure ( binaural = False , headphone = 'Sennheiser_HDA200' , calibrate = True , ** additional_data ) Creates a StandardProcedure object and uses it to start the standard procedure. Parameters: binaural ( bool , default: False ) \u2013 Whether to test both ears at the same time. Defaults to False. headphone ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate ( bool , default: True ) \u2013 Whether to use calibration file. Defaults to True. **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Source code in app\\main.py 43 44 45 46 47 48 49 50 51 52 53 54 def start_standard_procedure ( self , binaural : bool = False , headphone : str = \"Sennheiser_HDA200\" , calibrate : bool = True , ** additional_data ): \"\"\"Creates a StandardProcedure object and uses it to start the standard procedure. Args: binaural (bool, optional): Whether to test both ears at the same time. Defaults to False. headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate (bool, optional): Whether to use calibration file. Defaults to True. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" self . selected_program = \"standard\" self . standard_procedure = StandardProcedure ( self . familiarization . get_temp_csv_filename (), headphone_name = headphone , calibrate = calibrate , ** additional_data ) self . standard_procedure . standard_test ( binaural ) stop_sound \u00b6 stop_sound () Stops the sound during calibration process. Source code in app\\main.py 112 113 114 115 def stop_sound ( self ): \"\"\"Stops the sound during calibration process. \"\"\" self . calibration . stop_playing () Familiarization \u00b6 Bases: Procedure Source code in app\\model.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 class Familiarization ( Procedure ): def __init__ ( self , startlevel : int = 40 , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True , id : str = \"\" , ** additional_data ): \"\"\"Creates the Familiarization process. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. id (str, optional): id to be stored, that will later be used for naming exported CSV file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies def get_temp_csv_filename ( self ) -> str : \"\"\"Gets name of temp CSV file. Returns: str: name of CSV file \"\"\" return self . tempfile def familiarize ( self ) -> bool : \"\"\"Main function. Returns: bool: familiarization successful \"\"\" self . progress = 0.01 while True : self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 if self . progress < 1 / 5 : self . progress = 1 / 5 else : self . level += 10 if self . progress < 1 / 3 : self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True __init__ \u00b6 __init__ ( startlevel = 40 , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True , id = '' , ** additional_data ) Creates the Familiarization process. Parameters: startlevel ( int , default: 40 ) \u2013 starting level of procedure in dB HL. Defaults to 40. signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. id ( str , default: '' ) \u2013 id to be stored, that will later be used for naming exported CSV file **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Source code in app\\model.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 def __init__ ( self , startlevel : int = 40 , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True , id : str = \"\" , ** additional_data ): \"\"\"Creates the Familiarization process. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. id (str, optional): id to be stored, that will later be used for naming exported CSV file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies familiarize \u00b6 familiarize () Main function. Returns: bool ( bool ) \u2013 familiarization successful Source code in app\\model.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 def familiarize ( self ) -> bool : \"\"\"Main function. Returns: bool: familiarization successful \"\"\" self . progress = 0.01 while True : self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 if self . progress < 1 / 5 : self . progress = 1 / 5 else : self . level += 10 if self . progress < 1 / 3 : self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True get_temp_csv_filename \u00b6 get_temp_csv_filename () Gets name of temp CSV file. Returns: str ( str ) \u2013 name of CSV file Source code in app\\model.py 370 371 372 373 374 375 376 def get_temp_csv_filename ( self ) -> str : \"\"\"Gets name of temp CSV file. Returns: str: name of CSV file \"\"\" return self . tempfile Procedure \u00b6 Source code in app\\model.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 class Procedure : def __init__ ( self , startlevel : float , signal_length : float , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Creates the parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. This is a rough guess for uncalibrated systems and will be adjusted through the calibration file self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = False # set True to be able to skip procedures with right arrow key self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = self . get_save_path () # Initialize save_path def get_retspl_values ( self , headphone_name : str ): \"\"\"Reads the correct RETSPL values from the retspl.csv file. Args: headphone_name (str): exact name of headphone as it appears in CSV file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values def get_calibration_values ( self ) -> dict : \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values def dbhl_to_volume ( self , dbhl : float ) -> float : \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl def key_press ( self , key : keyboard . Key ): \"\"\"Function for pynputto be called on key press Args: key (keyboard.Key): key that was pressed \"\"\" if key == keyboard . Key . space : self . tone_heard = True print ( \"Tone heard!\" ) elif self . test_mode and key == keyboard . Key . right : self . jump_to_end = True def play_tone ( self ): \"\"\"Sets tone_heard to False, play beep, then waits 4 s (max) for keypress. Sets tone_heard to True if key is pressed. Then waits for around 1 s to 2.5 s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times def create_temp_csv ( self , id : str = \"\" , ** additional_data ) -> str : \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (str, optional): id to be stored, that will later be used for naming exported csv file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name def add_to_temp_csv ( self , value : str , frequency : str , side : str , temp_filename : str ): \"\"\"Add a value in for a specific frequency to the temporary CSV file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary CSV file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ]) def get_value_from_csv ( self , frequency : str , temp_filename : str , side : str = 'l' ) -> str : \"\"\"Get the value at a specific frequency from the temporary CSV file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary CSV file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ] def create_final_csv_and_audiogram ( self , temp_filename : str , binaural : bool = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels ) def parse_dbhl_value ( self , value : str ) -> int : \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None def get_progress ( self ) -> float : \"\"\"Gets the current progress. Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress def get_save_path ( self ) -> str : \"\"\"Gets selected path from settings.csv file for saving files. Returns: str: save path \"\"\" file_name = 'settings.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return save_path = \"\" try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) settings = next ( reader ) if settings [ 'file path' ]: save_path = settings [ 'file path' ] else : save_path = os . getcwd () except Exception as e : print ( f \"Error reading the file: { e } \" ) return return save_path __init__ \u00b6 __init__ ( startlevel , signal_length , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Creates the parent class for the familiarization, the main procedure, and the screening. Parameters: startlevel ( float ) \u2013 starting level of procedure in dB HL signal_length ( float ) \u2013 length of played signals in seconds headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. Source code in app\\model.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , startlevel : float , signal_length : float , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Creates the parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. This is a rough guess for uncalibrated systems and will be adjusted through the calibration file self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = False # set True to be able to skip procedures with right arrow key self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = self . get_save_path () # Initialize save_path add_to_temp_csv \u00b6 add_to_temp_csv ( value , frequency , side , temp_filename ) Add a value in for a specific frequency to the temporary CSV file Parameters: value ( str ) \u2013 level in dB HL at specific frequency frequency ( str ) \u2013 frequency where value should be added side ( str ) \u2013 specify which ear ('l' or 'r') temp_filename ( str ) \u2013 name of temporary CSV file Source code in app\\model.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def add_to_temp_csv ( self , value : str , frequency : str , side : str , temp_filename : str ): \"\"\"Add a value in for a specific frequency to the temporary CSV file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary CSV file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ]) create_final_csv_and_audiogram \u00b6 create_final_csv_and_audiogram ( temp_filename , binaural = False ) Creates a permanent CSV file and audiogram from the temporary file. Parameters: temp_filename ( str ) \u2013 Name of the temporary CSV file. binaural ( bool , default: False ) \u2013 If the test is binaural. Source code in app\\model.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def create_final_csv_and_audiogram ( self , temp_filename : str , binaural : bool = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels ) create_temp_csv \u00b6 create_temp_csv ( id = '' , ** additional_data ) Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Parameters: id ( str , default: '' ) \u2013 id to be stored, that will later be used for naming exported csv file **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Returns: str ( str ) \u2013 name of temporary file Source code in app\\model.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def create_temp_csv ( self , id : str = \"\" , ** additional_data ) -> str : \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (str, optional): id to be stored, that will later be used for naming exported csv file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name dbhl_to_volume \u00b6 dbhl_to_volume ( dbhl ) Calculate dB HL into absolute numbers. Parameters: dbhl ( float ) \u2013 value in dB HL Returns: float ( float ) \u2013 value in absolute numbers Source code in app\\model.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def dbhl_to_volume ( self , dbhl : float ) -> float : \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl get_calibration_values \u00b6 get_calibration_values () Read the correct calibration values from the calibration.csv file. Returns: dict \u2013 dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def get_calibration_values ( self ) -> dict : \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values get_progress \u00b6 get_progress () Gets the current progress. Returns: float ( float ) \u2013 progress value between 0.0 and 1.0 Source code in app\\model.py 314 315 316 317 318 319 320 def get_progress ( self ) -> float : \"\"\"Gets the current progress. Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress get_retspl_values \u00b6 get_retspl_values ( headphone_name ) Reads the correct RETSPL values from the retspl.csv file. Parameters: headphone_name ( str ) \u2013 exact name of headphone as it appears in CSV file Returns: \u2013 dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def get_retspl_values ( self , headphone_name : str ): \"\"\"Reads the correct RETSPL values from the retspl.csv file. Args: headphone_name (str): exact name of headphone as it appears in CSV file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values get_save_path \u00b6 get_save_path () Gets selected path from settings.csv file for saving files. Returns: str ( str ) \u2013 save path Source code in app\\model.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def get_save_path ( self ) -> str : \"\"\"Gets selected path from settings.csv file for saving files. Returns: str: save path \"\"\" file_name = 'settings.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return save_path = \"\" try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) settings = next ( reader ) if settings [ 'file path' ]: save_path = settings [ 'file path' ] else : save_path = os . getcwd () except Exception as e : print ( f \"Error reading the file: { e } \" ) return return save_path get_value_from_csv \u00b6 get_value_from_csv ( frequency , temp_filename , side = 'l' ) Get the value at a specific frequency from the temporary CSV file. Parameters: frequency ( str ) \u2013 frequency where value is stored temp_filename ( str ) \u2013 name of temporary CSV file side ( str , default: 'l' ) \u2013 specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str ( str ) \u2013 dB HL value at specified frequency Source code in app\\model.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def get_value_from_csv ( self , frequency : str , temp_filename : str , side : str = 'l' ) -> str : \"\"\"Get the value at a specific frequency from the temporary CSV file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary CSV file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ] key_press \u00b6 key_press ( key ) Function for pynputto be called on key press Parameters: key ( Key ) \u2013 key that was pressed Source code in app\\model.py 132 133 134 135 136 137 138 139 140 141 142 def key_press ( self , key : keyboard . Key ): \"\"\"Function for pynputto be called on key press Args: key (keyboard.Key): key that was pressed \"\"\" if key == keyboard . Key . space : self . tone_heard = True print ( \"Tone heard!\" ) elif self . test_mode and key == keyboard . Key . right : self . jump_to_end = True parse_dbhl_value \u00b6 parse_dbhl_value ( value ) Parses the dBHL value from the CSV file. Parameters: value ( str ) \u2013 the value from the CSV file Returns: int \u2013 int or None: the parsed value or None if 'NH' Source code in app\\model.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def parse_dbhl_value ( self , value : str ) -> int : \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None play_tone \u00b6 play_tone () Sets tone_heard to False, play beep, then waits 4 s (max) for keypress. Sets tone_heard to True if key is pressed. Then waits for around 1 s to 2.5 s (randomized). Source code in app\\model.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def play_tone ( self ): \"\"\"Sets tone_heard to False, play beep, then waits 4 s (max) for keypress. Sets tone_heard to True if key is pressed. Then waits for around 1 s to 2.5 s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times ScreeningProcedure \u00b6 Bases: Procedure Source code in app\\model.py 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 class ScreeningProcedure ( Procedure ): def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14 def screen_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function. Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) def screen_one_ear ( self ): \"\"\"Screening for one ear. \"\"\" success = [] for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . screen_one_freq ( f ) success . append ( s ) def screen_one_freq ( self , freq : int ) -> bool : \"\"\"Screening for one frequency. Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step __init__ \u00b6 __init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Short screening process to check if subject can hear specific frequencies at certain levels. Parameters: temp_filename ( str ) \u2013 name of temporary CSV file where starting level is stored and future values will be stored. signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. Source code in app\\model.py 605 606 607 608 609 610 611 612 613 614 615 616 617 618 def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14 screen_one_ear \u00b6 screen_one_ear () Screening for one ear. Source code in app\\model.py 648 649 650 651 652 653 654 655 656 def screen_one_ear ( self ): \"\"\"Screening for one ear. \"\"\" success = [] for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . screen_one_freq ( f ) success . append ( s ) screen_one_freq \u00b6 screen_one_freq ( freq ) Screening for one frequency. Parameters: freq ( int ) \u2013 frequency to be tested Returns: bool ( bool ) \u2013 tone heard Source code in app\\model.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 def screen_one_freq ( self , freq : int ) -> bool : \"\"\"Screening for one frequency. Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step screen_test \u00b6 screen_test ( binaural = False ) Main function. Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 def screen_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function. Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) StandardProcedure \u00b6 Bases: Procedure Source code in app\\model.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 class StandardProcedure ( Procedure ): def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : float = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14 def standard_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False def standard_test_one_ear ( self ) -> bool : \"\"\"Audiometer for one ear. Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False def standard_test_one_freq ( self , freq : int , retest : bool = False ) -> bool : \"\"\"Test for one frequency. Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False __init__ \u00b6 __init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Standard audiometer process (rising level). Parameters: temp_filename ( str ) \u2013 name of temporary CSV file where starting level is stored and future values will be stored signal_length ( int , default: 1 ) \u2013 length of played signal in seconds. Defaults to 1. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. Source code in app\\model.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : float = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14 standard_test \u00b6 standard_test ( binaural = False ) Main function Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 def standard_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False standard_test_one_ear \u00b6 standard_test_one_ear () Audiometer for one ear. Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 def standard_test_one_ear ( self ) -> bool : \"\"\"Audiometer for one ear. Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False standard_test_one_freq \u00b6 standard_test_one_freq ( freq , retest = False ) Test for one frequency. Parameters: freq ( int ) \u2013 frequency at which hearing is tested retest ( bool , default: False ) \u2013 this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 def standard_test_one_freq ( self , freq : int , retest : bool = False ) -> bool : \"\"\"Test for one frequency. Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False create_audiogram \u00b6 create_audiogram ( freqs , left_values = None , right_values = None , binaural = False , name = 'audiogram.png' , freq_levels = freq_levels , subtitle = None ) Creates an audiogram based on the given frequencies and hearing threshold values with custom x-axis labels. Parameters: freqs ( list of int ) \u2013 A list of frequencies in Hz. left_values ( list of int , default: None ) \u2013 A list of hearing thresholds in dB HL for the left ear. Defaults to None. right_values ( list of int , default: None ) \u2013 A list of hearing thresholds in dB HL for the right ear. Defaults to None. binaural ( bool , default: False ) \u2013 Whether the audiogram is made from binaural test values. Defaults to False. name ( str , default: 'audiogram.png' ) \u2013 The name of the saved audiogram file. Defaults to \"audiogram.png\". freq_levels ( dict , default: freq_levels ) \u2013 A dictionary mapping frequencies to their target values. Defaults to freq_levels. subtitle ( str , default: None ) \u2013 A subtitle for the audiogram. Defaults to None. Source code in app\\audiogram.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def create_audiogram ( freqs : list , left_values : list = None , right_values : list = None , binaural : bool = False , name : str = \"audiogram.png\" , freq_levels : dict = freq_levels , subtitle : str = None ): \"\"\" Creates an audiogram based on the given frequencies and hearing threshold values with custom x-axis labels. Args: freqs (list of int): A list of frequencies in Hz. left_values (list of int, optional): A list of hearing thresholds in dB HL for the left ear. Defaults to None. right_values (list of int, optional): A list of hearing thresholds in dB HL for the right ear. Defaults to None. binaural (bool, optional): Whether the audiogram is made from binaural test values. Defaults to False. name (str, optional): The name of the saved audiogram file. Defaults to \"audiogram.png\". freq_levels (dict, optional): A dictionary mapping frequencies to their target values. Defaults to freq_levels. subtitle (str, optional): A subtitle for the audiogram. Defaults to None. \"\"\" print ( \"Creating audiogram with frequencies:\" , freqs ) print ( \"Left ear values:\" , left_values ) print ( \"Right ear values:\" , right_values ) fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . axhspan ( - 10 , 20 , facecolor = 'lightgreen' , alpha = 0.2 ) ax . axhspan ( 20 , 40 , facecolor = 'lightskyblue' , alpha = 0.2 ) ax . axhspan ( 40 , 70 , facecolor = 'yellow' , alpha = 0.2 ) ax . axhspan ( 70 , 90 , facecolor = 'orange' , alpha = 0.2 ) ax . axhspan ( 90 , 120 , facecolor = 'red' , alpha = 0.2 ) t1 = ax . text ( 6.4 , 5 , 'Normalh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t2 = ax . text ( 6.4 , 30 , 'Leichte \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t3 = ax . text ( 6.4 , 55 , 'Mittlere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t4 = ax . text ( 6.4 , 80 , 'Schwere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t5 = ax . text ( 6.4 , 105 , 'Hochgradige \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) x_vals = range ( len ( freqs )) target_values = np . array ( list ( freq_levels . values ())) nan_freqs_left = [ freq for i , freq in zip ( left_values , freqs ) if i == 'NaN' ] nan_freqs_right = [ freq for i , freq in zip ( right_values , freqs ) if i == 'NaN' ] nan_text = \"\" nan_t = False if 'NH' in left_values or 'NH' in right_values : heard_i_left , heard_level_left , not_heard_i_left , not_heard_level_left = split_values ( x_vals , left_values , target_values ) heard_i_right , heard_level_right , not_heard_i_right , not_heard_level_right = split_values ( x_vals , right_values , target_values ) if binaural : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_BINAURAL ) ax . plot ( heard_i_left , heard_level_left , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left , marker = NOT_HEARD_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'nicht geh\u00f6rt' ) else : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_RIGHT ) ax . plot ( heard_i_right , heard_level_right , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markerfacecolor = 'none' , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts geh\u00f6rt' ) ax . plot ( not_heard_i_right , not_heard_level_right , marker = NOT_HEARD_RIGHT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts nicht geh\u00f6rt' ) ax . plot ( x_vals , target_values + SHIFT , linestyle = '-' , color = COLOR_LEFT ) ax . plot ( heard_i_left , heard_level_left + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left + SHIFT , marker = NOT_HEARD_LEFT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links nicht geh\u00f6rt' ) else : x_vals_left , left_values = filter_none ( x_vals , left_values ) x_vals_right , right_values = filter_none ( x_vals , right_values ) if binaural : ax . plot ( x_vals_left , left_values , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = '-' , color = COLOR_BINAURAL , label = 'binaural' ) else : ax . plot ( x_vals_right , right_values , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , markerfacecolor = 'none' , label = 'rechtes Ohr' ) ax . plot ( x_vals_left , left_values + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'linkes Ohr' ) if nan_freqs_left or nan_freqs_right : and_str = \"\" nan_text = \"Bei folgenden Frequenzen konnte kein Wert ermittelt werden: \\n \" print ( nan_freqs_left , nan_freqs_right ) if nan_freqs_left : nan_text += f \"links: { ', ' . join ( map ( str , nan_freqs_left )) } \" and_str = \"und \" if nan_freqs_right : nan_text += f \" { and_str } rechts: { ', ' . join ( map ( str , nan_freqs_right )) } \" nan_t = ax . text ( 0.05 , - 0.2 , nan_text , transform = ax . transAxes , fontsize = TEXT_FONT_SIZE , ha = 'left' , va = 'top' , bbox = dict ( facecolor = 'None' , edgecolor = 'None' )) ax . invert_yaxis () if subtitle : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE , y = 1.02 ) ax . set_title ( subtitle , fontsize = LABEL_FONT_SIZE , pad = 20 ) else : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE ) ax . set_xlabel ( 'Frequenzen (Hz)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylabel ( 'H\u00f6rschwelle (dB HL)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylim ( 120 , - 10 ) ax . set_xticks ( range ( len ( freqs ))) ax . set_xticklabels ([ f \" { int ( freq ) } \" for freq in freqs ], fontsize = TICK_FONT_SIZE ) ax . set_yticks ( np . arange ( 0 , 121 , 10 )) ax . set_yticklabels ( np . arange ( 0 , 121 , 10 ), fontsize = TICK_FONT_SIZE ) ax . grid ( True , which = 'both' , linestyle = '--' , linewidth = 0.5 ) lgd = ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1.15 , 0.205 ), fontsize = LEGEND_FONT_SIZE , frameon = False , labelspacing = 1 ) if nan_t : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 , nan_t ), bbox_inches = 'tight' ) else : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 ), bbox_inches = 'tight' ) plt . close ( fig )","title":"main"},{"location":"api/main/#main-module","text":"Main module of the Audiometer application that combines the model and view of the application.","title":"main Module"},{"location":"api/main/#app.main.AudioPlayer","text":"Source code in app\\audio_player.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class AudioPlayer : def __init__ ( self ): \"\"\"Creates an audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False def generate_tone ( self ) -> np . array : \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone def play_beep ( self , frequency : int , volume : float , duration : int , channel : str = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs ) def stop ( self ): \"\"\"Stops the current playback. \"\"\" sd . stop () def int_or_str ( self , text : str ) -> int : \"\"\"Helper function for argument parsing. \"\"\" try : return int ( text ) except ValueError : return text def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ]","title":"AudioPlayer"},{"location":"api/main/#app.main.AudioPlayer.__init__","text":"__init__ () Creates an audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. Source code in app\\audio_player.py 8 9 10 11 12 13 14 15 16 17 def __init__ ( self ): \"\"\"Creates an audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False","title":"__init__"},{"location":"api/main/#app.main.AudioPlayer.generate_tone","text":"generate_tone () Generates a sine tone with current audio player settings. Returns: array ( array ) \u2013 sine wave as numpy array Source code in app\\audio_player.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def generate_tone ( self ) -> np . array : \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone","title":"generate_tone"},{"location":"api/main/#app.main.AudioPlayer.get_device_samplerate","text":"get_device_samplerate () Gets current samplerate from the selected audio output device. Returns: float \u2013 samplerate of current sound device Source code in app\\audio_player.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ]","title":"get_device_samplerate"},{"location":"api/main/#app.main.AudioPlayer.int_or_str","text":"int_or_str ( text ) Helper function for argument parsing. Source code in app\\audio_player.py 68 69 70 71 72 73 74 def int_or_str ( self , text : str ) -> int : \"\"\"Helper function for argument parsing. \"\"\" try : return int ( text ) except ValueError : return text","title":"int_or_str"},{"location":"api/main/#app.main.AudioPlayer.play_beep","text":"play_beep ( frequency , volume , duration , channel = 'lr' ) Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Parameters: frequency ( int ) \u2013 frequency in Hz volume ( float ) \u2013 volume multiplier (between 0 and 1) duration ( int ) \u2013 duration of the beep in seconds channel ( string , default: 'lr' ) \u2013 'l', 'r' or 'lr' for only left, only right or both channels respectively Source code in app\\audio_player.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def play_beep ( self , frequency : int , volume : float , duration : int , channel : str = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs )","title":"play_beep"},{"location":"api/main/#app.main.AudioPlayer.stop","text":"stop () Stops the current playback. Source code in app\\audio_player.py 63 64 65 66 def stop ( self ): \"\"\"Stops the current playback. \"\"\" sd . stop ()","title":"stop"},{"location":"api/main/#app.main.Calibration","text":"Bases: Procedure Source code in app\\model.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 class Calibration ( Procedure ): def __init__ ( self , startlevel : int = 60 , signal_length : int = 10 , headphone_name : str = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ] def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2 def play_one_freq ( self ) -> tuple : \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) def set_calibration_value ( self , measured_value : float ): \"\"\"Rights the given calibration value into temporary CSV file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile ) def finish_calibration ( self ): \"\"\"Makes a permanent CSV file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary CSV file \"\"\" self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename ) def stop_playing ( self ): \"\"\"Stops the audio player. \"\"\" self . ap . stop ()","title":"Calibration"},{"location":"api/main/#app.main.Calibration.__init__","text":"__init__ ( startlevel = 60 , signal_length = 10 , headphone_name = 'Sennheiser_HDA200' , ** additional_data ) Process for calibrating system. Parameters: startlevel ( int , default: 60 ) \u2013 starting level of procedure in dB HL. Defaults to 60. signal_length ( int , default: 10 ) \u2013 length of played signals in seconds. Defaults to 10. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Source code in app\\model.py 695 696 697 698 699 700 701 702 703 704 705 706 707 def __init__ ( self , startlevel : int = 60 , signal_length : int = 10 , headphone_name : str = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ]","title":"__init__"},{"location":"api/main/#app.main.Calibration.finish_calibration","text":"finish_calibration () Makes a permanent CSV file from the temporary file that overwrites calibration.csv. Parameters: temp_filename ( str ) \u2013 name of temporary CSV file Source code in app\\model.py 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 def finish_calibration ( self ): \"\"\"Makes a permanent CSV file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary CSV file \"\"\" self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename )","title":"finish_calibration"},{"location":"api/main/#app.main.Calibration.get_next_freq","text":"get_next_freq () Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int \u2013 frequency Source code in app\\model.py 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2","title":"get_next_freq"},{"location":"api/main/#app.main.Calibration.play_one_freq","text":"play_one_freq () Get the next frequency and play it. Returns: bool ( tuple ) \u2013 False if no more frequencies left int ( tuple ) \u2013 current frequency float ( tuple ) \u2013 expected SPL value in dB Source code in app\\model.py 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 def play_one_freq ( self ) -> tuple : \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl","title":"play_one_freq"},{"location":"api/main/#app.main.Calibration.repeat_freq","text":"repeat_freq () Repeats the last played frequency. Source code in app\\model.py 751 752 753 754 755 756 def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side )","title":"repeat_freq"},{"location":"api/main/#app.main.Calibration.set_calibration_value","text":"set_calibration_value ( measured_value ) Rights the given calibration value into temporary CSV file Parameters: measured_value ( float ) \u2013 measured SPL value in dB Source code in app\\model.py 758 759 760 761 762 763 764 765 def set_calibration_value ( self , measured_value : float ): \"\"\"Rights the given calibration value into temporary CSV file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile )","title":"set_calibration_value"},{"location":"api/main/#app.main.Calibration.stop_playing","text":"stop_playing () Stops the audio player. Source code in app\\model.py 788 789 790 791 def stop_playing ( self ): \"\"\"Stops the audio player. \"\"\" self . ap . stop ()","title":"stop_playing"},{"location":"api/main/#app.main.Controller","text":"Source code in app\\main.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 class Controller (): def __init__ ( self ): \"\"\"Controller class (MVC architecture) that combines model and view of the Audiometer. \"\"\" self . selected_program = \"\" program_functions = { \"Klassisches Audiogramm\" : self . start_standard_procedure , \"Kurzes Screening\" : self . start_screen_procedure , \"Kalibrierung\" : self . start_calibration } self . calibration_funcs = [ self . start_calibration , self . calibration_next_freq , self . calibration_repeat_freq , self . stop_sound , self . calibration_set_level ] self . view = setup_ui ( self . start_familiarization , program_functions , self . calibration_funcs , self . get_progress ) # helper variable for calibration self . button_changed = False def run_app ( self ): \"\"\"Starts the app by running the tkinter mainloop of the view. \"\"\" self . view . mainloop () def start_familiarization ( self , id : str = \"\" , headphone : str = \"Sennheiser_HDA200\" , calibrate : bool = True , ** additional_data ) -> bool : \"\"\"Creates a Familiarization object and uses it to start the familiarization process. Args: id (str, optional): ID of test subject. Defaults to \"\". headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate (bool, optional): Whether to use calibration file. Defaults to True. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done Returns: bool: Whether familiarization was successful \"\"\" self . selected_program = \"familiarization\" self . familiarization = Familiarization ( id = id , headphone_name = headphone , calibrate = calibrate , ** additional_data ) return self . familiarization . familiarize () def start_standard_procedure ( self , binaural : bool = False , headphone : str = \"Sennheiser_HDA200\" , calibrate : bool = True , ** additional_data ): \"\"\"Creates a StandardProcedure object and uses it to start the standard procedure. Args: binaural (bool, optional): Whether to test both ears at the same time. Defaults to False. headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate (bool, optional): Whether to use calibration file. Defaults to True. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" self . selected_program = \"standard\" self . standard_procedure = StandardProcedure ( self . familiarization . get_temp_csv_filename (), headphone_name = headphone , calibrate = calibrate , ** additional_data ) self . standard_procedure . standard_test ( binaural ) def start_screen_procedure ( self , binaural : bool = False , headphone : str = \"Sennheiser_HDA200\" , calibrate : bool = True , ** additional_data ): \"\"\"Creates a ScreeningProcedure object and uses it to start the screening procedure. Args: binaural (bool, optional): Whether to test both ears at the same time. Defaults to False. headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate (bool, optional): Whether to use calibration file. Defaults to True. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" self . selected_program = \"screening\" self . screen_procedure = ScreeningProcedure ( self . familiarization . get_temp_csv_filename (), headphone_name = headphone , calibrate = calibrate , ** additional_data ) self . screen_procedure . screen_test ( binaural ) def start_calibration ( self , level : int , headphone : str = \"Sennheiser_HDA200\" ) -> tuple : \"\"\"Creates a Calibration object and uses it to start calibration. Args: level (int): Level of calibration in dB HL. headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". \"\"\" self . selected_program = \"calibration\" self . calibration = Calibration ( startlevel = level , headphone_name = headphone ) _ , current_freq , current_spl = self . calibration_next_freq () return current_freq , current_spl def calibration_next_freq ( self ) -> tuple : \"\"\"Goes to next frequency in calibration process and play it. Returns: bool: Whether there are more frequencies left after this one. int: current frequency float: expected SPL value in dB \"\"\" more_freqs , current_freq , current_spl = self . calibration . play_one_freq () if more_freqs : return True , current_freq , current_spl elif self . button_changed == False : self . button_changed = True return False , current_freq , current_spl else : self . calibration . finish_calibration () return False , current_freq , current_spl def calibration_repeat_freq ( self ): \"\"\"Repeats the current frequency during calibration process. \"\"\" self . calibration . repeat_freq () def calibration_set_level ( self , spl : float ): \"\"\"Sets the measured level in dB during calbration process. Args: spl (float): Sound pressure level that was measured in dB \"\"\" self . calibration . set_calibration_value ( spl ) def stop_sound ( self ): \"\"\"Stops the sound during calibration process. \"\"\" self . calibration . stop_playing () def get_progress ( self ) -> float : \"\"\"Gets current progress in curent procedure for progress bar. Returns: float: progress value between 0.0 and 1.0 \"\"\" if self . selected_program == \"familiarization\" : return self . familiarization . get_progress () elif self . selected_program == \"standard\" : return self . standard_procedure . get_progress () elif self . selected_program == \"screening\" : return self . screen_procedure . get_progress () elif self . selected_program == \"calibration\" : return 0.0 else : return 0.0","title":"Controller"},{"location":"api/main/#app.main.Controller.__init__","text":"__init__ () Controller class (MVC architecture) that combines model and view of the Audiometer. Source code in app\\main.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def __init__ ( self ): \"\"\"Controller class (MVC architecture) that combines model and view of the Audiometer. \"\"\" self . selected_program = \"\" program_functions = { \"Klassisches Audiogramm\" : self . start_standard_procedure , \"Kurzes Screening\" : self . start_screen_procedure , \"Kalibrierung\" : self . start_calibration } self . calibration_funcs = [ self . start_calibration , self . calibration_next_freq , self . calibration_repeat_freq , self . stop_sound , self . calibration_set_level ] self . view = setup_ui ( self . start_familiarization , program_functions , self . calibration_funcs , self . get_progress ) # helper variable for calibration self . button_changed = False","title":"__init__"},{"location":"api/main/#app.main.Controller.calibration_next_freq","text":"calibration_next_freq () Goes to next frequency in calibration process and play it. Returns: bool ( tuple ) \u2013 Whether there are more frequencies left after this one. int ( tuple ) \u2013 current frequency float ( tuple ) \u2013 expected SPL value in dB Source code in app\\main.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def calibration_next_freq ( self ) -> tuple : \"\"\"Goes to next frequency in calibration process and play it. Returns: bool: Whether there are more frequencies left after this one. int: current frequency float: expected SPL value in dB \"\"\" more_freqs , current_freq , current_spl = self . calibration . play_one_freq () if more_freqs : return True , current_freq , current_spl elif self . button_changed == False : self . button_changed = True return False , current_freq , current_spl else : self . calibration . finish_calibration () return False , current_freq , current_spl","title":"calibration_next_freq"},{"location":"api/main/#app.main.Controller.calibration_repeat_freq","text":"calibration_repeat_freq () Repeats the current frequency during calibration process. Source code in app\\main.py 99 100 101 102 def calibration_repeat_freq ( self ): \"\"\"Repeats the current frequency during calibration process. \"\"\" self . calibration . repeat_freq ()","title":"calibration_repeat_freq"},{"location":"api/main/#app.main.Controller.calibration_set_level","text":"calibration_set_level ( spl ) Sets the measured level in dB during calbration process. Parameters: spl ( float ) \u2013 Sound pressure level that was measured in dB Source code in app\\main.py 104 105 106 107 108 109 110 def calibration_set_level ( self , spl : float ): \"\"\"Sets the measured level in dB during calbration process. Args: spl (float): Sound pressure level that was measured in dB \"\"\" self . calibration . set_calibration_value ( spl )","title":"calibration_set_level"},{"location":"api/main/#app.main.Controller.get_progress","text":"get_progress () Gets current progress in curent procedure for progress bar. Returns: float ( float ) \u2013 progress value between 0.0 and 1.0 Source code in app\\main.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def get_progress ( self ) -> float : \"\"\"Gets current progress in curent procedure for progress bar. Returns: float: progress value between 0.0 and 1.0 \"\"\" if self . selected_program == \"familiarization\" : return self . familiarization . get_progress () elif self . selected_program == \"standard\" : return self . standard_procedure . get_progress () elif self . selected_program == \"screening\" : return self . screen_procedure . get_progress () elif self . selected_program == \"calibration\" : return 0.0 else : return 0.0","title":"get_progress"},{"location":"api/main/#app.main.Controller.run_app","text":"run_app () Starts the app by running the tkinter mainloop of the view. Source code in app\\main.py 22 23 24 25 def run_app ( self ): \"\"\"Starts the app by running the tkinter mainloop of the view. \"\"\" self . view . mainloop ()","title":"run_app"},{"location":"api/main/#app.main.Controller.start_calibration","text":"start_calibration ( level , headphone = 'Sennheiser_HDA200' ) Creates a Calibration object and uses it to start calibration. Parameters: level ( int ) \u2013 Level of calibration in dB HL. headphone ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". Source code in app\\main.py 69 70 71 72 73 74 75 76 77 78 79 def start_calibration ( self , level : int , headphone : str = \"Sennheiser_HDA200\" ) -> tuple : \"\"\"Creates a Calibration object and uses it to start calibration. Args: level (int): Level of calibration in dB HL. headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". \"\"\" self . selected_program = \"calibration\" self . calibration = Calibration ( startlevel = level , headphone_name = headphone ) _ , current_freq , current_spl = self . calibration_next_freq () return current_freq , current_spl","title":"start_calibration"},{"location":"api/main/#app.main.Controller.start_familiarization","text":"start_familiarization ( id = '' , headphone = 'Sennheiser_HDA200' , calibrate = True , ** additional_data ) Creates a Familiarization object and uses it to start the familiarization process. Parameters: id ( str , default: '' ) \u2013 ID of test subject. Defaults to \"\". headphone ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate ( bool , default: True ) \u2013 Whether to use calibration file. Defaults to True. **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Returns: bool ( bool ) \u2013 Whether familiarization was successful Source code in app\\main.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def start_familiarization ( self , id : str = \"\" , headphone : str = \"Sennheiser_HDA200\" , calibrate : bool = True , ** additional_data ) -> bool : \"\"\"Creates a Familiarization object and uses it to start the familiarization process. Args: id (str, optional): ID of test subject. Defaults to \"\". headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate (bool, optional): Whether to use calibration file. Defaults to True. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done Returns: bool: Whether familiarization was successful \"\"\" self . selected_program = \"familiarization\" self . familiarization = Familiarization ( id = id , headphone_name = headphone , calibrate = calibrate , ** additional_data ) return self . familiarization . familiarize ()","title":"start_familiarization"},{"location":"api/main/#app.main.Controller.start_screen_procedure","text":"start_screen_procedure ( binaural = False , headphone = 'Sennheiser_HDA200' , calibrate = True , ** additional_data ) Creates a ScreeningProcedure object and uses it to start the screening procedure. Parameters: binaural ( bool , default: False ) \u2013 Whether to test both ears at the same time. Defaults to False. headphone ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate ( bool , default: True ) \u2013 Whether to use calibration file. Defaults to True. **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Source code in app\\main.py 56 57 58 59 60 61 62 63 64 65 66 67 def start_screen_procedure ( self , binaural : bool = False , headphone : str = \"Sennheiser_HDA200\" , calibrate : bool = True , ** additional_data ): \"\"\"Creates a ScreeningProcedure object and uses it to start the screening procedure. Args: binaural (bool, optional): Whether to test both ears at the same time. Defaults to False. headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate (bool, optional): Whether to use calibration file. Defaults to True. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" self . selected_program = \"screening\" self . screen_procedure = ScreeningProcedure ( self . familiarization . get_temp_csv_filename (), headphone_name = headphone , calibrate = calibrate , ** additional_data ) self . screen_procedure . screen_test ( binaural )","title":"start_screen_procedure"},{"location":"api/main/#app.main.Controller.start_standard_procedure","text":"start_standard_procedure ( binaural = False , headphone = 'Sennheiser_HDA200' , calibrate = True , ** additional_data ) Creates a StandardProcedure object and uses it to start the standard procedure. Parameters: binaural ( bool , default: False ) \u2013 Whether to test both ears at the same time. Defaults to False. headphone ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate ( bool , default: True ) \u2013 Whether to use calibration file. Defaults to True. **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Source code in app\\main.py 43 44 45 46 47 48 49 50 51 52 53 54 def start_standard_procedure ( self , binaural : bool = False , headphone : str = \"Sennheiser_HDA200\" , calibrate : bool = True , ** additional_data ): \"\"\"Creates a StandardProcedure object and uses it to start the standard procedure. Args: binaural (bool, optional): Whether to test both ears at the same time. Defaults to False. headphone (str, optional): Name of headphone model being used. Defaults to \"Sennheiser_HDA200\". calibrate (bool, optional): Whether to use calibration file. Defaults to True. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" self . selected_program = \"standard\" self . standard_procedure = StandardProcedure ( self . familiarization . get_temp_csv_filename (), headphone_name = headphone , calibrate = calibrate , ** additional_data ) self . standard_procedure . standard_test ( binaural )","title":"start_standard_procedure"},{"location":"api/main/#app.main.Controller.stop_sound","text":"stop_sound () Stops the sound during calibration process. Source code in app\\main.py 112 113 114 115 def stop_sound ( self ): \"\"\"Stops the sound during calibration process. \"\"\" self . calibration . stop_playing ()","title":"stop_sound"},{"location":"api/main/#app.main.Familiarization","text":"Bases: Procedure Source code in app\\model.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 class Familiarization ( Procedure ): def __init__ ( self , startlevel : int = 40 , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True , id : str = \"\" , ** additional_data ): \"\"\"Creates the Familiarization process. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. id (str, optional): id to be stored, that will later be used for naming exported CSV file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies def get_temp_csv_filename ( self ) -> str : \"\"\"Gets name of temp CSV file. Returns: str: name of CSV file \"\"\" return self . tempfile def familiarize ( self ) -> bool : \"\"\"Main function. Returns: bool: familiarization successful \"\"\" self . progress = 0.01 while True : self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 if self . progress < 1 / 5 : self . progress = 1 / 5 else : self . level += 10 if self . progress < 1 / 3 : self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True","title":"Familiarization"},{"location":"api/main/#app.main.Familiarization.__init__","text":"__init__ ( startlevel = 40 , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True , id = '' , ** additional_data ) Creates the Familiarization process. Parameters: startlevel ( int , default: 40 ) \u2013 starting level of procedure in dB HL. Defaults to 40. signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. id ( str , default: '' ) \u2013 id to be stored, that will later be used for naming exported CSV file **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Source code in app\\model.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 def __init__ ( self , startlevel : int = 40 , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True , id : str = \"\" , ** additional_data ): \"\"\"Creates the Familiarization process. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. id (str, optional): id to be stored, that will later be used for naming exported CSV file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies","title":"__init__"},{"location":"api/main/#app.main.Familiarization.familiarize","text":"familiarize () Main function. Returns: bool ( bool ) \u2013 familiarization successful Source code in app\\model.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 def familiarize ( self ) -> bool : \"\"\"Main function. Returns: bool: familiarization successful \"\"\" self . progress = 0.01 while True : self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 if self . progress < 1 / 5 : self . progress = 1 / 5 else : self . level += 10 if self . progress < 1 / 3 : self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True","title":"familiarize"},{"location":"api/main/#app.main.Familiarization.get_temp_csv_filename","text":"get_temp_csv_filename () Gets name of temp CSV file. Returns: str ( str ) \u2013 name of CSV file Source code in app\\model.py 370 371 372 373 374 375 376 def get_temp_csv_filename ( self ) -> str : \"\"\"Gets name of temp CSV file. Returns: str: name of CSV file \"\"\" return self . tempfile","title":"get_temp_csv_filename"},{"location":"api/main/#app.main.Procedure","text":"Source code in app\\model.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 class Procedure : def __init__ ( self , startlevel : float , signal_length : float , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Creates the parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. This is a rough guess for uncalibrated systems and will be adjusted through the calibration file self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = False # set True to be able to skip procedures with right arrow key self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = self . get_save_path () # Initialize save_path def get_retspl_values ( self , headphone_name : str ): \"\"\"Reads the correct RETSPL values from the retspl.csv file. Args: headphone_name (str): exact name of headphone as it appears in CSV file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values def get_calibration_values ( self ) -> dict : \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values def dbhl_to_volume ( self , dbhl : float ) -> float : \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl def key_press ( self , key : keyboard . Key ): \"\"\"Function for pynputto be called on key press Args: key (keyboard.Key): key that was pressed \"\"\" if key == keyboard . Key . space : self . tone_heard = True print ( \"Tone heard!\" ) elif self . test_mode and key == keyboard . Key . right : self . jump_to_end = True def play_tone ( self ): \"\"\"Sets tone_heard to False, play beep, then waits 4 s (max) for keypress. Sets tone_heard to True if key is pressed. Then waits for around 1 s to 2.5 s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times def create_temp_csv ( self , id : str = \"\" , ** additional_data ) -> str : \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (str, optional): id to be stored, that will later be used for naming exported csv file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name def add_to_temp_csv ( self , value : str , frequency : str , side : str , temp_filename : str ): \"\"\"Add a value in for a specific frequency to the temporary CSV file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary CSV file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ]) def get_value_from_csv ( self , frequency : str , temp_filename : str , side : str = 'l' ) -> str : \"\"\"Get the value at a specific frequency from the temporary CSV file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary CSV file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ] def create_final_csv_and_audiogram ( self , temp_filename : str , binaural : bool = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels ) def parse_dbhl_value ( self , value : str ) -> int : \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None def get_progress ( self ) -> float : \"\"\"Gets the current progress. Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress def get_save_path ( self ) -> str : \"\"\"Gets selected path from settings.csv file for saving files. Returns: str: save path \"\"\" file_name = 'settings.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return save_path = \"\" try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) settings = next ( reader ) if settings [ 'file path' ]: save_path = settings [ 'file path' ] else : save_path = os . getcwd () except Exception as e : print ( f \"Error reading the file: { e } \" ) return return save_path","title":"Procedure"},{"location":"api/main/#app.main.Procedure.__init__","text":"__init__ ( startlevel , signal_length , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Creates the parent class for the familiarization, the main procedure, and the screening. Parameters: startlevel ( float ) \u2013 starting level of procedure in dB HL signal_length ( float ) \u2013 length of played signals in seconds headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. Source code in app\\model.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , startlevel : float , signal_length : float , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Creates the parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. This is a rough guess for uncalibrated systems and will be adjusted through the calibration file self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = False # set True to be able to skip procedures with right arrow key self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = self . get_save_path () # Initialize save_path","title":"__init__"},{"location":"api/main/#app.main.Procedure.add_to_temp_csv","text":"add_to_temp_csv ( value , frequency , side , temp_filename ) Add a value in for a specific frequency to the temporary CSV file Parameters: value ( str ) \u2013 level in dB HL at specific frequency frequency ( str ) \u2013 frequency where value should be added side ( str ) \u2013 specify which ear ('l' or 'r') temp_filename ( str ) \u2013 name of temporary CSV file Source code in app\\model.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def add_to_temp_csv ( self , value : str , frequency : str , side : str , temp_filename : str ): \"\"\"Add a value in for a specific frequency to the temporary CSV file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary CSV file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ])","title":"add_to_temp_csv"},{"location":"api/main/#app.main.Procedure.create_final_csv_and_audiogram","text":"create_final_csv_and_audiogram ( temp_filename , binaural = False ) Creates a permanent CSV file and audiogram from the temporary file. Parameters: temp_filename ( str ) \u2013 Name of the temporary CSV file. binaural ( bool , default: False ) \u2013 If the test is binaural. Source code in app\\model.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def create_final_csv_and_audiogram ( self , temp_filename : str , binaural : bool = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels )","title":"create_final_csv_and_audiogram"},{"location":"api/main/#app.main.Procedure.create_temp_csv","text":"create_temp_csv ( id = '' , ** additional_data ) Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Parameters: id ( str , default: '' ) \u2013 id to be stored, that will later be used for naming exported csv file **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Returns: str ( str ) \u2013 name of temporary file Source code in app\\model.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def create_temp_csv ( self , id : str = \"\" , ** additional_data ) -> str : \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (str, optional): id to be stored, that will later be used for naming exported csv file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name","title":"create_temp_csv"},{"location":"api/main/#app.main.Procedure.dbhl_to_volume","text":"dbhl_to_volume ( dbhl ) Calculate dB HL into absolute numbers. Parameters: dbhl ( float ) \u2013 value in dB HL Returns: float ( float ) \u2013 value in absolute numbers Source code in app\\model.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def dbhl_to_volume ( self , dbhl : float ) -> float : \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl","title":"dbhl_to_volume"},{"location":"api/main/#app.main.Procedure.get_calibration_values","text":"get_calibration_values () Read the correct calibration values from the calibration.csv file. Returns: dict \u2013 dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def get_calibration_values ( self ) -> dict : \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values","title":"get_calibration_values"},{"location":"api/main/#app.main.Procedure.get_progress","text":"get_progress () Gets the current progress. Returns: float ( float ) \u2013 progress value between 0.0 and 1.0 Source code in app\\model.py 314 315 316 317 318 319 320 def get_progress ( self ) -> float : \"\"\"Gets the current progress. Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress","title":"get_progress"},{"location":"api/main/#app.main.Procedure.get_retspl_values","text":"get_retspl_values ( headphone_name ) Reads the correct RETSPL values from the retspl.csv file. Parameters: headphone_name ( str ) \u2013 exact name of headphone as it appears in CSV file Returns: \u2013 dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def get_retspl_values ( self , headphone_name : str ): \"\"\"Reads the correct RETSPL values from the retspl.csv file. Args: headphone_name (str): exact name of headphone as it appears in CSV file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values","title":"get_retspl_values"},{"location":"api/main/#app.main.Procedure.get_save_path","text":"get_save_path () Gets selected path from settings.csv file for saving files. Returns: str ( str ) \u2013 save path Source code in app\\model.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def get_save_path ( self ) -> str : \"\"\"Gets selected path from settings.csv file for saving files. Returns: str: save path \"\"\" file_name = 'settings.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return save_path = \"\" try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) settings = next ( reader ) if settings [ 'file path' ]: save_path = settings [ 'file path' ] else : save_path = os . getcwd () except Exception as e : print ( f \"Error reading the file: { e } \" ) return return save_path","title":"get_save_path"},{"location":"api/main/#app.main.Procedure.get_value_from_csv","text":"get_value_from_csv ( frequency , temp_filename , side = 'l' ) Get the value at a specific frequency from the temporary CSV file. Parameters: frequency ( str ) \u2013 frequency where value is stored temp_filename ( str ) \u2013 name of temporary CSV file side ( str , default: 'l' ) \u2013 specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str ( str ) \u2013 dB HL value at specified frequency Source code in app\\model.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def get_value_from_csv ( self , frequency : str , temp_filename : str , side : str = 'l' ) -> str : \"\"\"Get the value at a specific frequency from the temporary CSV file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary CSV file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ]","title":"get_value_from_csv"},{"location":"api/main/#app.main.Procedure.key_press","text":"key_press ( key ) Function for pynputto be called on key press Parameters: key ( Key ) \u2013 key that was pressed Source code in app\\model.py 132 133 134 135 136 137 138 139 140 141 142 def key_press ( self , key : keyboard . Key ): \"\"\"Function for pynputto be called on key press Args: key (keyboard.Key): key that was pressed \"\"\" if key == keyboard . Key . space : self . tone_heard = True print ( \"Tone heard!\" ) elif self . test_mode and key == keyboard . Key . right : self . jump_to_end = True","title":"key_press"},{"location":"api/main/#app.main.Procedure.parse_dbhl_value","text":"parse_dbhl_value ( value ) Parses the dBHL value from the CSV file. Parameters: value ( str ) \u2013 the value from the CSV file Returns: int \u2013 int or None: the parsed value or None if 'NH' Source code in app\\model.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def parse_dbhl_value ( self , value : str ) -> int : \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None","title":"parse_dbhl_value"},{"location":"api/main/#app.main.Procedure.play_tone","text":"play_tone () Sets tone_heard to False, play beep, then waits 4 s (max) for keypress. Sets tone_heard to True if key is pressed. Then waits for around 1 s to 2.5 s (randomized). Source code in app\\model.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def play_tone ( self ): \"\"\"Sets tone_heard to False, play beep, then waits 4 s (max) for keypress. Sets tone_heard to True if key is pressed. Then waits for around 1 s to 2.5 s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times","title":"play_tone"},{"location":"api/main/#app.main.ScreeningProcedure","text":"Bases: Procedure Source code in app\\model.py 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 class ScreeningProcedure ( Procedure ): def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14 def screen_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function. Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) def screen_one_ear ( self ): \"\"\"Screening for one ear. \"\"\" success = [] for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . screen_one_freq ( f ) success . append ( s ) def screen_one_freq ( self , freq : int ) -> bool : \"\"\"Screening for one frequency. Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step","title":"ScreeningProcedure"},{"location":"api/main/#app.main.ScreeningProcedure.__init__","text":"__init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Short screening process to check if subject can hear specific frequencies at certain levels. Parameters: temp_filename ( str ) \u2013 name of temporary CSV file where starting level is stored and future values will be stored. signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. Source code in app\\model.py 605 606 607 608 609 610 611 612 613 614 615 616 617 618 def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14","title":"__init__"},{"location":"api/main/#app.main.ScreeningProcedure.screen_one_ear","text":"screen_one_ear () Screening for one ear. Source code in app\\model.py 648 649 650 651 652 653 654 655 656 def screen_one_ear ( self ): \"\"\"Screening for one ear. \"\"\" success = [] for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . screen_one_freq ( f ) success . append ( s )","title":"screen_one_ear"},{"location":"api/main/#app.main.ScreeningProcedure.screen_one_freq","text":"screen_one_freq ( freq ) Screening for one frequency. Parameters: freq ( int ) \u2013 frequency to be tested Returns: bool ( bool ) \u2013 tone heard Source code in app\\model.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 def screen_one_freq ( self , freq : int ) -> bool : \"\"\"Screening for one frequency. Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step","title":"screen_one_freq"},{"location":"api/main/#app.main.ScreeningProcedure.screen_test","text":"screen_test ( binaural = False ) Main function. Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 def screen_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function. Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural )","title":"screen_test"},{"location":"api/main/#app.main.StandardProcedure","text":"Bases: Procedure Source code in app\\model.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 class StandardProcedure ( Procedure ): def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : float = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14 def standard_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False def standard_test_one_ear ( self ) -> bool : \"\"\"Audiometer for one ear. Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False def standard_test_one_freq ( self , freq : int , retest : bool = False ) -> bool : \"\"\"Test for one frequency. Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False","title":"StandardProcedure"},{"location":"api/main/#app.main.StandardProcedure.__init__","text":"__init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Standard audiometer process (rising level). Parameters: temp_filename ( str ) \u2013 name of temporary CSV file where starting level is stored and future values will be stored signal_length ( int , default: 1 ) \u2013 length of played signal in seconds. Defaults to 1. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. Source code in app\\model.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : float = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14","title":"__init__"},{"location":"api/main/#app.main.StandardProcedure.standard_test","text":"standard_test ( binaural = False ) Main function Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 def standard_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False","title":"standard_test"},{"location":"api/main/#app.main.StandardProcedure.standard_test_one_ear","text":"standard_test_one_ear () Audiometer for one ear. Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 def standard_test_one_ear ( self ) -> bool : \"\"\"Audiometer for one ear. Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False","title":"standard_test_one_ear"},{"location":"api/main/#app.main.StandardProcedure.standard_test_one_freq","text":"standard_test_one_freq ( freq , retest = False ) Test for one frequency. Parameters: freq ( int ) \u2013 frequency at which hearing is tested retest ( bool , default: False ) \u2013 this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 def standard_test_one_freq ( self , freq : int , retest : bool = False ) -> bool : \"\"\"Test for one frequency. Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False","title":"standard_test_one_freq"},{"location":"api/main/#app.main.create_audiogram","text":"create_audiogram ( freqs , left_values = None , right_values = None , binaural = False , name = 'audiogram.png' , freq_levels = freq_levels , subtitle = None ) Creates an audiogram based on the given frequencies and hearing threshold values with custom x-axis labels. Parameters: freqs ( list of int ) \u2013 A list of frequencies in Hz. left_values ( list of int , default: None ) \u2013 A list of hearing thresholds in dB HL for the left ear. Defaults to None. right_values ( list of int , default: None ) \u2013 A list of hearing thresholds in dB HL for the right ear. Defaults to None. binaural ( bool , default: False ) \u2013 Whether the audiogram is made from binaural test values. Defaults to False. name ( str , default: 'audiogram.png' ) \u2013 The name of the saved audiogram file. Defaults to \"audiogram.png\". freq_levels ( dict , default: freq_levels ) \u2013 A dictionary mapping frequencies to their target values. Defaults to freq_levels. subtitle ( str , default: None ) \u2013 A subtitle for the audiogram. Defaults to None. Source code in app\\audiogram.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def create_audiogram ( freqs : list , left_values : list = None , right_values : list = None , binaural : bool = False , name : str = \"audiogram.png\" , freq_levels : dict = freq_levels , subtitle : str = None ): \"\"\" Creates an audiogram based on the given frequencies and hearing threshold values with custom x-axis labels. Args: freqs (list of int): A list of frequencies in Hz. left_values (list of int, optional): A list of hearing thresholds in dB HL for the left ear. Defaults to None. right_values (list of int, optional): A list of hearing thresholds in dB HL for the right ear. Defaults to None. binaural (bool, optional): Whether the audiogram is made from binaural test values. Defaults to False. name (str, optional): The name of the saved audiogram file. Defaults to \"audiogram.png\". freq_levels (dict, optional): A dictionary mapping frequencies to their target values. Defaults to freq_levels. subtitle (str, optional): A subtitle for the audiogram. Defaults to None. \"\"\" print ( \"Creating audiogram with frequencies:\" , freqs ) print ( \"Left ear values:\" , left_values ) print ( \"Right ear values:\" , right_values ) fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . axhspan ( - 10 , 20 , facecolor = 'lightgreen' , alpha = 0.2 ) ax . axhspan ( 20 , 40 , facecolor = 'lightskyblue' , alpha = 0.2 ) ax . axhspan ( 40 , 70 , facecolor = 'yellow' , alpha = 0.2 ) ax . axhspan ( 70 , 90 , facecolor = 'orange' , alpha = 0.2 ) ax . axhspan ( 90 , 120 , facecolor = 'red' , alpha = 0.2 ) t1 = ax . text ( 6.4 , 5 , 'Normalh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t2 = ax . text ( 6.4 , 30 , 'Leichte \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t3 = ax . text ( 6.4 , 55 , 'Mittlere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t4 = ax . text ( 6.4 , 80 , 'Schwere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t5 = ax . text ( 6.4 , 105 , 'Hochgradige \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) x_vals = range ( len ( freqs )) target_values = np . array ( list ( freq_levels . values ())) nan_freqs_left = [ freq for i , freq in zip ( left_values , freqs ) if i == 'NaN' ] nan_freqs_right = [ freq for i , freq in zip ( right_values , freqs ) if i == 'NaN' ] nan_text = \"\" nan_t = False if 'NH' in left_values or 'NH' in right_values : heard_i_left , heard_level_left , not_heard_i_left , not_heard_level_left = split_values ( x_vals , left_values , target_values ) heard_i_right , heard_level_right , not_heard_i_right , not_heard_level_right = split_values ( x_vals , right_values , target_values ) if binaural : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_BINAURAL ) ax . plot ( heard_i_left , heard_level_left , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left , marker = NOT_HEARD_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'nicht geh\u00f6rt' ) else : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_RIGHT ) ax . plot ( heard_i_right , heard_level_right , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markerfacecolor = 'none' , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts geh\u00f6rt' ) ax . plot ( not_heard_i_right , not_heard_level_right , marker = NOT_HEARD_RIGHT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts nicht geh\u00f6rt' ) ax . plot ( x_vals , target_values + SHIFT , linestyle = '-' , color = COLOR_LEFT ) ax . plot ( heard_i_left , heard_level_left + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left + SHIFT , marker = NOT_HEARD_LEFT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links nicht geh\u00f6rt' ) else : x_vals_left , left_values = filter_none ( x_vals , left_values ) x_vals_right , right_values = filter_none ( x_vals , right_values ) if binaural : ax . plot ( x_vals_left , left_values , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = '-' , color = COLOR_BINAURAL , label = 'binaural' ) else : ax . plot ( x_vals_right , right_values , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , markerfacecolor = 'none' , label = 'rechtes Ohr' ) ax . plot ( x_vals_left , left_values + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'linkes Ohr' ) if nan_freqs_left or nan_freqs_right : and_str = \"\" nan_text = \"Bei folgenden Frequenzen konnte kein Wert ermittelt werden: \\n \" print ( nan_freqs_left , nan_freqs_right ) if nan_freqs_left : nan_text += f \"links: { ', ' . join ( map ( str , nan_freqs_left )) } \" and_str = \"und \" if nan_freqs_right : nan_text += f \" { and_str } rechts: { ', ' . join ( map ( str , nan_freqs_right )) } \" nan_t = ax . text ( 0.05 , - 0.2 , nan_text , transform = ax . transAxes , fontsize = TEXT_FONT_SIZE , ha = 'left' , va = 'top' , bbox = dict ( facecolor = 'None' , edgecolor = 'None' )) ax . invert_yaxis () if subtitle : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE , y = 1.02 ) ax . set_title ( subtitle , fontsize = LABEL_FONT_SIZE , pad = 20 ) else : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE ) ax . set_xlabel ( 'Frequenzen (Hz)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylabel ( 'H\u00f6rschwelle (dB HL)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylim ( 120 , - 10 ) ax . set_xticks ( range ( len ( freqs ))) ax . set_xticklabels ([ f \" { int ( freq ) } \" for freq in freqs ], fontsize = TICK_FONT_SIZE ) ax . set_yticks ( np . arange ( 0 , 121 , 10 )) ax . set_yticklabels ( np . arange ( 0 , 121 , 10 ), fontsize = TICK_FONT_SIZE ) ax . grid ( True , which = 'both' , linestyle = '--' , linewidth = 0.5 ) lgd = ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1.15 , 0.205 ), fontsize = LEGEND_FONT_SIZE , frameon = False , labelspacing = 1 ) if nan_t : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 , nan_t ), bbox_inches = 'tight' ) else : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 ), bbox_inches = 'tight' ) plt . close ( fig )","title":"create_audiogram"},{"location":"api/model/","text":"model Module \u00b6 This module contains the classes for the familiarization, the main procedure, and the screening. Calibration \u00b6 Bases: Procedure Source code in app\\model.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 class Calibration ( Procedure ): def __init__ ( self , startlevel : int = 60 , signal_length : int = 10 , headphone_name : str = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ] def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2 def play_one_freq ( self ) -> tuple : \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) def set_calibration_value ( self , measured_value : float ): \"\"\"Rights the given calibration value into temporary CSV file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile ) def finish_calibration ( self ): \"\"\"Makes a permanent CSV file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary CSV file \"\"\" self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename ) def stop_playing ( self ): \"\"\"Stops the audio player. \"\"\" self . ap . stop () __init__ \u00b6 __init__ ( startlevel = 60 , signal_length = 10 , headphone_name = 'Sennheiser_HDA200' , ** additional_data ) Process for calibrating system. Parameters: startlevel ( int , default: 60 ) \u2013 starting level of procedure in dB HL. Defaults to 60. signal_length ( int , default: 10 ) \u2013 length of played signals in seconds. Defaults to 10. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Source code in app\\model.py 695 696 697 698 699 700 701 702 703 704 705 706 707 def __init__ ( self , startlevel : int = 60 , signal_length : int = 10 , headphone_name : str = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ] finish_calibration \u00b6 finish_calibration () Makes a permanent CSV file from the temporary file that overwrites calibration.csv. Parameters: temp_filename ( str ) \u2013 name of temporary CSV file Source code in app\\model.py 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 def finish_calibration ( self ): \"\"\"Makes a permanent CSV file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary CSV file \"\"\" self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename ) get_next_freq \u00b6 get_next_freq () Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int \u2013 frequency Source code in app\\model.py 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2 play_one_freq \u00b6 play_one_freq () Get the next frequency and play it. Returns: bool ( tuple ) \u2013 False if no more frequencies left int ( tuple ) \u2013 current frequency float ( tuple ) \u2013 expected SPL value in dB Source code in app\\model.py 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 def play_one_freq ( self ) -> tuple : \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl repeat_freq \u00b6 repeat_freq () Repeats the last played frequency. Source code in app\\model.py 751 752 753 754 755 756 def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) set_calibration_value \u00b6 set_calibration_value ( measured_value ) Rights the given calibration value into temporary CSV file Parameters: measured_value ( float ) \u2013 measured SPL value in dB Source code in app\\model.py 758 759 760 761 762 763 764 765 def set_calibration_value ( self , measured_value : float ): \"\"\"Rights the given calibration value into temporary CSV file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile ) stop_playing \u00b6 stop_playing () Stops the audio player. Source code in app\\model.py 788 789 790 791 def stop_playing ( self ): \"\"\"Stops the audio player. \"\"\" self . ap . stop () Familiarization \u00b6 Bases: Procedure Source code in app\\model.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 class Familiarization ( Procedure ): def __init__ ( self , startlevel : int = 40 , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True , id : str = \"\" , ** additional_data ): \"\"\"Creates the Familiarization process. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. id (str, optional): id to be stored, that will later be used for naming exported CSV file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies def get_temp_csv_filename ( self ) -> str : \"\"\"Gets name of temp CSV file. Returns: str: name of CSV file \"\"\" return self . tempfile def familiarize ( self ) -> bool : \"\"\"Main function. Returns: bool: familiarization successful \"\"\" self . progress = 0.01 while True : self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 if self . progress < 1 / 5 : self . progress = 1 / 5 else : self . level += 10 if self . progress < 1 / 3 : self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True __init__ \u00b6 __init__ ( startlevel = 40 , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True , id = '' , ** additional_data ) Creates the Familiarization process. Parameters: startlevel ( int , default: 40 ) \u2013 starting level of procedure in dB HL. Defaults to 40. signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. id ( str , default: '' ) \u2013 id to be stored, that will later be used for naming exported CSV file **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Source code in app\\model.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 def __init__ ( self , startlevel : int = 40 , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True , id : str = \"\" , ** additional_data ): \"\"\"Creates the Familiarization process. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. id (str, optional): id to be stored, that will later be used for naming exported CSV file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies familiarize \u00b6 familiarize () Main function. Returns: bool ( bool ) \u2013 familiarization successful Source code in app\\model.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 def familiarize ( self ) -> bool : \"\"\"Main function. Returns: bool: familiarization successful \"\"\" self . progress = 0.01 while True : self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 if self . progress < 1 / 5 : self . progress = 1 / 5 else : self . level += 10 if self . progress < 1 / 3 : self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True get_temp_csv_filename \u00b6 get_temp_csv_filename () Gets name of temp CSV file. Returns: str ( str ) \u2013 name of CSV file Source code in app\\model.py 370 371 372 373 374 375 376 def get_temp_csv_filename ( self ) -> str : \"\"\"Gets name of temp CSV file. Returns: str: name of CSV file \"\"\" return self . tempfile Procedure \u00b6 Source code in app\\model.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 class Procedure : def __init__ ( self , startlevel : float , signal_length : float , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Creates the parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. This is a rough guess for uncalibrated systems and will be adjusted through the calibration file self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = False # set True to be able to skip procedures with right arrow key self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = self . get_save_path () # Initialize save_path def get_retspl_values ( self , headphone_name : str ): \"\"\"Reads the correct RETSPL values from the retspl.csv file. Args: headphone_name (str): exact name of headphone as it appears in CSV file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values def get_calibration_values ( self ) -> dict : \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values def dbhl_to_volume ( self , dbhl : float ) -> float : \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl def key_press ( self , key : keyboard . Key ): \"\"\"Function for pynputto be called on key press Args: key (keyboard.Key): key that was pressed \"\"\" if key == keyboard . Key . space : self . tone_heard = True print ( \"Tone heard!\" ) elif self . test_mode and key == keyboard . Key . right : self . jump_to_end = True def play_tone ( self ): \"\"\"Sets tone_heard to False, play beep, then waits 4 s (max) for keypress. Sets tone_heard to True if key is pressed. Then waits for around 1 s to 2.5 s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times def create_temp_csv ( self , id : str = \"\" , ** additional_data ) -> str : \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (str, optional): id to be stored, that will later be used for naming exported csv file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name def add_to_temp_csv ( self , value : str , frequency : str , side : str , temp_filename : str ): \"\"\"Add a value in for a specific frequency to the temporary CSV file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary CSV file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ]) def get_value_from_csv ( self , frequency : str , temp_filename : str , side : str = 'l' ) -> str : \"\"\"Get the value at a specific frequency from the temporary CSV file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary CSV file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ] def create_final_csv_and_audiogram ( self , temp_filename : str , binaural : bool = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels ) def parse_dbhl_value ( self , value : str ) -> int : \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None def get_progress ( self ) -> float : \"\"\"Gets the current progress. Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress def get_save_path ( self ) -> str : \"\"\"Gets selected path from settings.csv file for saving files. Returns: str: save path \"\"\" file_name = 'settings.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return save_path = \"\" try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) settings = next ( reader ) if settings [ 'file path' ]: save_path = settings [ 'file path' ] else : save_path = os . getcwd () except Exception as e : print ( f \"Error reading the file: { e } \" ) return return save_path __init__ \u00b6 __init__ ( startlevel , signal_length , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Creates the parent class for the familiarization, the main procedure, and the screening. Parameters: startlevel ( float ) \u2013 starting level of procedure in dB HL signal_length ( float ) \u2013 length of played signals in seconds headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. Source code in app\\model.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , startlevel : float , signal_length : float , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Creates the parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. This is a rough guess for uncalibrated systems and will be adjusted through the calibration file self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = False # set True to be able to skip procedures with right arrow key self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = self . get_save_path () # Initialize save_path add_to_temp_csv \u00b6 add_to_temp_csv ( value , frequency , side , temp_filename ) Add a value in for a specific frequency to the temporary CSV file Parameters: value ( str ) \u2013 level in dB HL at specific frequency frequency ( str ) \u2013 frequency where value should be added side ( str ) \u2013 specify which ear ('l' or 'r') temp_filename ( str ) \u2013 name of temporary CSV file Source code in app\\model.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def add_to_temp_csv ( self , value : str , frequency : str , side : str , temp_filename : str ): \"\"\"Add a value in for a specific frequency to the temporary CSV file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary CSV file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ]) create_final_csv_and_audiogram \u00b6 create_final_csv_and_audiogram ( temp_filename , binaural = False ) Creates a permanent CSV file and audiogram from the temporary file. Parameters: temp_filename ( str ) \u2013 Name of the temporary CSV file. binaural ( bool , default: False ) \u2013 If the test is binaural. Source code in app\\model.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def create_final_csv_and_audiogram ( self , temp_filename : str , binaural : bool = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels ) create_temp_csv \u00b6 create_temp_csv ( id = '' , ** additional_data ) Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Parameters: id ( str , default: '' ) \u2013 id to be stored, that will later be used for naming exported csv file **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Returns: str ( str ) \u2013 name of temporary file Source code in app\\model.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def create_temp_csv ( self , id : str = \"\" , ** additional_data ) -> str : \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (str, optional): id to be stored, that will later be used for naming exported csv file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name dbhl_to_volume \u00b6 dbhl_to_volume ( dbhl ) Calculate dB HL into absolute numbers. Parameters: dbhl ( float ) \u2013 value in dB HL Returns: float ( float ) \u2013 value in absolute numbers Source code in app\\model.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def dbhl_to_volume ( self , dbhl : float ) -> float : \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl get_calibration_values \u00b6 get_calibration_values () Read the correct calibration values from the calibration.csv file. Returns: dict \u2013 dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def get_calibration_values ( self ) -> dict : \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values get_progress \u00b6 get_progress () Gets the current progress. Returns: float ( float ) \u2013 progress value between 0.0 and 1.0 Source code in app\\model.py 314 315 316 317 318 319 320 def get_progress ( self ) -> float : \"\"\"Gets the current progress. Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress get_retspl_values \u00b6 get_retspl_values ( headphone_name ) Reads the correct RETSPL values from the retspl.csv file. Parameters: headphone_name ( str ) \u2013 exact name of headphone as it appears in CSV file Returns: \u2013 dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def get_retspl_values ( self , headphone_name : str ): \"\"\"Reads the correct RETSPL values from the retspl.csv file. Args: headphone_name (str): exact name of headphone as it appears in CSV file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values get_save_path \u00b6 get_save_path () Gets selected path from settings.csv file for saving files. Returns: str ( str ) \u2013 save path Source code in app\\model.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def get_save_path ( self ) -> str : \"\"\"Gets selected path from settings.csv file for saving files. Returns: str: save path \"\"\" file_name = 'settings.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return save_path = \"\" try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) settings = next ( reader ) if settings [ 'file path' ]: save_path = settings [ 'file path' ] else : save_path = os . getcwd () except Exception as e : print ( f \"Error reading the file: { e } \" ) return return save_path get_value_from_csv \u00b6 get_value_from_csv ( frequency , temp_filename , side = 'l' ) Get the value at a specific frequency from the temporary CSV file. Parameters: frequency ( str ) \u2013 frequency where value is stored temp_filename ( str ) \u2013 name of temporary CSV file side ( str , default: 'l' ) \u2013 specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str ( str ) \u2013 dB HL value at specified frequency Source code in app\\model.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def get_value_from_csv ( self , frequency : str , temp_filename : str , side : str = 'l' ) -> str : \"\"\"Get the value at a specific frequency from the temporary CSV file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary CSV file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ] key_press \u00b6 key_press ( key ) Function for pynputto be called on key press Parameters: key ( Key ) \u2013 key that was pressed Source code in app\\model.py 132 133 134 135 136 137 138 139 140 141 142 def key_press ( self , key : keyboard . Key ): \"\"\"Function for pynputto be called on key press Args: key (keyboard.Key): key that was pressed \"\"\" if key == keyboard . Key . space : self . tone_heard = True print ( \"Tone heard!\" ) elif self . test_mode and key == keyboard . Key . right : self . jump_to_end = True parse_dbhl_value \u00b6 parse_dbhl_value ( value ) Parses the dBHL value from the CSV file. Parameters: value ( str ) \u2013 the value from the CSV file Returns: int \u2013 int or None: the parsed value or None if 'NH' Source code in app\\model.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def parse_dbhl_value ( self , value : str ) -> int : \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None play_tone \u00b6 play_tone () Sets tone_heard to False, play beep, then waits 4 s (max) for keypress. Sets tone_heard to True if key is pressed. Then waits for around 1 s to 2.5 s (randomized). Source code in app\\model.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def play_tone ( self ): \"\"\"Sets tone_heard to False, play beep, then waits 4 s (max) for keypress. Sets tone_heard to True if key is pressed. Then waits for around 1 s to 2.5 s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times ScreeningProcedure \u00b6 Bases: Procedure Source code in app\\model.py 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 class ScreeningProcedure ( Procedure ): def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14 def screen_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function. Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) def screen_one_ear ( self ): \"\"\"Screening for one ear. \"\"\" success = [] for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . screen_one_freq ( f ) success . append ( s ) def screen_one_freq ( self , freq : int ) -> bool : \"\"\"Screening for one frequency. Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step __init__ \u00b6 __init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Short screening process to check if subject can hear specific frequencies at certain levels. Parameters: temp_filename ( str ) \u2013 name of temporary CSV file where starting level is stored and future values will be stored. signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. Source code in app\\model.py 605 606 607 608 609 610 611 612 613 614 615 616 617 618 def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14 screen_one_ear \u00b6 screen_one_ear () Screening for one ear. Source code in app\\model.py 648 649 650 651 652 653 654 655 656 def screen_one_ear ( self ): \"\"\"Screening for one ear. \"\"\" success = [] for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . screen_one_freq ( f ) success . append ( s ) screen_one_freq \u00b6 screen_one_freq ( freq ) Screening for one frequency. Parameters: freq ( int ) \u2013 frequency to be tested Returns: bool ( bool ) \u2013 tone heard Source code in app\\model.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 def screen_one_freq ( self , freq : int ) -> bool : \"\"\"Screening for one frequency. Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step screen_test \u00b6 screen_test ( binaural = False ) Main function. Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 def screen_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function. Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) StandardProcedure \u00b6 Bases: Procedure Source code in app\\model.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 class StandardProcedure ( Procedure ): def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : float = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14 def standard_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False def standard_test_one_ear ( self ) -> bool : \"\"\"Audiometer for one ear. Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False def standard_test_one_freq ( self , freq : int , retest : bool = False ) -> bool : \"\"\"Test for one frequency. Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False __init__ \u00b6 __init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Standard audiometer process (rising level). Parameters: temp_filename ( str ) \u2013 name of temporary CSV file where starting level is stored and future values will be stored signal_length ( int , default: 1 ) \u2013 length of played signal in seconds. Defaults to 1. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. Source code in app\\model.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : float = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14 standard_test \u00b6 standard_test ( binaural = False ) Main function Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 def standard_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False standard_test_one_ear \u00b6 standard_test_one_ear () Audiometer for one ear. Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 def standard_test_one_ear ( self ) -> bool : \"\"\"Audiometer for one ear. Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False standard_test_one_freq \u00b6 standard_test_one_freq ( freq , retest = False ) Test for one frequency. Parameters: freq ( int ) \u2013 frequency at which hearing is tested retest ( bool , default: False ) \u2013 this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 def standard_test_one_freq ( self , freq : int , retest : bool = False ) -> bool : \"\"\"Test for one frequency. Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False","title":"model"},{"location":"api/model/#model-module","text":"This module contains the classes for the familiarization, the main procedure, and the screening.","title":"model Module"},{"location":"api/model/#app.model.Calibration","text":"Bases: Procedure Source code in app\\model.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 class Calibration ( Procedure ): def __init__ ( self , startlevel : int = 60 , signal_length : int = 10 , headphone_name : str = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ] def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2 def play_one_freq ( self ) -> tuple : \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) def set_calibration_value ( self , measured_value : float ): \"\"\"Rights the given calibration value into temporary CSV file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile ) def finish_calibration ( self ): \"\"\"Makes a permanent CSV file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary CSV file \"\"\" self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename ) def stop_playing ( self ): \"\"\"Stops the audio player. \"\"\" self . ap . stop ()","title":"Calibration"},{"location":"api/model/#app.model.Calibration.__init__","text":"__init__ ( startlevel = 60 , signal_length = 10 , headphone_name = 'Sennheiser_HDA200' , ** additional_data ) Process for calibrating system. Parameters: startlevel ( int , default: 60 ) \u2013 starting level of procedure in dB HL. Defaults to 60. signal_length ( int , default: 10 ) \u2013 length of played signals in seconds. Defaults to 10. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Source code in app\\model.py 695 696 697 698 699 700 701 702 703 704 705 706 707 def __init__ ( self , startlevel : int = 60 , signal_length : int = 10 , headphone_name : str = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ]","title":"__init__"},{"location":"api/model/#app.model.Calibration.finish_calibration","text":"finish_calibration () Makes a permanent CSV file from the temporary file that overwrites calibration.csv. Parameters: temp_filename ( str ) \u2013 name of temporary CSV file Source code in app\\model.py 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 def finish_calibration ( self ): \"\"\"Makes a permanent CSV file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary CSV file \"\"\" self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename )","title":"finish_calibration"},{"location":"api/model/#app.model.Calibration.get_next_freq","text":"get_next_freq () Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int \u2013 frequency Source code in app\\model.py 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2","title":"get_next_freq"},{"location":"api/model/#app.model.Calibration.play_one_freq","text":"play_one_freq () Get the next frequency and play it. Returns: bool ( tuple ) \u2013 False if no more frequencies left int ( tuple ) \u2013 current frequency float ( tuple ) \u2013 expected SPL value in dB Source code in app\\model.py 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 def play_one_freq ( self ) -> tuple : \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl","title":"play_one_freq"},{"location":"api/model/#app.model.Calibration.repeat_freq","text":"repeat_freq () Repeats the last played frequency. Source code in app\\model.py 751 752 753 754 755 756 def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side )","title":"repeat_freq"},{"location":"api/model/#app.model.Calibration.set_calibration_value","text":"set_calibration_value ( measured_value ) Rights the given calibration value into temporary CSV file Parameters: measured_value ( float ) \u2013 measured SPL value in dB Source code in app\\model.py 758 759 760 761 762 763 764 765 def set_calibration_value ( self , measured_value : float ): \"\"\"Rights the given calibration value into temporary CSV file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile )","title":"set_calibration_value"},{"location":"api/model/#app.model.Calibration.stop_playing","text":"stop_playing () Stops the audio player. Source code in app\\model.py 788 789 790 791 def stop_playing ( self ): \"\"\"Stops the audio player. \"\"\" self . ap . stop ()","title":"stop_playing"},{"location":"api/model/#app.model.Familiarization","text":"Bases: Procedure Source code in app\\model.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 class Familiarization ( Procedure ): def __init__ ( self , startlevel : int = 40 , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True , id : str = \"\" , ** additional_data ): \"\"\"Creates the Familiarization process. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. id (str, optional): id to be stored, that will later be used for naming exported CSV file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies def get_temp_csv_filename ( self ) -> str : \"\"\"Gets name of temp CSV file. Returns: str: name of CSV file \"\"\" return self . tempfile def familiarize ( self ) -> bool : \"\"\"Main function. Returns: bool: familiarization successful \"\"\" self . progress = 0.01 while True : self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 if self . progress < 1 / 5 : self . progress = 1 / 5 else : self . level += 10 if self . progress < 1 / 3 : self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True","title":"Familiarization"},{"location":"api/model/#app.model.Familiarization.__init__","text":"__init__ ( startlevel = 40 , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True , id = '' , ** additional_data ) Creates the Familiarization process. Parameters: startlevel ( int , default: 40 ) \u2013 starting level of procedure in dB HL. Defaults to 40. signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. id ( str , default: '' ) \u2013 id to be stored, that will later be used for naming exported CSV file **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Source code in app\\model.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 def __init__ ( self , startlevel : int = 40 , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True , id : str = \"\" , ** additional_data ): \"\"\"Creates the Familiarization process. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. id (str, optional): id to be stored, that will later be used for naming exported CSV file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies","title":"__init__"},{"location":"api/model/#app.model.Familiarization.familiarize","text":"familiarize () Main function. Returns: bool ( bool ) \u2013 familiarization successful Source code in app\\model.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 def familiarize ( self ) -> bool : \"\"\"Main function. Returns: bool: familiarization successful \"\"\" self . progress = 0.01 while True : self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 if self . progress < 1 / 5 : self . progress = 1 / 5 else : self . level += 10 if self . progress < 1 / 3 : self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True","title":"familiarize"},{"location":"api/model/#app.model.Familiarization.get_temp_csv_filename","text":"get_temp_csv_filename () Gets name of temp CSV file. Returns: str ( str ) \u2013 name of CSV file Source code in app\\model.py 370 371 372 373 374 375 376 def get_temp_csv_filename ( self ) -> str : \"\"\"Gets name of temp CSV file. Returns: str: name of CSV file \"\"\" return self . tempfile","title":"get_temp_csv_filename"},{"location":"api/model/#app.model.Procedure","text":"Source code in app\\model.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 class Procedure : def __init__ ( self , startlevel : float , signal_length : float , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Creates the parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. This is a rough guess for uncalibrated systems and will be adjusted through the calibration file self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = False # set True to be able to skip procedures with right arrow key self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = self . get_save_path () # Initialize save_path def get_retspl_values ( self , headphone_name : str ): \"\"\"Reads the correct RETSPL values from the retspl.csv file. Args: headphone_name (str): exact name of headphone as it appears in CSV file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values def get_calibration_values ( self ) -> dict : \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values def dbhl_to_volume ( self , dbhl : float ) -> float : \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl def key_press ( self , key : keyboard . Key ): \"\"\"Function for pynputto be called on key press Args: key (keyboard.Key): key that was pressed \"\"\" if key == keyboard . Key . space : self . tone_heard = True print ( \"Tone heard!\" ) elif self . test_mode and key == keyboard . Key . right : self . jump_to_end = True def play_tone ( self ): \"\"\"Sets tone_heard to False, play beep, then waits 4 s (max) for keypress. Sets tone_heard to True if key is pressed. Then waits for around 1 s to 2.5 s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times def create_temp_csv ( self , id : str = \"\" , ** additional_data ) -> str : \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (str, optional): id to be stored, that will later be used for naming exported csv file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name def add_to_temp_csv ( self , value : str , frequency : str , side : str , temp_filename : str ): \"\"\"Add a value in for a specific frequency to the temporary CSV file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary CSV file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ]) def get_value_from_csv ( self , frequency : str , temp_filename : str , side : str = 'l' ) -> str : \"\"\"Get the value at a specific frequency from the temporary CSV file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary CSV file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ] def create_final_csv_and_audiogram ( self , temp_filename : str , binaural : bool = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels ) def parse_dbhl_value ( self , value : str ) -> int : \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None def get_progress ( self ) -> float : \"\"\"Gets the current progress. Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress def get_save_path ( self ) -> str : \"\"\"Gets selected path from settings.csv file for saving files. Returns: str: save path \"\"\" file_name = 'settings.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return save_path = \"\" try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) settings = next ( reader ) if settings [ 'file path' ]: save_path = settings [ 'file path' ] else : save_path = os . getcwd () except Exception as e : print ( f \"Error reading the file: { e } \" ) return return save_path","title":"Procedure"},{"location":"api/model/#app.model.Procedure.__init__","text":"__init__ ( startlevel , signal_length , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Creates the parent class for the familiarization, the main procedure, and the screening. Parameters: startlevel ( float ) \u2013 starting level of procedure in dB HL signal_length ( float ) \u2013 length of played signals in seconds headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. Source code in app\\model.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , startlevel : float , signal_length : float , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Creates the parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. This is a rough guess for uncalibrated systems and will be adjusted through the calibration file self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = False # set True to be able to skip procedures with right arrow key self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = self . get_save_path () # Initialize save_path","title":"__init__"},{"location":"api/model/#app.model.Procedure.add_to_temp_csv","text":"add_to_temp_csv ( value , frequency , side , temp_filename ) Add a value in for a specific frequency to the temporary CSV file Parameters: value ( str ) \u2013 level in dB HL at specific frequency frequency ( str ) \u2013 frequency where value should be added side ( str ) \u2013 specify which ear ('l' or 'r') temp_filename ( str ) \u2013 name of temporary CSV file Source code in app\\model.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def add_to_temp_csv ( self , value : str , frequency : str , side : str , temp_filename : str ): \"\"\"Add a value in for a specific frequency to the temporary CSV file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary CSV file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ])","title":"add_to_temp_csv"},{"location":"api/model/#app.model.Procedure.create_final_csv_and_audiogram","text":"create_final_csv_and_audiogram ( temp_filename , binaural = False ) Creates a permanent CSV file and audiogram from the temporary file. Parameters: temp_filename ( str ) \u2013 Name of the temporary CSV file. binaural ( bool , default: False ) \u2013 If the test is binaural. Source code in app\\model.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def create_final_csv_and_audiogram ( self , temp_filename : str , binaural : bool = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels )","title":"create_final_csv_and_audiogram"},{"location":"api/model/#app.model.Procedure.create_temp_csv","text":"create_temp_csv ( id = '' , ** additional_data ) Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Parameters: id ( str , default: '' ) \u2013 id to be stored, that will later be used for naming exported csv file **additional_data \u2013 additional key/value pairs to be stored in CSV file after procedure is done Returns: str ( str ) \u2013 name of temporary file Source code in app\\model.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def create_temp_csv ( self , id : str = \"\" , ** additional_data ) -> str : \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (str, optional): id to be stored, that will later be used for naming exported csv file **additional_data: additional key/value pairs to be stored in CSV file after procedure is done Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name","title":"create_temp_csv"},{"location":"api/model/#app.model.Procedure.dbhl_to_volume","text":"dbhl_to_volume ( dbhl ) Calculate dB HL into absolute numbers. Parameters: dbhl ( float ) \u2013 value in dB HL Returns: float ( float ) \u2013 value in absolute numbers Source code in app\\model.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def dbhl_to_volume ( self , dbhl : float ) -> float : \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl","title":"dbhl_to_volume"},{"location":"api/model/#app.model.Procedure.get_calibration_values","text":"get_calibration_values () Read the correct calibration values from the calibration.csv file. Returns: dict \u2013 dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def get_calibration_values ( self ) -> dict : \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values","title":"get_calibration_values"},{"location":"api/model/#app.model.Procedure.get_progress","text":"get_progress () Gets the current progress. Returns: float ( float ) \u2013 progress value between 0.0 and 1.0 Source code in app\\model.py 314 315 316 317 318 319 320 def get_progress ( self ) -> float : \"\"\"Gets the current progress. Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress","title":"get_progress"},{"location":"api/model/#app.model.Procedure.get_retspl_values","text":"get_retspl_values ( headphone_name ) Reads the correct RETSPL values from the retspl.csv file. Parameters: headphone_name ( str ) \u2013 exact name of headphone as it appears in CSV file Returns: \u2013 dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def get_retspl_values ( self , headphone_name : str ): \"\"\"Reads the correct RETSPL values from the retspl.csv file. Args: headphone_name (str): exact name of headphone as it appears in CSV file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values","title":"get_retspl_values"},{"location":"api/model/#app.model.Procedure.get_save_path","text":"get_save_path () Gets selected path from settings.csv file for saving files. Returns: str ( str ) \u2013 save path Source code in app\\model.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def get_save_path ( self ) -> str : \"\"\"Gets selected path from settings.csv file for saving files. Returns: str: save path \"\"\" file_name = 'settings.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return save_path = \"\" try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) settings = next ( reader ) if settings [ 'file path' ]: save_path = settings [ 'file path' ] else : save_path = os . getcwd () except Exception as e : print ( f \"Error reading the file: { e } \" ) return return save_path","title":"get_save_path"},{"location":"api/model/#app.model.Procedure.get_value_from_csv","text":"get_value_from_csv ( frequency , temp_filename , side = 'l' ) Get the value at a specific frequency from the temporary CSV file. Parameters: frequency ( str ) \u2013 frequency where value is stored temp_filename ( str ) \u2013 name of temporary CSV file side ( str , default: 'l' ) \u2013 specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str ( str ) \u2013 dB HL value at specified frequency Source code in app\\model.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def get_value_from_csv ( self , frequency : str , temp_filename : str , side : str = 'l' ) -> str : \"\"\"Get the value at a specific frequency from the temporary CSV file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary CSV file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ]","title":"get_value_from_csv"},{"location":"api/model/#app.model.Procedure.key_press","text":"key_press ( key ) Function for pynputto be called on key press Parameters: key ( Key ) \u2013 key that was pressed Source code in app\\model.py 132 133 134 135 136 137 138 139 140 141 142 def key_press ( self , key : keyboard . Key ): \"\"\"Function for pynputto be called on key press Args: key (keyboard.Key): key that was pressed \"\"\" if key == keyboard . Key . space : self . tone_heard = True print ( \"Tone heard!\" ) elif self . test_mode and key == keyboard . Key . right : self . jump_to_end = True","title":"key_press"},{"location":"api/model/#app.model.Procedure.parse_dbhl_value","text":"parse_dbhl_value ( value ) Parses the dBHL value from the CSV file. Parameters: value ( str ) \u2013 the value from the CSV file Returns: int \u2013 int or None: the parsed value or None if 'NH' Source code in app\\model.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def parse_dbhl_value ( self , value : str ) -> int : \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None","title":"parse_dbhl_value"},{"location":"api/model/#app.model.Procedure.play_tone","text":"play_tone () Sets tone_heard to False, play beep, then waits 4 s (max) for keypress. Sets tone_heard to True if key is pressed. Then waits for around 1 s to 2.5 s (randomized). Source code in app\\model.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def play_tone ( self ): \"\"\"Sets tone_heard to False, play beep, then waits 4 s (max) for keypress. Sets tone_heard to True if key is pressed. Then waits for around 1 s to 2.5 s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times","title":"play_tone"},{"location":"api/model/#app.model.ScreeningProcedure","text":"Bases: Procedure Source code in app\\model.py 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 class ScreeningProcedure ( Procedure ): def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14 def screen_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function. Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) def screen_one_ear ( self ): \"\"\"Screening for one ear. \"\"\" success = [] for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . screen_one_freq ( f ) success . append ( s ) def screen_one_freq ( self , freq : int ) -> bool : \"\"\"Screening for one frequency. Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step","title":"ScreeningProcedure"},{"location":"api/model/#app.model.ScreeningProcedure.__init__","text":"__init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Short screening process to check if subject can hear specific frequencies at certain levels. Parameters: temp_filename ( str ) \u2013 name of temporary CSV file where starting level is stored and future values will be stored. signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. Source code in app\\model.py 605 606 607 608 609 610 611 612 613 614 615 616 617 618 def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : str = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored. signal_length (int, optional): length of played signals in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14","title":"__init__"},{"location":"api/model/#app.model.ScreeningProcedure.screen_one_ear","text":"screen_one_ear () Screening for one ear. Source code in app\\model.py 648 649 650 651 652 653 654 655 656 def screen_one_ear ( self ): \"\"\"Screening for one ear. \"\"\" success = [] for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . screen_one_freq ( f ) success . append ( s )","title":"screen_one_ear"},{"location":"api/model/#app.model.ScreeningProcedure.screen_one_freq","text":"screen_one_freq ( freq ) Screening for one frequency. Parameters: freq ( int ) \u2013 frequency to be tested Returns: bool ( bool ) \u2013 tone heard Source code in app\\model.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 def screen_one_freq ( self , freq : int ) -> bool : \"\"\"Screening for one frequency. Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step","title":"screen_one_freq"},{"location":"api/model/#app.model.ScreeningProcedure.screen_test","text":"screen_test ( binaural = False ) Main function. Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 def screen_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function. Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural )","title":"screen_test"},{"location":"api/model/#app.model.StandardProcedure","text":"Bases: Procedure Source code in app\\model.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 class StandardProcedure ( Procedure ): def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : float = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14 def standard_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False def standard_test_one_ear ( self ) -> bool : \"\"\"Audiometer for one ear. Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False def standard_test_one_freq ( self , freq : int , retest : bool = False ) -> bool : \"\"\"Test for one frequency. Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False","title":"StandardProcedure"},{"location":"api/model/#app.model.StandardProcedure.__init__","text":"__init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Standard audiometer process (rising level). Parameters: temp_filename ( str ) \u2013 name of temporary CSV file where starting level is stored and future values will be stored signal_length ( int , default: 1 ) \u2013 length of played signal in seconds. Defaults to 1. headphone_name ( str , default: 'Sennheiser_HDA200' ) \u2013 Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate ( bool , default: True ) \u2013 Use calibration file. Defaults to True. Source code in app\\model.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 def __init__ ( self , temp_filename : str , signal_length : int = 1 , headphone_name : float = \"Sennheiser_HDA200\" , calibrate : bool = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary CSV file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. headphone_name (str, optional): Name of headphone model being used. Defaults to Sennheiser_HDA200. calibrate (bool, optional): Use calibration file. Defaults to True. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14","title":"__init__"},{"location":"api/model/#app.model.StandardProcedure.standard_test","text":"standard_test ( binaural = False ) Main function Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 def standard_test ( self , binaural : bool = False ) -> bool : \"\"\"Main function Returns: bool: test successful \"\"\" self . progress = 0.01 if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False","title":"standard_test"},{"location":"api/model/#app.model.StandardProcedure.standard_test_one_ear","text":"standard_test_one_ear () Audiometer for one ear. Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 def standard_test_one_ear ( self ) -> bool : \"\"\"Audiometer for one ear. Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False","title":"standard_test_one_ear"},{"location":"api/model/#app.model.StandardProcedure.standard_test_one_freq","text":"standard_test_one_freq ( freq , retest = False ) Test for one frequency. Parameters: freq ( int ) \u2013 frequency at which hearing is tested retest ( bool , default: False ) \u2013 this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool ( bool ) \u2013 test successful Source code in app\\model.py 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 def standard_test_one_freq ( self , freq : int , retest : bool = False ) -> bool : \"\"\"Test for one frequency. Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False","title":"standard_test_one_freq"},{"location":"api/ui/","text":"ui Module \u00b6 This module contains the UI classes for the Audiometer application. The UI is built using the tkinter library. App \u00b6 Bases: Window Source code in app\\ui.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 class App ( tb . Window ): def __init__ ( self , familiarization_func : callable , program_funcs : dict , calibration_funcs : list , progress_func : callable ): \"\"\"Creats Main application window. Contains all pages and controls the flow of the program. Args: familiarization_func (function): function to be called for familiarization audiogram_func (function): function to be called for creating audiogram program_funcs (dict of str:function): function(s) to be called for the main program calibration_funcs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level \"\"\" themename = self . get_theme () super () . __init__ ( themename = themename ) # General theme settings self . title ( \"Sound Player\" ) self . geometry ( GEOMETRY ) self . minsize ( 650 , 650 ) self . attributes ( '-fullscreen' , True ) self . bind ( \"<Escape>\" , self . exit_fullscreen ) self . save_path = os . path . join ( os . getcwd ()) # Ensure the default save path exists os . makedirs ( self . save_path , exist_ok = True ) self . set_icon ( \"Logo_NBG.png\" ) #change the icon maybe? #TODO self . tk . call ( 'tk' , 'scaling' , 2.0 ) # Adjust for high-DPI displays # Dictionary to store all pages self . program_funcs = program_funcs self . frames = {} self . binaural_test = False # Interactive Pages for F in ( MainMenu , FamiliarizationPage , ProgramPage , ResultPage ): frame = F ( self ) self . frames [ F ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Calibration separately to give it its functions frame = CalibrationPage ( self , calibration_funcs ) self . frames [ CalibrationPage ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during familiarization frame = DuringFamiliarizationView ( self , familiarization_func , progress_func ) self . frames [ DuringFamiliarizationView ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during programs for name , program_func in program_funcs . items (): frame = DuringProcedureView ( self , program_func , progress_func , text = \"Programm l\u00e4uft...\" ) self . frames [ name ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Show MainMenu first self . show_frame ( MainMenu ) # Create menubar self . create_menubar () # Variable for threading self . process_done = False # Override the close button protocol self . protocol ( \"WM_DELETE_WINDOW\" , self . on_closing ) self . grid_rowconfigure ( 0 , weight = 1 ) self . grid_columnconfigure ( 0 , weight = 1 ) def create_menubar ( self ): \"\"\"Creates a menubar with options for changing the theme and exiting the program. \"\"\" menubar = tk . Menu ( self ) self . config ( menu = menubar ) file_menu = tk . Menu ( menubar , tearoff = 0 ) file_menu . add_command ( label = \"Startseite\" , command = lambda : self . show_frame ( MainMenu )) file_menu . add_command ( label = \"Speicherort \u00e4ndern\" , command = self . change_save_path ) ChangeTheme = tk . Menu ( file_menu , tearoff = 0 ) ChangeTheme . add_command ( label = \"light\" , command = lambda : self . change_theme ( LIGHT_THEME )) ChangeTheme . add_command ( label = \"dark\" , command = lambda : self . change_theme ( DARK_THEME )) file_menu . add_cascade ( label = \"Theme \u00e4ndern\" , menu = ChangeTheme ) file_menu . add_separator () file_menu . add_command ( label = \"Programm beenden\" , command = self . on_closing ) menubar . add_cascade ( label = \"Einstellungen\" , menu = file_menu ) def change_theme ( self , theme_name : str ): \"\"\"Changes to the specified theme. Args: theme_name (str): name of the theme to change \"\"\" current_theme = self . style . theme_use () if current_theme == theme_name : messagebox . showwarning ( \"Oops..\" , \"Dieses Theme wird bereits verwendet.\" ) else : self . style . theme_use ( theme_name ) # change in settings.csv file filename = \"settings.csv\" fieldnames = [ 'file path' , 'theme' ] # Read all rows from the settings.csv file with open ( filename , mode = 'r' , newline = '' ) as file : dict_reader = csv . DictReader ( file ) rows = list ( dict_reader ) # Update the relevant row rows [ 0 ][ 'theme' ] = theme_name # Write all rows back to the CSV file with open ( filename , mode = 'w' , newline = '' ) as file : dict_writer = csv . DictWriter ( file , fieldnames = fieldnames ) dict_writer . writeheader () dict_writer . writerows ( rows ) def get_theme ( self ): \"\"\"Gets currently selected theme from settings.csv file. Returns: str: name of light theme or name of dark theme \"\"\" file_name = \"settings.csv\" with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) settings = next ( reader ) if settings [ 'theme' ] == LIGHT_THEME : return LIGHT_THEME elif settings [ 'theme' ] == DARK_THEME : return DARK_THEME else : return LIGHT_THEME def exit_fullscreen ( self , event = None ): \"\"\"Exits fullscreen mode. \"\"\" self . attributes ( '-fullscreen' , False ) def set_icon ( self , path ): \"\"\"Sets the window icon using Pillow. \"\"\" img = Image . open ( path ) photo = ImageTk . PhotoImage ( img ) self . iconphoto ( False , photo ) def show_frame ( self , page ): \"\"\"Shows frame for the given page name. Args: page(class): class of the page to be shown \"\"\" frame = self . frames [ page ] frame . tkraise () def wait_for_process ( self , process , callback ): \"\"\"Starts a process in a new thread and calls a callback function when the process is done. Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" t = threading . Thread ( target = self . run_process , args = ( process , callback )) t . daemon = True t . start () def run_process ( self , process , callback ): \"\"\"Runs a process and calls a callback function when the process is done. Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" process () self . process_done = True self . after ( 100 , callback ) def change_save_path ( self ): \"\"\"Asks the user to select a folder to save the files. Changes settings.csv file accordingly. \"\"\" new_path = filedialog . askdirectory ( title = \"Select Folder to Save Files\" ) if new_path : # change in settings.csv file filename = \"settings.csv\" fieldnames = [ 'file path' , 'theme' ] # Read all rows from the settings.csv file with open ( filename , mode = 'r' , newline = '' ) as file : dict_reader = csv . DictReader ( file ) rows = list ( dict_reader ) # Update the relevant row rows [ 0 ][ 'file path' ] = new_path # Write all rows back to the CSV file with open ( filename , mode = 'w' , newline = '' ) as file : dict_writer = csv . DictWriter ( file , fieldnames = fieldnames ) dict_writer . writeheader () dict_writer . writerows ( rows ) self . save_path = new_path messagebox . showinfo ( \"Speicherort ge\u00e4ndert\" , f \"Neuer Speicherort: { self . save_path } \" ) def on_closing ( self ): \"\"\"Asks for confirmation before closing the program. \"\"\" if messagebox . askyesno ( title = \"Quit\" , message = \"M\u00f6chten Sie wirklich das Programm beenden?\" ): self . destroy () def get_images_in_path ( self , directory , image_extensions = [ \".png\" , \".jpg\" , \".jpeg\" , \".gif\" , \".bmp\" ]): \"\"\"Gets a list of image files in the specified directory. Args: directory (str): The path to the directory to check. image_extensions (list): List of image file extensions to check for. Returns: list: List of image file paths if any image files are found, False otherwise. \"\"\" if not os . path . exists ( directory ): return False image_files = [ os . path . join ( directory , file ) for file in os . listdir ( directory ) if any ( file . lower () . endswith ( ext ) for ext in image_extensions )] return image_files if image_files else False __init__ \u00b6 __init__ ( familiarization_func , program_funcs , calibration_funcs , progress_func ) Creats Main application window. Contains all pages and controls the flow of the program. Parameters: familiarization_func ( function ) \u2013 function to be called for familiarization audiogram_func ( function ) \u2013 function to be called for creating audiogram program_funcs ( dict of str ) \u2013 function): function(s) to be called for the main program calibration_funcs ( list function ) \u2013 list of function(s) for calibration in this order: start, next, repeat, stop, set_level Source code in app\\ui.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def __init__ ( self , familiarization_func : callable , program_funcs : dict , calibration_funcs : list , progress_func : callable ): \"\"\"Creats Main application window. Contains all pages and controls the flow of the program. Args: familiarization_func (function): function to be called for familiarization audiogram_func (function): function to be called for creating audiogram program_funcs (dict of str:function): function(s) to be called for the main program calibration_funcs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level \"\"\" themename = self . get_theme () super () . __init__ ( themename = themename ) # General theme settings self . title ( \"Sound Player\" ) self . geometry ( GEOMETRY ) self . minsize ( 650 , 650 ) self . attributes ( '-fullscreen' , True ) self . bind ( \"<Escape>\" , self . exit_fullscreen ) self . save_path = os . path . join ( os . getcwd ()) # Ensure the default save path exists os . makedirs ( self . save_path , exist_ok = True ) self . set_icon ( \"Logo_NBG.png\" ) #change the icon maybe? #TODO self . tk . call ( 'tk' , 'scaling' , 2.0 ) # Adjust for high-DPI displays # Dictionary to store all pages self . program_funcs = program_funcs self . frames = {} self . binaural_test = False # Interactive Pages for F in ( MainMenu , FamiliarizationPage , ProgramPage , ResultPage ): frame = F ( self ) self . frames [ F ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Calibration separately to give it its functions frame = CalibrationPage ( self , calibration_funcs ) self . frames [ CalibrationPage ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during familiarization frame = DuringFamiliarizationView ( self , familiarization_func , progress_func ) self . frames [ DuringFamiliarizationView ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during programs for name , program_func in program_funcs . items (): frame = DuringProcedureView ( self , program_func , progress_func , text = \"Programm l\u00e4uft...\" ) self . frames [ name ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Show MainMenu first self . show_frame ( MainMenu ) # Create menubar self . create_menubar () # Variable for threading self . process_done = False # Override the close button protocol self . protocol ( \"WM_DELETE_WINDOW\" , self . on_closing ) self . grid_rowconfigure ( 0 , weight = 1 ) self . grid_columnconfigure ( 0 , weight = 1 ) change_save_path \u00b6 change_save_path () Asks the user to select a folder to save the files. Changes settings.csv file accordingly. Source code in app\\ui.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def change_save_path ( self ): \"\"\"Asks the user to select a folder to save the files. Changes settings.csv file accordingly. \"\"\" new_path = filedialog . askdirectory ( title = \"Select Folder to Save Files\" ) if new_path : # change in settings.csv file filename = \"settings.csv\" fieldnames = [ 'file path' , 'theme' ] # Read all rows from the settings.csv file with open ( filename , mode = 'r' , newline = '' ) as file : dict_reader = csv . DictReader ( file ) rows = list ( dict_reader ) # Update the relevant row rows [ 0 ][ 'file path' ] = new_path # Write all rows back to the CSV file with open ( filename , mode = 'w' , newline = '' ) as file : dict_writer = csv . DictWriter ( file , fieldnames = fieldnames ) dict_writer . writeheader () dict_writer . writerows ( rows ) self . save_path = new_path messagebox . showinfo ( \"Speicherort ge\u00e4ndert\" , f \"Neuer Speicherort: { self . save_path } \" ) change_theme \u00b6 change_theme ( theme_name ) Changes to the specified theme. Parameters: theme_name ( str ) \u2013 name of the theme to change Source code in app\\ui.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def change_theme ( self , theme_name : str ): \"\"\"Changes to the specified theme. Args: theme_name (str): name of the theme to change \"\"\" current_theme = self . style . theme_use () if current_theme == theme_name : messagebox . showwarning ( \"Oops..\" , \"Dieses Theme wird bereits verwendet.\" ) else : self . style . theme_use ( theme_name ) # change in settings.csv file filename = \"settings.csv\" fieldnames = [ 'file path' , 'theme' ] # Read all rows from the settings.csv file with open ( filename , mode = 'r' , newline = '' ) as file : dict_reader = csv . DictReader ( file ) rows = list ( dict_reader ) # Update the relevant row rows [ 0 ][ 'theme' ] = theme_name # Write all rows back to the CSV file with open ( filename , mode = 'w' , newline = '' ) as file : dict_writer = csv . DictWriter ( file , fieldnames = fieldnames ) dict_writer . writeheader () dict_writer . writerows ( rows ) create_menubar \u00b6 create_menubar () Creates a menubar with options for changing the theme and exiting the program. Source code in app\\ui.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def create_menubar ( self ): \"\"\"Creates a menubar with options for changing the theme and exiting the program. \"\"\" menubar = tk . Menu ( self ) self . config ( menu = menubar ) file_menu = tk . Menu ( menubar , tearoff = 0 ) file_menu . add_command ( label = \"Startseite\" , command = lambda : self . show_frame ( MainMenu )) file_menu . add_command ( label = \"Speicherort \u00e4ndern\" , command = self . change_save_path ) ChangeTheme = tk . Menu ( file_menu , tearoff = 0 ) ChangeTheme . add_command ( label = \"light\" , command = lambda : self . change_theme ( LIGHT_THEME )) ChangeTheme . add_command ( label = \"dark\" , command = lambda : self . change_theme ( DARK_THEME )) file_menu . add_cascade ( label = \"Theme \u00e4ndern\" , menu = ChangeTheme ) file_menu . add_separator () file_menu . add_command ( label = \"Programm beenden\" , command = self . on_closing ) menubar . add_cascade ( label = \"Einstellungen\" , menu = file_menu ) exit_fullscreen \u00b6 exit_fullscreen ( event = None ) Exits fullscreen mode. Source code in app\\ui.py 158 159 160 161 def exit_fullscreen ( self , event = None ): \"\"\"Exits fullscreen mode. \"\"\" self . attributes ( '-fullscreen' , False ) get_images_in_path \u00b6 get_images_in_path ( directory , image_extensions = [ '.png' , '.jpg' , '.jpeg' , '.gif' , '.bmp' ]) Gets a list of image files in the specified directory. Args: directory (str): The path to the directory to check. image_extensions (list): List of image file extensions to check for. Returns: list: List of image file paths if any image files are found, False otherwise. Source code in app\\ui.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def get_images_in_path ( self , directory , image_extensions = [ \".png\" , \".jpg\" , \".jpeg\" , \".gif\" , \".bmp\" ]): \"\"\"Gets a list of image files in the specified directory. Args: directory (str): The path to the directory to check. image_extensions (list): List of image file extensions to check for. Returns: list: List of image file paths if any image files are found, False otherwise. \"\"\" if not os . path . exists ( directory ): return False image_files = [ os . path . join ( directory , file ) for file in os . listdir ( directory ) if any ( file . lower () . endswith ( ext ) for ext in image_extensions )] return image_files if image_files else False get_theme \u00b6 get_theme () Gets currently selected theme from settings.csv file. Returns: str \u2013 name of light theme or name of dark theme Source code in app\\ui.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def get_theme ( self ): \"\"\"Gets currently selected theme from settings.csv file. Returns: str: name of light theme or name of dark theme \"\"\" file_name = \"settings.csv\" with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) settings = next ( reader ) if settings [ 'theme' ] == LIGHT_THEME : return LIGHT_THEME elif settings [ 'theme' ] == DARK_THEME : return DARK_THEME else : return LIGHT_THEME on_closing \u00b6 on_closing () Asks for confirmation before closing the program. Source code in app\\ui.py 229 230 231 232 233 def on_closing ( self ): \"\"\"Asks for confirmation before closing the program. \"\"\" if messagebox . askyesno ( title = \"Quit\" , message = \"M\u00f6chten Sie wirklich das Programm beenden?\" ): self . destroy () run_process \u00b6 run_process ( process , callback ) Runs a process and calls a callback function when the process is done. Parameters: process ( function ) \u2013 function to be called callback ( function ) \u2013 function to be called when process is done Source code in app\\ui.py 190 191 192 193 194 195 196 197 198 199 def run_process ( self , process , callback ): \"\"\"Runs a process and calls a callback function when the process is done. Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" process () self . process_done = True self . after ( 100 , callback ) set_icon \u00b6 set_icon ( path ) Sets the window icon using Pillow. Source code in app\\ui.py 163 164 165 166 167 168 def set_icon ( self , path ): \"\"\"Sets the window icon using Pillow. \"\"\" img = Image . open ( path ) photo = ImageTk . PhotoImage ( img ) self . iconphoto ( False , photo ) show_frame \u00b6 show_frame ( page ) Shows frame for the given page name. Parameters: page(class) \u2013 class of the page to be shown Source code in app\\ui.py 170 171 172 173 174 175 176 177 def show_frame ( self , page ): \"\"\"Shows frame for the given page name. Args: page(class): class of the page to be shown \"\"\" frame = self . frames [ page ] frame . tkraise () wait_for_process \u00b6 wait_for_process ( process , callback ) Starts a process in a new thread and calls a callback function when the process is done. Parameters: process ( function ) \u2013 function to be called callback ( function ) \u2013 function to be called when process is done Source code in app\\ui.py 179 180 181 182 183 184 185 186 187 188 def wait_for_process ( self , process , callback ): \"\"\"Starts a process in a new thread and calls a callback function when the process is done. Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" t = threading . Thread ( target = self . run_process , args = ( process , callback )) t . daemon = True t . start () CalibrationPage \u00b6 Bases: Frame Source code in app\\ui.py 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 class CalibrationPage ( ttk . Frame ): def __init__ ( self , parent , calibration_funcs ): \"\"\"Creates Page for calibrating the audiometer. Args: parent (App): parent application calibration_funcs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level \"\"\" super () . __init__ ( parent ) self . parent = parent self . cal_start = calibration_funcs [ 0 ] self . cal_next = calibration_funcs [ 1 ] self . cal_repeat = calibration_funcs [ 2 ] self . cal_stop = calibration_funcs [ 3 ] self . cal_setlevel = calibration_funcs [ 4 ] self . create_widgets () self . finished = False def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" button_width = 25 self . intro = ttk . Label ( self , text = text_calibration , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . intro . pack ( padx = 10 , pady = 10 ) self . level_label = ttk . Label ( self , text = \"Wert in dBHL, bei dem kalibriert werden soll:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_label . pack ( padx = 10 , pady = 10 ) self . level_entry_var = tk . StringVar () self . level_entry_var . set ( \"10\" ) self . level_entry = ttk . Entry ( self , width = button_width - 10 , textvariable = self . level_entry_var ) self . level_entry . pack ( padx = 10 , pady = 10 ) self . start_button = ttk . Button ( self , text = \"Kalibrierung starten\" , command = self . start_calibration , width = button_width ) self . start_button . pack ( padx = 10 , pady = 10 ) self . next_button = ttk . Button ( self , text = \"N\u00e4chste Frequenz\" , command = self . next_frequency , width = button_width , state = tk . DISABLED ) self . next_button . pack ( padx = 10 , pady = 10 ) self . repeat_button = ttk . Button ( self , text = \"Erneut wiedergeben\" , command = self . repeat_frequency , width = button_width , state = tk . DISABLED ) self . repeat_button . pack ( padx = 10 , pady = 10 ) self . stop_button = ttk . Button ( self , text = \"Wiedergabe stoppen\" , command = self . stop_playing , width = button_width , state = tk . DISABLED ) self . stop_button . pack ( padx = 10 , pady = 10 ) self . back_button = ttk . Button ( self , text = \"Zur\u00fcck zum Hauptmen\u00fc\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) # TODO Kalibrierung resetten, damit man sie dann wieder von vorne anfangen kann self . back_button . pack ( padx = 10 , pady = 20 ) self . spacer_frame = tk . Frame ( self , width = 20 , height = 80 ) self . spacer_frame . pack () self . current_freq_var = tk . StringVar ( value = \"Aktuelle Frequenz:\" ) self . current_freq = ttk . Label ( self , textvariable = self . current_freq_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . current_freq . pack ( padx = 10 , pady = 10 ) self . level_expected_var = tk . StringVar ( value = \"Schalldruckpegel (soll):\" ) self . level_expected_label = ttk . Label ( self , textvariable = self . level_expected_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_expected_label . pack ( padx = 10 , pady = 10 ) self . level_measured_label = ttk . Label ( self , text = \"Gemessener Schalldruckpegel in dB:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_measured_label . pack ( padx = 10 , pady = 10 ) self . level_measured_var = tk . StringVar () self . level_measured_entry = ttk . Entry ( self , width = button_width - 10 , font = ( FONT_FAMILY , SUBHEADER_SIZE ), state = tk . DISABLED , textvariable = self . level_measured_var ) self . level_measured_entry . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) def start_calibration ( self ): \"\"\"Starts the calibration process and change state of buttons. \"\"\" try : current_freq , current_spl = self . cal_start ( float ( self . level_entry_var . get ())) except : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie eine Zahl ein.' ) return self . start_button . config ( state = tk . DISABLED ) self . next_button . config ( state = tk . NORMAL ) self . repeat_button . config ( state = tk . NORMAL ) self . stop_button . config ( state = tk . NORMAL ) self . level_measured_entry . config ( state = tk . NORMAL ) self . current_freq_var . set ( \"Aktuelle Frequenz: \" + str ( current_freq ) + \" Hz\" ) self . level_expected_var . set ( \"Schalldruckpegel (soll): \" + str ( current_spl ) + \" dB\" ) def next_frequency ( self ): \"\"\"Sets previously entered level, then get next frequency and play it. \"\"\" try : if self . level_measured_var . get () != \"\" : self . cal_setlevel ( float ( self . level_measured_var . get ())) else : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei \"gemessener Schalldruckpegel\" eine Zahl ein.' ) return except ValueError : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei \"gemessener Schalldruck\" eine Zahl ein.' ) return self . level_measured_var . set ( \"\" ) more_freqs , current_freq , current_spl = self . cal_next () # Change Button when last frequency if not more_freqs : # Grey out all buttons when finished if self . finished : self . next_button . config ( state = tk . DISABLED ) self . repeat_button . config ( state = tk . DISABLED ) self . stop_button . config ( state = tk . DISABLED ) self . level_measured_entry . config ( state = tk . DISABLED ) messagebox . showwarning ( \"Kalibrierung abgeschlossen.\" , \"Die Kalibrierung wurde erfolgreich abgeschlossen. Datei gespeichert als calibration.csv\" ) return self . next_button . config ( text = \"Kalibrierung abschlie\u00dfen\" ) self . finished = True self . current_freq_var . set ( \"Aktuelle Frequenz: \" + str ( current_freq ) + \" Hz\" ) self . level_expected_var . set ( \"Schalldruckpegel (soll): \" + str ( current_spl ) + \" dB\" ) def repeat_frequency ( self ): \"\"\"Replays the same frequency.\"\"\" self . cal_repeat () def stop_playing ( self ): \"\"\"Stops playing audio.\"\"\" self . cal_stop () __init__ \u00b6 __init__ ( parent , calibration_funcs ) Creates Page for calibrating the audiometer. Parameters: parent ( App ) \u2013 parent application calibration_funcs ( list function ) \u2013 list of function(s) for calibration in this order: start, next, repeat, stop, set_level Source code in app\\ui.py 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 def __init__ ( self , parent , calibration_funcs ): \"\"\"Creates Page for calibrating the audiometer. Args: parent (App): parent application calibration_funcs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level \"\"\" super () . __init__ ( parent ) self . parent = parent self . cal_start = calibration_funcs [ 0 ] self . cal_next = calibration_funcs [ 1 ] self . cal_repeat = calibration_funcs [ 2 ] self . cal_stop = calibration_funcs [ 3 ] self . cal_setlevel = calibration_funcs [ 4 ] self . create_widgets () self . finished = False create_widgets \u00b6 create_widgets () Creates the widgets for the page. Source code in app\\ui.py 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" button_width = 25 self . intro = ttk . Label ( self , text = text_calibration , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . intro . pack ( padx = 10 , pady = 10 ) self . level_label = ttk . Label ( self , text = \"Wert in dBHL, bei dem kalibriert werden soll:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_label . pack ( padx = 10 , pady = 10 ) self . level_entry_var = tk . StringVar () self . level_entry_var . set ( \"10\" ) self . level_entry = ttk . Entry ( self , width = button_width - 10 , textvariable = self . level_entry_var ) self . level_entry . pack ( padx = 10 , pady = 10 ) self . start_button = ttk . Button ( self , text = \"Kalibrierung starten\" , command = self . start_calibration , width = button_width ) self . start_button . pack ( padx = 10 , pady = 10 ) self . next_button = ttk . Button ( self , text = \"N\u00e4chste Frequenz\" , command = self . next_frequency , width = button_width , state = tk . DISABLED ) self . next_button . pack ( padx = 10 , pady = 10 ) self . repeat_button = ttk . Button ( self , text = \"Erneut wiedergeben\" , command = self . repeat_frequency , width = button_width , state = tk . DISABLED ) self . repeat_button . pack ( padx = 10 , pady = 10 ) self . stop_button = ttk . Button ( self , text = \"Wiedergabe stoppen\" , command = self . stop_playing , width = button_width , state = tk . DISABLED ) self . stop_button . pack ( padx = 10 , pady = 10 ) self . back_button = ttk . Button ( self , text = \"Zur\u00fcck zum Hauptmen\u00fc\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) # TODO Kalibrierung resetten, damit man sie dann wieder von vorne anfangen kann self . back_button . pack ( padx = 10 , pady = 20 ) self . spacer_frame = tk . Frame ( self , width = 20 , height = 80 ) self . spacer_frame . pack () self . current_freq_var = tk . StringVar ( value = \"Aktuelle Frequenz:\" ) self . current_freq = ttk . Label ( self , textvariable = self . current_freq_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . current_freq . pack ( padx = 10 , pady = 10 ) self . level_expected_var = tk . StringVar ( value = \"Schalldruckpegel (soll):\" ) self . level_expected_label = ttk . Label ( self , textvariable = self . level_expected_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_expected_label . pack ( padx = 10 , pady = 10 ) self . level_measured_label = ttk . Label ( self , text = \"Gemessener Schalldruckpegel in dB:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_measured_label . pack ( padx = 10 , pady = 10 ) self . level_measured_var = tk . StringVar () self . level_measured_entry = ttk . Entry ( self , width = button_width - 10 , font = ( FONT_FAMILY , SUBHEADER_SIZE ), state = tk . DISABLED , textvariable = self . level_measured_var ) self . level_measured_entry . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) next_frequency \u00b6 next_frequency () Sets previously entered level, then get next frequency and play it. Source code in app\\ui.py 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 def next_frequency ( self ): \"\"\"Sets previously entered level, then get next frequency and play it. \"\"\" try : if self . level_measured_var . get () != \"\" : self . cal_setlevel ( float ( self . level_measured_var . get ())) else : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei \"gemessener Schalldruckpegel\" eine Zahl ein.' ) return except ValueError : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei \"gemessener Schalldruck\" eine Zahl ein.' ) return self . level_measured_var . set ( \"\" ) more_freqs , current_freq , current_spl = self . cal_next () # Change Button when last frequency if not more_freqs : # Grey out all buttons when finished if self . finished : self . next_button . config ( state = tk . DISABLED ) self . repeat_button . config ( state = tk . DISABLED ) self . stop_button . config ( state = tk . DISABLED ) self . level_measured_entry . config ( state = tk . DISABLED ) messagebox . showwarning ( \"Kalibrierung abgeschlossen.\" , \"Die Kalibrierung wurde erfolgreich abgeschlossen. Datei gespeichert als calibration.csv\" ) return self . next_button . config ( text = \"Kalibrierung abschlie\u00dfen\" ) self . finished = True self . current_freq_var . set ( \"Aktuelle Frequenz: \" + str ( current_freq ) + \" Hz\" ) self . level_expected_var . set ( \"Schalldruckpegel (soll): \" + str ( current_spl ) + \" dB\" ) repeat_frequency \u00b6 repeat_frequency () Replays the same frequency. Source code in app\\ui.py 786 787 788 789 def repeat_frequency ( self ): \"\"\"Replays the same frequency.\"\"\" self . cal_repeat () start_calibration \u00b6 start_calibration () Starts the calibration process and change state of buttons. Source code in app\\ui.py 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 def start_calibration ( self ): \"\"\"Starts the calibration process and change state of buttons. \"\"\" try : current_freq , current_spl = self . cal_start ( float ( self . level_entry_var . get ())) except : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie eine Zahl ein.' ) return self . start_button . config ( state = tk . DISABLED ) self . next_button . config ( state = tk . NORMAL ) self . repeat_button . config ( state = tk . NORMAL ) self . stop_button . config ( state = tk . NORMAL ) self . level_measured_entry . config ( state = tk . NORMAL ) self . current_freq_var . set ( \"Aktuelle Frequenz: \" + str ( current_freq ) + \" Hz\" ) self . level_expected_var . set ( \"Schalldruckpegel (soll): \" + str ( current_spl ) + \" dB\" ) stop_playing \u00b6 stop_playing () Stops playing audio. Source code in app\\ui.py 791 792 793 794 def stop_playing ( self ): \"\"\"Stops playing audio.\"\"\" self . cal_stop () DuringFamiliarizationView \u00b6 Bases: Frame Source code in app\\ui.py 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 class DuringFamiliarizationView ( ttk . Frame ): def __init__ ( self , parent , familiarization_func , progress_func ): \"\"\"Creates View during familiarization process. Args: parent (App): parent application familiarization_func (function): function to be called for familiarization progress_func (function): function to get the progress of the current process \"\"\" super () . __init__ ( parent ) self . parent = parent self . program = familiarization_func self . get_progress = progress_func self . text = \"Eingew\u00f6hnung l\u00e4uft...\" self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the view. \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 ) __init__ \u00b6 __init__ ( parent , familiarization_func , progress_func ) Creates View during familiarization process. Parameters: parent ( App ) \u2013 parent application familiarization_func ( function ) \u2013 function to be called for familiarization progress_func ( function ) \u2013 function to get the progress of the current process Source code in app\\ui.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def __init__ ( self , parent , familiarization_func , progress_func ): \"\"\"Creates View during familiarization process. Args: parent (App): parent application familiarization_func (function): function to be called for familiarization progress_func (function): function to get the progress of the current process \"\"\" super () . __init__ ( parent ) self . parent = parent self . program = familiarization_func self . get_progress = progress_func self . text = \"Eingew\u00f6hnung l\u00e4uft...\" self . create_widgets () create_widgets \u00b6 create_widgets () Creates the widgets for the view. Source code in app\\ui.py 549 550 551 552 553 554 555 556 def create_widgets ( self ): \"\"\"Creates the widgets for the view. \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 ) DuringProcedureView \u00b6 Bases: Frame Source code in app\\ui.py 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 class DuringProcedureView ( ttk . Frame ): def __init__ ( self , parent , program_func , progress_func , text ): \"\"\"Creates View during main program. Args: parent (App): parent application program_func (function): function to be called for the main program progress_func (function): function to get the progress of the current process text (str): text to be displayed \"\"\" super () . __init__ ( parent ) self . parent = parent self . program = program_func self . get_progress = progress_func self . text = text self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the view. \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 ) __init__ \u00b6 __init__ ( parent , program_func , progress_func , text ) Creates View during main program. Parameters: parent ( App ) \u2013 parent application program_func ( function ) \u2013 function to be called for the main program progress_func ( function ) \u2013 function to get the progress of the current process text ( str ) \u2013 text to be displayed Source code in app\\ui.py 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 def __init__ ( self , parent , program_func , progress_func , text ): \"\"\"Creates View during main program. Args: parent (App): parent application program_func (function): function to be called for the main program progress_func (function): function to get the progress of the current process text (str): text to be displayed \"\"\" super () . __init__ ( parent ) self . parent = parent self . program = program_func self . get_progress = progress_func self . text = text self . create_widgets () create_widgets \u00b6 create_widgets () Creates the widgets for the view. Source code in app\\ui.py 577 578 579 580 581 582 583 584 def create_widgets ( self ): \"\"\"Creates the widgets for the view. \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 ) FamiliarizationPage \u00b6 Bases: Frame Source code in app\\ui.py 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 class FamiliarizationPage ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Creates Page for starting the familiarization process. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" button_width = 25 self . label = ttk . Label ( self , text = text_Familiarization , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . label . pack ( padx = 10 , pady = 10 ) self . play_button = ttk . Button ( self , text = \"Starte Eingew\u00f6hnung\" , command = self . run_familiarization , width = button_width ) self . play_button . pack ( padx = 10 , pady = 10 ) self . go_back_button = ttk . Button ( self , text = \"zur\u00fcck\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) self . go_back_button . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) def run_familiarization ( self ): \"\"\"Runs the familiarization process and goes to the next page. \"\"\" self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( DuringFamiliarizationView ) gender = self . parent . frames [ MainMenu ] . gender_dropdown . get () if gender == \"Geschlecht...\" or gender == \"Keine Angabe\" : gender = \"\" age = self . parent . frames [ MainMenu ] . age_entry . get () self . parent . wait_for_process ( lambda : self . parent . frames [ DuringFamiliarizationView ] . program ( id = self . parent . frames [ MainMenu ] . proband_number , calibrate = self . use_calibration , gender = gender , age = age ), lambda : self . parent . show_frame ( ProgramPage )) time . sleep ( 0.001 ) self . update () counter = 3000 # set a high value so that progress bar is updated once at the beginning sleep_time = random . uniform ( 0.1 , 0.5 ) # random time in seconds between 0.1 and 0.5 to update progress bar while self . parent . frames [ DuringFamiliarizationView ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ DuringFamiliarizationView ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ DuringFamiliarizationView ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False __init__ \u00b6 __init__ ( parent ) Creates Page for starting the familiarization process. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 404 405 406 407 408 409 410 411 412 def __init__ ( self , parent ): \"\"\"Creates Page for starting the familiarization process. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets () create_widgets \u00b6 create_widgets () Creates the widgets for the page. Source code in app\\ui.py 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" button_width = 25 self . label = ttk . Label ( self , text = text_Familiarization , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . label . pack ( padx = 10 , pady = 10 ) self . play_button = ttk . Button ( self , text = \"Starte Eingew\u00f6hnung\" , command = self . run_familiarization , width = button_width ) self . play_button . pack ( padx = 10 , pady = 10 ) self . go_back_button = ttk . Button ( self , text = \"zur\u00fcck\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) self . go_back_button . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) run_familiarization \u00b6 run_familiarization () Runs the familiarization process and goes to the next page. Source code in app\\ui.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 def run_familiarization ( self ): \"\"\"Runs the familiarization process and goes to the next page. \"\"\" self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( DuringFamiliarizationView ) gender = self . parent . frames [ MainMenu ] . gender_dropdown . get () if gender == \"Geschlecht...\" or gender == \"Keine Angabe\" : gender = \"\" age = self . parent . frames [ MainMenu ] . age_entry . get () self . parent . wait_for_process ( lambda : self . parent . frames [ DuringFamiliarizationView ] . program ( id = self . parent . frames [ MainMenu ] . proband_number , calibrate = self . use_calibration , gender = gender , age = age ), lambda : self . parent . show_frame ( ProgramPage )) time . sleep ( 0.001 ) self . update () counter = 3000 # set a high value so that progress bar is updated once at the beginning sleep_time = random . uniform ( 0.1 , 0.5 ) # random time in seconds between 0.1 and 0.5 to update progress bar while self . parent . frames [ DuringFamiliarizationView ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ DuringFamiliarizationView ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ DuringFamiliarizationView ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False MainMenu \u00b6 Bases: Frame Source code in app\\ui.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 class MainMenu ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Creates the Main menu page. \"\"\" super () . __init__ ( parent ) self . parent = parent self . button_width = 25 self . start_button = None self . binaural_test = tk . BooleanVar () self . use_calibration = tk . BooleanVar ( value = True ) self . selected_option = None self . proband_number = \"\" self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" self . proband_number_label = ttk . Label ( self , text = \"Probandennummer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . proband_number_label . pack ( padx = 10 , pady = 10 ) self . proband_number_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . proband_number_entry . pack ( padx = 10 , pady = 10 ) self . gender_label = ttk . Label ( self , text = \"Geschlecht (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . gender_label . pack ( padx = 10 , pady = 10 ) self . gender_dropdown = ttk . Combobox ( self , values = [ \"M\u00e4nnlich\" , \"Weiblich\" , \"Divers\" , \"Keine Angabe\" ], state = \"readonly\" , width = self . button_width - 1 ) self . gender_dropdown . set ( \"Geschlecht...\" ) self . gender_dropdown . pack ( padx = 10 , pady = 10 ) self . age_label = ttk . Label ( self , text = \"Alter (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . age_label . pack ( padx = 10 , pady = 10 ) self . age_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . age_entry . pack ( padx = 10 , pady = 10 ) self . label = ttk . Label ( self , text = \" \\n Bitte w\u00e4hlen Sie ein Programm\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . label . pack ( pady = 10 ) # Dropdown menu options = list ( self . parent . program_funcs . keys ()) self . dropdown = ttk . Combobox ( self , values = options , state = \"readonly\" , width = self . button_width - 1 ) self . dropdown . set ( \"Test w\u00e4hlen...\" ) self . dropdown . pack ( pady = 10 ) self . dropdown . bind ( \"<<ComboboxSelected>>\" , self . on_option_selected ) self . binaural_button = ttk . Checkbutton ( self , text = \"Binaurale Testung\" , variable = self . binaural_test ) self . binaural_button . pack ( pady = 10 ) # Use calibration button self . cal_button = ttk . Checkbutton ( self , text = \"Werte aus letzter Kalibrierung verwenden\" , variable = self . use_calibration ) self . cal_button . pack ( pady = 10 , side = \"bottom\" ) # Headphone selection self . headphone_dropdown = ttk . Combobox ( self , values = self . get_headphone_options (), state = \"readonly\" , width = self . button_width - 1 ) self . headphone_dropdown . set ( \"Sennheiser_HDA200\" ) self . headphone_dropdown . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) self . headphone_label = ttk . Label ( self , text = \"Kopfh\u00f6rer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . headphone_label . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) def get_headphone_options ( self ): \"\"\"Reads all possible headphone models from retspl.csv file. Returns: list of str: all headphone models listed in retspl.csv \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): messagebox . showwarning ( \"Warnung\" , f 'Die Datei \" { file_name } \" konnte nicht gefunden werden.' ) return headphone_options = [] try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : headphone_options . append ( row [ 'headphone_model' ]) headphone_options = list ( set ( headphone_options )) return headphone_options except Exception as e : messagebox . showwarning ( \"Warnung\" , f 'Fehler beim Lesen der Datei \" { file_name } \": { e } ' ) return def on_option_selected ( self , event ): \"\"\"Changes state of buttons and show start button depending on procedure selected. \"\"\" self . selected_option = self . dropdown . get () self . show_start_button () if self . selected_option == \"Kalibrierung\" : self . cal_button . config ( state = tk . DISABLED ) self . binaural_button . config ( state = tk . DISABLED ) self . gender_dropdown . config ( state = tk . DISABLED ) self . proband_number_entry . config ( state = tk . DISABLED ) else : self . cal_button . config ( state = tk . NORMAL ) self . binaural_button . config ( state = tk . NORMAL ) self . gender_dropdown . config ( state = tk . NORMAL ) self . proband_number_entry . config ( state = tk . NORMAL ) def show_start_button ( self ): \"\"\"Shows start button if not already visible. \"\"\" if self . start_button is None : self . start_button = ttk . Button ( self , text = \"Test starten\" , command = self . go_to_next_page , width = self . button_width ) self . start_button . pack ( pady = 10 ) def go_to_next_page ( self ): \"\"\"Go to next page depending on selected options. \"\"\" if self . selected_option == \"Kalibrierung\" : self . parent . show_frame ( CalibrationPage ) else : self . proband_number = self . proband_number_entry . get () if not self . proband_number : messagebox . showwarning ( \"Warnung\" , \"Bitte geben Sie eine Probandennummer ein.\" ) return # check if valide age is entered if self . age_entry . get (): try : i = int ( self . age_entry . get ()) if i > 110 or i < 0 : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei Alter eine g\u00fcltige Zahl oder gar nichts ein.' ) return except : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei Alter eine g\u00fcltige Zahl oder gar nichts ein.' ) return proband_folder = os . path . join ( self . parent . save_path , self . proband_number ) pics = self . parent . get_images_in_path ( proband_folder ) if pics : if messagebox . askyesno ( \"Proband vorhanden\" , \"F\u00fcr diese Probandennummer gibt es bereits Ergebnisse. M\u00f6chten Sie diese anzeigen?\" ): results_page = self . parent . frames [ ResultPage ] results_page . display_images ( self . proband_number ) self . parent . show_frame ( ResultPage ) return self . parent . show_frame ( FamiliarizationPage ) __init__ \u00b6 __init__ ( parent ) Creates the Main menu page. Source code in app\\ui.py 254 255 256 257 258 259 260 261 262 263 264 265 def __init__ ( self , parent ): \"\"\"Creates the Main menu page. \"\"\" super () . __init__ ( parent ) self . parent = parent self . button_width = 25 self . start_button = None self . binaural_test = tk . BooleanVar () self . use_calibration = tk . BooleanVar ( value = True ) self . selected_option = None self . proband_number = \"\" self . create_widgets () create_widgets \u00b6 create_widgets () Creates the widgets for the page. Source code in app\\ui.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" self . proband_number_label = ttk . Label ( self , text = \"Probandennummer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . proband_number_label . pack ( padx = 10 , pady = 10 ) self . proband_number_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . proband_number_entry . pack ( padx = 10 , pady = 10 ) self . gender_label = ttk . Label ( self , text = \"Geschlecht (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . gender_label . pack ( padx = 10 , pady = 10 ) self . gender_dropdown = ttk . Combobox ( self , values = [ \"M\u00e4nnlich\" , \"Weiblich\" , \"Divers\" , \"Keine Angabe\" ], state = \"readonly\" , width = self . button_width - 1 ) self . gender_dropdown . set ( \"Geschlecht...\" ) self . gender_dropdown . pack ( padx = 10 , pady = 10 ) self . age_label = ttk . Label ( self , text = \"Alter (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . age_label . pack ( padx = 10 , pady = 10 ) self . age_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . age_entry . pack ( padx = 10 , pady = 10 ) self . label = ttk . Label ( self , text = \" \\n Bitte w\u00e4hlen Sie ein Programm\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . label . pack ( pady = 10 ) # Dropdown menu options = list ( self . parent . program_funcs . keys ()) self . dropdown = ttk . Combobox ( self , values = options , state = \"readonly\" , width = self . button_width - 1 ) self . dropdown . set ( \"Test w\u00e4hlen...\" ) self . dropdown . pack ( pady = 10 ) self . dropdown . bind ( \"<<ComboboxSelected>>\" , self . on_option_selected ) self . binaural_button = ttk . Checkbutton ( self , text = \"Binaurale Testung\" , variable = self . binaural_test ) self . binaural_button . pack ( pady = 10 ) # Use calibration button self . cal_button = ttk . Checkbutton ( self , text = \"Werte aus letzter Kalibrierung verwenden\" , variable = self . use_calibration ) self . cal_button . pack ( pady = 10 , side = \"bottom\" ) # Headphone selection self . headphone_dropdown = ttk . Combobox ( self , values = self . get_headphone_options (), state = \"readonly\" , width = self . button_width - 1 ) self . headphone_dropdown . set ( \"Sennheiser_HDA200\" ) self . headphone_dropdown . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) self . headphone_label = ttk . Label ( self , text = \"Kopfh\u00f6rer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . headphone_label . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) get_headphone_options \u00b6 get_headphone_options () Reads all possible headphone models from retspl.csv file. Returns: \u2013 list of str: all headphone models listed in retspl.csv Source code in app\\ui.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def get_headphone_options ( self ): \"\"\"Reads all possible headphone models from retspl.csv file. Returns: list of str: all headphone models listed in retspl.csv \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): messagebox . showwarning ( \"Warnung\" , f 'Die Datei \" { file_name } \" konnte nicht gefunden werden.' ) return headphone_options = [] try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : headphone_options . append ( row [ 'headphone_model' ]) headphone_options = list ( set ( headphone_options )) return headphone_options except Exception as e : messagebox . showwarning ( \"Warnung\" , f 'Fehler beim Lesen der Datei \" { file_name } \": { e } ' ) return go_to_next_page \u00b6 go_to_next_page () Go to next page depending on selected options. Source code in app\\ui.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def go_to_next_page ( self ): \"\"\"Go to next page depending on selected options. \"\"\" if self . selected_option == \"Kalibrierung\" : self . parent . show_frame ( CalibrationPage ) else : self . proband_number = self . proband_number_entry . get () if not self . proband_number : messagebox . showwarning ( \"Warnung\" , \"Bitte geben Sie eine Probandennummer ein.\" ) return # check if valide age is entered if self . age_entry . get (): try : i = int ( self . age_entry . get ()) if i > 110 or i < 0 : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei Alter eine g\u00fcltige Zahl oder gar nichts ein.' ) return except : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei Alter eine g\u00fcltige Zahl oder gar nichts ein.' ) return proband_folder = os . path . join ( self . parent . save_path , self . proband_number ) pics = self . parent . get_images_in_path ( proband_folder ) if pics : if messagebox . askyesno ( \"Proband vorhanden\" , \"F\u00fcr diese Probandennummer gibt es bereits Ergebnisse. M\u00f6chten Sie diese anzeigen?\" ): results_page = self . parent . frames [ ResultPage ] results_page . display_images ( self . proband_number ) self . parent . show_frame ( ResultPage ) return self . parent . show_frame ( FamiliarizationPage ) on_option_selected \u00b6 on_option_selected ( event ) Changes state of buttons and show start button depending on procedure selected. Source code in app\\ui.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 def on_option_selected ( self , event ): \"\"\"Changes state of buttons and show start button depending on procedure selected. \"\"\" self . selected_option = self . dropdown . get () self . show_start_button () if self . selected_option == \"Kalibrierung\" : self . cal_button . config ( state = tk . DISABLED ) self . binaural_button . config ( state = tk . DISABLED ) self . gender_dropdown . config ( state = tk . DISABLED ) self . proband_number_entry . config ( state = tk . DISABLED ) else : self . cal_button . config ( state = tk . NORMAL ) self . binaural_button . config ( state = tk . NORMAL ) self . gender_dropdown . config ( state = tk . NORMAL ) self . proband_number_entry . config ( state = tk . NORMAL ) show_start_button \u00b6 show_start_button () Shows start button if not already visible. Source code in app\\ui.py 356 357 358 359 360 361 362 363 364 def show_start_button ( self ): \"\"\"Shows start button if not already visible. \"\"\" if self . start_button is None : self . start_button = ttk . Button ( self , text = \"Test starten\" , command = self . go_to_next_page , width = self . button_width ) self . start_button . pack ( pady = 10 ) ProgramPage \u00b6 Bases: Frame Source code in app\\ui.py 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 class ProgramPage ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Creates Page for starting the main program. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . selected_option = None self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" self . start_button = ttk . Button ( self , text = \"Starte Prozess\" , command = self . run_program ) self . start_button . pack ( padx = 10 , pady = 200 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) def run_program ( self ): \"\"\"Runs the main program. \"\"\" self . selected_option = self . parent . frames [ MainMenu ] . selected_option self . binaural_test = self . parent . frames [ MainMenu ] . binaural_test . get () self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( self . selected_option ) self . parent . wait_for_process ( lambda : self . parent . frames [ self . selected_option ] . program ( self . binaural_test , calibrate = self . use_calibration ), self . show_results ) time . sleep ( 0.001 ) self . update () counter = 3000 # set a high value so that progress bar is updated once at the beginning sleep_time = random . uniform ( 1 , 2.5 ) # random time in seconds between 1 and 2.5 to update progress bar while self . parent . frames [ self . selected_option ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ self . selected_option ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ self . selected_option ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False def show_results ( self ): \"\"\"Shows the results page with (all) images. \"\"\" proband_number = self . parent . frames [ MainMenu ] . proband_number results_page = self . parent . frames [ ResultPage ] results_page . display_images ( proband_number ) self . parent . show_frame ( ResultPage ) __init__ \u00b6 __init__ ( parent ) Creates Page for starting the main program. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 473 474 475 476 477 478 479 480 481 482 def __init__ ( self , parent ): \"\"\"Creates Page for starting the main program. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . selected_option = None self . create_widgets () create_widgets \u00b6 create_widgets () Creates the widgets for the page. Source code in app\\ui.py 484 485 486 487 488 489 490 491 def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" self . start_button = ttk . Button ( self , text = \"Starte Prozess\" , command = self . run_program ) self . start_button . pack ( padx = 10 , pady = 200 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) run_program \u00b6 run_program () Runs the main program. Source code in app\\ui.py 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 def run_program ( self ): \"\"\"Runs the main program. \"\"\" self . selected_option = self . parent . frames [ MainMenu ] . selected_option self . binaural_test = self . parent . frames [ MainMenu ] . binaural_test . get () self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( self . selected_option ) self . parent . wait_for_process ( lambda : self . parent . frames [ self . selected_option ] . program ( self . binaural_test , calibrate = self . use_calibration ), self . show_results ) time . sleep ( 0.001 ) self . update () counter = 3000 # set a high value so that progress bar is updated once at the beginning sleep_time = random . uniform ( 1 , 2.5 ) # random time in seconds between 1 and 2.5 to update progress bar while self . parent . frames [ self . selected_option ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ self . selected_option ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ self . selected_option ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False show_results \u00b6 show_results () Shows the results page with (all) images. Source code in app\\ui.py 521 522 523 524 525 526 527 def show_results ( self ): \"\"\"Shows the results page with (all) images. \"\"\" proband_number = self . parent . frames [ MainMenu ] . proband_number results_page = self . parent . frames [ ResultPage ] results_page . display_images ( proband_number ) self . parent . show_frame ( ResultPage ) ResultPage \u00b6 Bases: Frame Source code in app\\ui.py 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 class ResultPage ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Creates Page for showing the results of the program. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the view. \"\"\" self . info = ttk . Label ( self , text = \"Ergebnisse\" , font = ( FONT_FAMILY , HEADER_SIZE )) self . info . pack ( padx = 10 , pady = 10 ) # Set the title on the parent window self . parent . title ( \"Audiogramm\" ) # Create a frame for the images self . image_frame = ttk . Frame ( self ) self . image_frame . pack ( anchor = \"center\" ) #,fill=\"both\", expand=True) # Button to go back to the main menu self . BackToMainMenu = ttk . Button ( self , text = \"Zur\u00fcck zur Startseite\" , command = lambda : self . parent . show_frame ( MainMenu )) self . BackToMainMenu . pack ( padx = 10 , pady = 10 ) def display_images ( self , folder_name ): \"\"\"Display all images in the given folder. Args: folder_name (str): name of the folder containing the images \"\"\" folder_path = os . path . join ( self . parent . save_path , folder_name ) for widget in self . image_frame . winfo_children (): widget . destroy () pics = self . parent . get_images_in_path ( folder_path ) if pics : for file in pics : img = Image . open ( file ) photo = ImageTk . PhotoImage ( img ) label = ttk . Label ( self . image_frame , image = photo ) label . image = photo label . pack ( padx = 10 , pady = 10 , side = \"left\" ) def back_to_MainMenu ( self ): \"\"\"Goes back to main menu. \"\"\" self . parent . show_frame ( MainMenu ) __init__ \u00b6 __init__ ( parent ) Creates Page for showing the results of the program. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 589 590 591 592 593 594 595 596 597 598 def __init__ ( self , parent ): \"\"\"Creates Page for showing the results of the program. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets () back_to_MainMenu \u00b6 back_to_MainMenu () Goes back to main menu. Source code in app\\ui.py 637 638 639 640 def back_to_MainMenu ( self ): \"\"\"Goes back to main menu. \"\"\" self . parent . show_frame ( MainMenu ) create_widgets \u00b6 create_widgets () Creates the widgets for the view. Source code in app\\ui.py 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 def create_widgets ( self ): \"\"\"Creates the widgets for the view. \"\"\" self . info = ttk . Label ( self , text = \"Ergebnisse\" , font = ( FONT_FAMILY , HEADER_SIZE )) self . info . pack ( padx = 10 , pady = 10 ) # Set the title on the parent window self . parent . title ( \"Audiogramm\" ) # Create a frame for the images self . image_frame = ttk . Frame ( self ) self . image_frame . pack ( anchor = \"center\" ) #,fill=\"both\", expand=True) # Button to go back to the main menu self . BackToMainMenu = ttk . Button ( self , text = \"Zur\u00fcck zur Startseite\" , command = lambda : self . parent . show_frame ( MainMenu )) self . BackToMainMenu . pack ( padx = 10 , pady = 10 ) display_images \u00b6 display_images ( folder_name ) Display all images in the given folder. Parameters: folder_name ( str ) \u2013 name of the folder containing the images Source code in app\\ui.py 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 def display_images ( self , folder_name ): \"\"\"Display all images in the given folder. Args: folder_name (str): name of the folder containing the images \"\"\" folder_path = os . path . join ( self . parent . save_path , folder_name ) for widget in self . image_frame . winfo_children (): widget . destroy () pics = self . parent . get_images_in_path ( folder_path ) if pics : for file in pics : img = Image . open ( file ) photo = ImageTk . PhotoImage ( img ) label = ttk . Label ( self . image_frame , image = photo ) label . image = photo label . pack ( padx = 10 , pady = 10 , side = \"left\" ) setup_ui \u00b6 setup_ui ( startfunc , programfuncs , calibrationfuncs , progressfunc ) Creates tkinter app and return it. Parameters: startfunc ( function ) \u2013 function to be called for familiarization programfuncs ( dict of str ) \u2013 function): function(s) to be called for the main program calibrationfuncs ( list function ) \u2013 list of function(s) for calibration in this order: start, next, repeat, stop, set_level progressfunc ( function ) \u2013 function to get the progress of the current process Source code in app\\ui.py 796 797 798 799 800 801 802 803 804 805 806 807 def setup_ui ( startfunc , programfuncs , calibrationfuncs , progressfunc ): \"\"\" Creates tkinter app and return it. Args: startfunc (function): function to be called for familiarization programfuncs (dict of str:function): function(s) to be called for the main program calibrationfuncs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level progressfunc (function): function to get the progress of the current process \"\"\" app = App ( startfunc , programfuncs , calibrationfuncs , progressfunc ) return app","title":"ui"},{"location":"api/ui/#ui-module","text":"This module contains the UI classes for the Audiometer application. The UI is built using the tkinter library.","title":"ui Module"},{"location":"api/ui/#app.ui.App","text":"Bases: Window Source code in app\\ui.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 class App ( tb . Window ): def __init__ ( self , familiarization_func : callable , program_funcs : dict , calibration_funcs : list , progress_func : callable ): \"\"\"Creats Main application window. Contains all pages and controls the flow of the program. Args: familiarization_func (function): function to be called for familiarization audiogram_func (function): function to be called for creating audiogram program_funcs (dict of str:function): function(s) to be called for the main program calibration_funcs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level \"\"\" themename = self . get_theme () super () . __init__ ( themename = themename ) # General theme settings self . title ( \"Sound Player\" ) self . geometry ( GEOMETRY ) self . minsize ( 650 , 650 ) self . attributes ( '-fullscreen' , True ) self . bind ( \"<Escape>\" , self . exit_fullscreen ) self . save_path = os . path . join ( os . getcwd ()) # Ensure the default save path exists os . makedirs ( self . save_path , exist_ok = True ) self . set_icon ( \"Logo_NBG.png\" ) #change the icon maybe? #TODO self . tk . call ( 'tk' , 'scaling' , 2.0 ) # Adjust for high-DPI displays # Dictionary to store all pages self . program_funcs = program_funcs self . frames = {} self . binaural_test = False # Interactive Pages for F in ( MainMenu , FamiliarizationPage , ProgramPage , ResultPage ): frame = F ( self ) self . frames [ F ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Calibration separately to give it its functions frame = CalibrationPage ( self , calibration_funcs ) self . frames [ CalibrationPage ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during familiarization frame = DuringFamiliarizationView ( self , familiarization_func , progress_func ) self . frames [ DuringFamiliarizationView ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during programs for name , program_func in program_funcs . items (): frame = DuringProcedureView ( self , program_func , progress_func , text = \"Programm l\u00e4uft...\" ) self . frames [ name ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Show MainMenu first self . show_frame ( MainMenu ) # Create menubar self . create_menubar () # Variable for threading self . process_done = False # Override the close button protocol self . protocol ( \"WM_DELETE_WINDOW\" , self . on_closing ) self . grid_rowconfigure ( 0 , weight = 1 ) self . grid_columnconfigure ( 0 , weight = 1 ) def create_menubar ( self ): \"\"\"Creates a menubar with options for changing the theme and exiting the program. \"\"\" menubar = tk . Menu ( self ) self . config ( menu = menubar ) file_menu = tk . Menu ( menubar , tearoff = 0 ) file_menu . add_command ( label = \"Startseite\" , command = lambda : self . show_frame ( MainMenu )) file_menu . add_command ( label = \"Speicherort \u00e4ndern\" , command = self . change_save_path ) ChangeTheme = tk . Menu ( file_menu , tearoff = 0 ) ChangeTheme . add_command ( label = \"light\" , command = lambda : self . change_theme ( LIGHT_THEME )) ChangeTheme . add_command ( label = \"dark\" , command = lambda : self . change_theme ( DARK_THEME )) file_menu . add_cascade ( label = \"Theme \u00e4ndern\" , menu = ChangeTheme ) file_menu . add_separator () file_menu . add_command ( label = \"Programm beenden\" , command = self . on_closing ) menubar . add_cascade ( label = \"Einstellungen\" , menu = file_menu ) def change_theme ( self , theme_name : str ): \"\"\"Changes to the specified theme. Args: theme_name (str): name of the theme to change \"\"\" current_theme = self . style . theme_use () if current_theme == theme_name : messagebox . showwarning ( \"Oops..\" , \"Dieses Theme wird bereits verwendet.\" ) else : self . style . theme_use ( theme_name ) # change in settings.csv file filename = \"settings.csv\" fieldnames = [ 'file path' , 'theme' ] # Read all rows from the settings.csv file with open ( filename , mode = 'r' , newline = '' ) as file : dict_reader = csv . DictReader ( file ) rows = list ( dict_reader ) # Update the relevant row rows [ 0 ][ 'theme' ] = theme_name # Write all rows back to the CSV file with open ( filename , mode = 'w' , newline = '' ) as file : dict_writer = csv . DictWriter ( file , fieldnames = fieldnames ) dict_writer . writeheader () dict_writer . writerows ( rows ) def get_theme ( self ): \"\"\"Gets currently selected theme from settings.csv file. Returns: str: name of light theme or name of dark theme \"\"\" file_name = \"settings.csv\" with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) settings = next ( reader ) if settings [ 'theme' ] == LIGHT_THEME : return LIGHT_THEME elif settings [ 'theme' ] == DARK_THEME : return DARK_THEME else : return LIGHT_THEME def exit_fullscreen ( self , event = None ): \"\"\"Exits fullscreen mode. \"\"\" self . attributes ( '-fullscreen' , False ) def set_icon ( self , path ): \"\"\"Sets the window icon using Pillow. \"\"\" img = Image . open ( path ) photo = ImageTk . PhotoImage ( img ) self . iconphoto ( False , photo ) def show_frame ( self , page ): \"\"\"Shows frame for the given page name. Args: page(class): class of the page to be shown \"\"\" frame = self . frames [ page ] frame . tkraise () def wait_for_process ( self , process , callback ): \"\"\"Starts a process in a new thread and calls a callback function when the process is done. Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" t = threading . Thread ( target = self . run_process , args = ( process , callback )) t . daemon = True t . start () def run_process ( self , process , callback ): \"\"\"Runs a process and calls a callback function when the process is done. Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" process () self . process_done = True self . after ( 100 , callback ) def change_save_path ( self ): \"\"\"Asks the user to select a folder to save the files. Changes settings.csv file accordingly. \"\"\" new_path = filedialog . askdirectory ( title = \"Select Folder to Save Files\" ) if new_path : # change in settings.csv file filename = \"settings.csv\" fieldnames = [ 'file path' , 'theme' ] # Read all rows from the settings.csv file with open ( filename , mode = 'r' , newline = '' ) as file : dict_reader = csv . DictReader ( file ) rows = list ( dict_reader ) # Update the relevant row rows [ 0 ][ 'file path' ] = new_path # Write all rows back to the CSV file with open ( filename , mode = 'w' , newline = '' ) as file : dict_writer = csv . DictWriter ( file , fieldnames = fieldnames ) dict_writer . writeheader () dict_writer . writerows ( rows ) self . save_path = new_path messagebox . showinfo ( \"Speicherort ge\u00e4ndert\" , f \"Neuer Speicherort: { self . save_path } \" ) def on_closing ( self ): \"\"\"Asks for confirmation before closing the program. \"\"\" if messagebox . askyesno ( title = \"Quit\" , message = \"M\u00f6chten Sie wirklich das Programm beenden?\" ): self . destroy () def get_images_in_path ( self , directory , image_extensions = [ \".png\" , \".jpg\" , \".jpeg\" , \".gif\" , \".bmp\" ]): \"\"\"Gets a list of image files in the specified directory. Args: directory (str): The path to the directory to check. image_extensions (list): List of image file extensions to check for. Returns: list: List of image file paths if any image files are found, False otherwise. \"\"\" if not os . path . exists ( directory ): return False image_files = [ os . path . join ( directory , file ) for file in os . listdir ( directory ) if any ( file . lower () . endswith ( ext ) for ext in image_extensions )] return image_files if image_files else False","title":"App"},{"location":"api/ui/#app.ui.App.__init__","text":"__init__ ( familiarization_func , program_funcs , calibration_funcs , progress_func ) Creats Main application window. Contains all pages and controls the flow of the program. Parameters: familiarization_func ( function ) \u2013 function to be called for familiarization audiogram_func ( function ) \u2013 function to be called for creating audiogram program_funcs ( dict of str ) \u2013 function): function(s) to be called for the main program calibration_funcs ( list function ) \u2013 list of function(s) for calibration in this order: start, next, repeat, stop, set_level Source code in app\\ui.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def __init__ ( self , familiarization_func : callable , program_funcs : dict , calibration_funcs : list , progress_func : callable ): \"\"\"Creats Main application window. Contains all pages and controls the flow of the program. Args: familiarization_func (function): function to be called for familiarization audiogram_func (function): function to be called for creating audiogram program_funcs (dict of str:function): function(s) to be called for the main program calibration_funcs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level \"\"\" themename = self . get_theme () super () . __init__ ( themename = themename ) # General theme settings self . title ( \"Sound Player\" ) self . geometry ( GEOMETRY ) self . minsize ( 650 , 650 ) self . attributes ( '-fullscreen' , True ) self . bind ( \"<Escape>\" , self . exit_fullscreen ) self . save_path = os . path . join ( os . getcwd ()) # Ensure the default save path exists os . makedirs ( self . save_path , exist_ok = True ) self . set_icon ( \"Logo_NBG.png\" ) #change the icon maybe? #TODO self . tk . call ( 'tk' , 'scaling' , 2.0 ) # Adjust for high-DPI displays # Dictionary to store all pages self . program_funcs = program_funcs self . frames = {} self . binaural_test = False # Interactive Pages for F in ( MainMenu , FamiliarizationPage , ProgramPage , ResultPage ): frame = F ( self ) self . frames [ F ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Calibration separately to give it its functions frame = CalibrationPage ( self , calibration_funcs ) self . frames [ CalibrationPage ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during familiarization frame = DuringFamiliarizationView ( self , familiarization_func , progress_func ) self . frames [ DuringFamiliarizationView ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during programs for name , program_func in program_funcs . items (): frame = DuringProcedureView ( self , program_func , progress_func , text = \"Programm l\u00e4uft...\" ) self . frames [ name ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Show MainMenu first self . show_frame ( MainMenu ) # Create menubar self . create_menubar () # Variable for threading self . process_done = False # Override the close button protocol self . protocol ( \"WM_DELETE_WINDOW\" , self . on_closing ) self . grid_rowconfigure ( 0 , weight = 1 ) self . grid_columnconfigure ( 0 , weight = 1 )","title":"__init__"},{"location":"api/ui/#app.ui.App.change_save_path","text":"change_save_path () Asks the user to select a folder to save the files. Changes settings.csv file accordingly. Source code in app\\ui.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def change_save_path ( self ): \"\"\"Asks the user to select a folder to save the files. Changes settings.csv file accordingly. \"\"\" new_path = filedialog . askdirectory ( title = \"Select Folder to Save Files\" ) if new_path : # change in settings.csv file filename = \"settings.csv\" fieldnames = [ 'file path' , 'theme' ] # Read all rows from the settings.csv file with open ( filename , mode = 'r' , newline = '' ) as file : dict_reader = csv . DictReader ( file ) rows = list ( dict_reader ) # Update the relevant row rows [ 0 ][ 'file path' ] = new_path # Write all rows back to the CSV file with open ( filename , mode = 'w' , newline = '' ) as file : dict_writer = csv . DictWriter ( file , fieldnames = fieldnames ) dict_writer . writeheader () dict_writer . writerows ( rows ) self . save_path = new_path messagebox . showinfo ( \"Speicherort ge\u00e4ndert\" , f \"Neuer Speicherort: { self . save_path } \" )","title":"change_save_path"},{"location":"api/ui/#app.ui.App.change_theme","text":"change_theme ( theme_name ) Changes to the specified theme. Parameters: theme_name ( str ) \u2013 name of the theme to change Source code in app\\ui.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def change_theme ( self , theme_name : str ): \"\"\"Changes to the specified theme. Args: theme_name (str): name of the theme to change \"\"\" current_theme = self . style . theme_use () if current_theme == theme_name : messagebox . showwarning ( \"Oops..\" , \"Dieses Theme wird bereits verwendet.\" ) else : self . style . theme_use ( theme_name ) # change in settings.csv file filename = \"settings.csv\" fieldnames = [ 'file path' , 'theme' ] # Read all rows from the settings.csv file with open ( filename , mode = 'r' , newline = '' ) as file : dict_reader = csv . DictReader ( file ) rows = list ( dict_reader ) # Update the relevant row rows [ 0 ][ 'theme' ] = theme_name # Write all rows back to the CSV file with open ( filename , mode = 'w' , newline = '' ) as file : dict_writer = csv . DictWriter ( file , fieldnames = fieldnames ) dict_writer . writeheader () dict_writer . writerows ( rows )","title":"change_theme"},{"location":"api/ui/#app.ui.App.create_menubar","text":"create_menubar () Creates a menubar with options for changing the theme and exiting the program. Source code in app\\ui.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def create_menubar ( self ): \"\"\"Creates a menubar with options for changing the theme and exiting the program. \"\"\" menubar = tk . Menu ( self ) self . config ( menu = menubar ) file_menu = tk . Menu ( menubar , tearoff = 0 ) file_menu . add_command ( label = \"Startseite\" , command = lambda : self . show_frame ( MainMenu )) file_menu . add_command ( label = \"Speicherort \u00e4ndern\" , command = self . change_save_path ) ChangeTheme = tk . Menu ( file_menu , tearoff = 0 ) ChangeTheme . add_command ( label = \"light\" , command = lambda : self . change_theme ( LIGHT_THEME )) ChangeTheme . add_command ( label = \"dark\" , command = lambda : self . change_theme ( DARK_THEME )) file_menu . add_cascade ( label = \"Theme \u00e4ndern\" , menu = ChangeTheme ) file_menu . add_separator () file_menu . add_command ( label = \"Programm beenden\" , command = self . on_closing ) menubar . add_cascade ( label = \"Einstellungen\" , menu = file_menu )","title":"create_menubar"},{"location":"api/ui/#app.ui.App.exit_fullscreen","text":"exit_fullscreen ( event = None ) Exits fullscreen mode. Source code in app\\ui.py 158 159 160 161 def exit_fullscreen ( self , event = None ): \"\"\"Exits fullscreen mode. \"\"\" self . attributes ( '-fullscreen' , False )","title":"exit_fullscreen"},{"location":"api/ui/#app.ui.App.get_images_in_path","text":"get_images_in_path ( directory , image_extensions = [ '.png' , '.jpg' , '.jpeg' , '.gif' , '.bmp' ]) Gets a list of image files in the specified directory. Args: directory (str): The path to the directory to check. image_extensions (list): List of image file extensions to check for. Returns: list: List of image file paths if any image files are found, False otherwise. Source code in app\\ui.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def get_images_in_path ( self , directory , image_extensions = [ \".png\" , \".jpg\" , \".jpeg\" , \".gif\" , \".bmp\" ]): \"\"\"Gets a list of image files in the specified directory. Args: directory (str): The path to the directory to check. image_extensions (list): List of image file extensions to check for. Returns: list: List of image file paths if any image files are found, False otherwise. \"\"\" if not os . path . exists ( directory ): return False image_files = [ os . path . join ( directory , file ) for file in os . listdir ( directory ) if any ( file . lower () . endswith ( ext ) for ext in image_extensions )] return image_files if image_files else False","title":"get_images_in_path"},{"location":"api/ui/#app.ui.App.get_theme","text":"get_theme () Gets currently selected theme from settings.csv file. Returns: str \u2013 name of light theme or name of dark theme Source code in app\\ui.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def get_theme ( self ): \"\"\"Gets currently selected theme from settings.csv file. Returns: str: name of light theme or name of dark theme \"\"\" file_name = \"settings.csv\" with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) settings = next ( reader ) if settings [ 'theme' ] == LIGHT_THEME : return LIGHT_THEME elif settings [ 'theme' ] == DARK_THEME : return DARK_THEME else : return LIGHT_THEME","title":"get_theme"},{"location":"api/ui/#app.ui.App.on_closing","text":"on_closing () Asks for confirmation before closing the program. Source code in app\\ui.py 229 230 231 232 233 def on_closing ( self ): \"\"\"Asks for confirmation before closing the program. \"\"\" if messagebox . askyesno ( title = \"Quit\" , message = \"M\u00f6chten Sie wirklich das Programm beenden?\" ): self . destroy ()","title":"on_closing"},{"location":"api/ui/#app.ui.App.run_process","text":"run_process ( process , callback ) Runs a process and calls a callback function when the process is done. Parameters: process ( function ) \u2013 function to be called callback ( function ) \u2013 function to be called when process is done Source code in app\\ui.py 190 191 192 193 194 195 196 197 198 199 def run_process ( self , process , callback ): \"\"\"Runs a process and calls a callback function when the process is done. Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" process () self . process_done = True self . after ( 100 , callback )","title":"run_process"},{"location":"api/ui/#app.ui.App.set_icon","text":"set_icon ( path ) Sets the window icon using Pillow. Source code in app\\ui.py 163 164 165 166 167 168 def set_icon ( self , path ): \"\"\"Sets the window icon using Pillow. \"\"\" img = Image . open ( path ) photo = ImageTk . PhotoImage ( img ) self . iconphoto ( False , photo )","title":"set_icon"},{"location":"api/ui/#app.ui.App.show_frame","text":"show_frame ( page ) Shows frame for the given page name. Parameters: page(class) \u2013 class of the page to be shown Source code in app\\ui.py 170 171 172 173 174 175 176 177 def show_frame ( self , page ): \"\"\"Shows frame for the given page name. Args: page(class): class of the page to be shown \"\"\" frame = self . frames [ page ] frame . tkraise ()","title":"show_frame"},{"location":"api/ui/#app.ui.App.wait_for_process","text":"wait_for_process ( process , callback ) Starts a process in a new thread and calls a callback function when the process is done. Parameters: process ( function ) \u2013 function to be called callback ( function ) \u2013 function to be called when process is done Source code in app\\ui.py 179 180 181 182 183 184 185 186 187 188 def wait_for_process ( self , process , callback ): \"\"\"Starts a process in a new thread and calls a callback function when the process is done. Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" t = threading . Thread ( target = self . run_process , args = ( process , callback )) t . daemon = True t . start ()","title":"wait_for_process"},{"location":"api/ui/#app.ui.CalibrationPage","text":"Bases: Frame Source code in app\\ui.py 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 class CalibrationPage ( ttk . Frame ): def __init__ ( self , parent , calibration_funcs ): \"\"\"Creates Page for calibrating the audiometer. Args: parent (App): parent application calibration_funcs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level \"\"\" super () . __init__ ( parent ) self . parent = parent self . cal_start = calibration_funcs [ 0 ] self . cal_next = calibration_funcs [ 1 ] self . cal_repeat = calibration_funcs [ 2 ] self . cal_stop = calibration_funcs [ 3 ] self . cal_setlevel = calibration_funcs [ 4 ] self . create_widgets () self . finished = False def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" button_width = 25 self . intro = ttk . Label ( self , text = text_calibration , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . intro . pack ( padx = 10 , pady = 10 ) self . level_label = ttk . Label ( self , text = \"Wert in dBHL, bei dem kalibriert werden soll:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_label . pack ( padx = 10 , pady = 10 ) self . level_entry_var = tk . StringVar () self . level_entry_var . set ( \"10\" ) self . level_entry = ttk . Entry ( self , width = button_width - 10 , textvariable = self . level_entry_var ) self . level_entry . pack ( padx = 10 , pady = 10 ) self . start_button = ttk . Button ( self , text = \"Kalibrierung starten\" , command = self . start_calibration , width = button_width ) self . start_button . pack ( padx = 10 , pady = 10 ) self . next_button = ttk . Button ( self , text = \"N\u00e4chste Frequenz\" , command = self . next_frequency , width = button_width , state = tk . DISABLED ) self . next_button . pack ( padx = 10 , pady = 10 ) self . repeat_button = ttk . Button ( self , text = \"Erneut wiedergeben\" , command = self . repeat_frequency , width = button_width , state = tk . DISABLED ) self . repeat_button . pack ( padx = 10 , pady = 10 ) self . stop_button = ttk . Button ( self , text = \"Wiedergabe stoppen\" , command = self . stop_playing , width = button_width , state = tk . DISABLED ) self . stop_button . pack ( padx = 10 , pady = 10 ) self . back_button = ttk . Button ( self , text = \"Zur\u00fcck zum Hauptmen\u00fc\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) # TODO Kalibrierung resetten, damit man sie dann wieder von vorne anfangen kann self . back_button . pack ( padx = 10 , pady = 20 ) self . spacer_frame = tk . Frame ( self , width = 20 , height = 80 ) self . spacer_frame . pack () self . current_freq_var = tk . StringVar ( value = \"Aktuelle Frequenz:\" ) self . current_freq = ttk . Label ( self , textvariable = self . current_freq_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . current_freq . pack ( padx = 10 , pady = 10 ) self . level_expected_var = tk . StringVar ( value = \"Schalldruckpegel (soll):\" ) self . level_expected_label = ttk . Label ( self , textvariable = self . level_expected_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_expected_label . pack ( padx = 10 , pady = 10 ) self . level_measured_label = ttk . Label ( self , text = \"Gemessener Schalldruckpegel in dB:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_measured_label . pack ( padx = 10 , pady = 10 ) self . level_measured_var = tk . StringVar () self . level_measured_entry = ttk . Entry ( self , width = button_width - 10 , font = ( FONT_FAMILY , SUBHEADER_SIZE ), state = tk . DISABLED , textvariable = self . level_measured_var ) self . level_measured_entry . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) def start_calibration ( self ): \"\"\"Starts the calibration process and change state of buttons. \"\"\" try : current_freq , current_spl = self . cal_start ( float ( self . level_entry_var . get ())) except : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie eine Zahl ein.' ) return self . start_button . config ( state = tk . DISABLED ) self . next_button . config ( state = tk . NORMAL ) self . repeat_button . config ( state = tk . NORMAL ) self . stop_button . config ( state = tk . NORMAL ) self . level_measured_entry . config ( state = tk . NORMAL ) self . current_freq_var . set ( \"Aktuelle Frequenz: \" + str ( current_freq ) + \" Hz\" ) self . level_expected_var . set ( \"Schalldruckpegel (soll): \" + str ( current_spl ) + \" dB\" ) def next_frequency ( self ): \"\"\"Sets previously entered level, then get next frequency and play it. \"\"\" try : if self . level_measured_var . get () != \"\" : self . cal_setlevel ( float ( self . level_measured_var . get ())) else : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei \"gemessener Schalldruckpegel\" eine Zahl ein.' ) return except ValueError : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei \"gemessener Schalldruck\" eine Zahl ein.' ) return self . level_measured_var . set ( \"\" ) more_freqs , current_freq , current_spl = self . cal_next () # Change Button when last frequency if not more_freqs : # Grey out all buttons when finished if self . finished : self . next_button . config ( state = tk . DISABLED ) self . repeat_button . config ( state = tk . DISABLED ) self . stop_button . config ( state = tk . DISABLED ) self . level_measured_entry . config ( state = tk . DISABLED ) messagebox . showwarning ( \"Kalibrierung abgeschlossen.\" , \"Die Kalibrierung wurde erfolgreich abgeschlossen. Datei gespeichert als calibration.csv\" ) return self . next_button . config ( text = \"Kalibrierung abschlie\u00dfen\" ) self . finished = True self . current_freq_var . set ( \"Aktuelle Frequenz: \" + str ( current_freq ) + \" Hz\" ) self . level_expected_var . set ( \"Schalldruckpegel (soll): \" + str ( current_spl ) + \" dB\" ) def repeat_frequency ( self ): \"\"\"Replays the same frequency.\"\"\" self . cal_repeat () def stop_playing ( self ): \"\"\"Stops playing audio.\"\"\" self . cal_stop ()","title":"CalibrationPage"},{"location":"api/ui/#app.ui.CalibrationPage.__init__","text":"__init__ ( parent , calibration_funcs ) Creates Page for calibrating the audiometer. Parameters: parent ( App ) \u2013 parent application calibration_funcs ( list function ) \u2013 list of function(s) for calibration in this order: start, next, repeat, stop, set_level Source code in app\\ui.py 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 def __init__ ( self , parent , calibration_funcs ): \"\"\"Creates Page for calibrating the audiometer. Args: parent (App): parent application calibration_funcs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level \"\"\" super () . __init__ ( parent ) self . parent = parent self . cal_start = calibration_funcs [ 0 ] self . cal_next = calibration_funcs [ 1 ] self . cal_repeat = calibration_funcs [ 2 ] self . cal_stop = calibration_funcs [ 3 ] self . cal_setlevel = calibration_funcs [ 4 ] self . create_widgets () self . finished = False","title":"__init__"},{"location":"api/ui/#app.ui.CalibrationPage.create_widgets","text":"create_widgets () Creates the widgets for the page. Source code in app\\ui.py 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" button_width = 25 self . intro = ttk . Label ( self , text = text_calibration , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . intro . pack ( padx = 10 , pady = 10 ) self . level_label = ttk . Label ( self , text = \"Wert in dBHL, bei dem kalibriert werden soll:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_label . pack ( padx = 10 , pady = 10 ) self . level_entry_var = tk . StringVar () self . level_entry_var . set ( \"10\" ) self . level_entry = ttk . Entry ( self , width = button_width - 10 , textvariable = self . level_entry_var ) self . level_entry . pack ( padx = 10 , pady = 10 ) self . start_button = ttk . Button ( self , text = \"Kalibrierung starten\" , command = self . start_calibration , width = button_width ) self . start_button . pack ( padx = 10 , pady = 10 ) self . next_button = ttk . Button ( self , text = \"N\u00e4chste Frequenz\" , command = self . next_frequency , width = button_width , state = tk . DISABLED ) self . next_button . pack ( padx = 10 , pady = 10 ) self . repeat_button = ttk . Button ( self , text = \"Erneut wiedergeben\" , command = self . repeat_frequency , width = button_width , state = tk . DISABLED ) self . repeat_button . pack ( padx = 10 , pady = 10 ) self . stop_button = ttk . Button ( self , text = \"Wiedergabe stoppen\" , command = self . stop_playing , width = button_width , state = tk . DISABLED ) self . stop_button . pack ( padx = 10 , pady = 10 ) self . back_button = ttk . Button ( self , text = \"Zur\u00fcck zum Hauptmen\u00fc\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) # TODO Kalibrierung resetten, damit man sie dann wieder von vorne anfangen kann self . back_button . pack ( padx = 10 , pady = 20 ) self . spacer_frame = tk . Frame ( self , width = 20 , height = 80 ) self . spacer_frame . pack () self . current_freq_var = tk . StringVar ( value = \"Aktuelle Frequenz:\" ) self . current_freq = ttk . Label ( self , textvariable = self . current_freq_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . current_freq . pack ( padx = 10 , pady = 10 ) self . level_expected_var = tk . StringVar ( value = \"Schalldruckpegel (soll):\" ) self . level_expected_label = ttk . Label ( self , textvariable = self . level_expected_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_expected_label . pack ( padx = 10 , pady = 10 ) self . level_measured_label = ttk . Label ( self , text = \"Gemessener Schalldruckpegel in dB:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_measured_label . pack ( padx = 10 , pady = 10 ) self . level_measured_var = tk . StringVar () self . level_measured_entry = ttk . Entry ( self , width = button_width - 10 , font = ( FONT_FAMILY , SUBHEADER_SIZE ), state = tk . DISABLED , textvariable = self . level_measured_var ) self . level_measured_entry . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' )","title":"create_widgets"},{"location":"api/ui/#app.ui.CalibrationPage.next_frequency","text":"next_frequency () Sets previously entered level, then get next frequency and play it. Source code in app\\ui.py 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 def next_frequency ( self ): \"\"\"Sets previously entered level, then get next frequency and play it. \"\"\" try : if self . level_measured_var . get () != \"\" : self . cal_setlevel ( float ( self . level_measured_var . get ())) else : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei \"gemessener Schalldruckpegel\" eine Zahl ein.' ) return except ValueError : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei \"gemessener Schalldruck\" eine Zahl ein.' ) return self . level_measured_var . set ( \"\" ) more_freqs , current_freq , current_spl = self . cal_next () # Change Button when last frequency if not more_freqs : # Grey out all buttons when finished if self . finished : self . next_button . config ( state = tk . DISABLED ) self . repeat_button . config ( state = tk . DISABLED ) self . stop_button . config ( state = tk . DISABLED ) self . level_measured_entry . config ( state = tk . DISABLED ) messagebox . showwarning ( \"Kalibrierung abgeschlossen.\" , \"Die Kalibrierung wurde erfolgreich abgeschlossen. Datei gespeichert als calibration.csv\" ) return self . next_button . config ( text = \"Kalibrierung abschlie\u00dfen\" ) self . finished = True self . current_freq_var . set ( \"Aktuelle Frequenz: \" + str ( current_freq ) + \" Hz\" ) self . level_expected_var . set ( \"Schalldruckpegel (soll): \" + str ( current_spl ) + \" dB\" )","title":"next_frequency"},{"location":"api/ui/#app.ui.CalibrationPage.repeat_frequency","text":"repeat_frequency () Replays the same frequency. Source code in app\\ui.py 786 787 788 789 def repeat_frequency ( self ): \"\"\"Replays the same frequency.\"\"\" self . cal_repeat ()","title":"repeat_frequency"},{"location":"api/ui/#app.ui.CalibrationPage.start_calibration","text":"start_calibration () Starts the calibration process and change state of buttons. Source code in app\\ui.py 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 def start_calibration ( self ): \"\"\"Starts the calibration process and change state of buttons. \"\"\" try : current_freq , current_spl = self . cal_start ( float ( self . level_entry_var . get ())) except : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie eine Zahl ein.' ) return self . start_button . config ( state = tk . DISABLED ) self . next_button . config ( state = tk . NORMAL ) self . repeat_button . config ( state = tk . NORMAL ) self . stop_button . config ( state = tk . NORMAL ) self . level_measured_entry . config ( state = tk . NORMAL ) self . current_freq_var . set ( \"Aktuelle Frequenz: \" + str ( current_freq ) + \" Hz\" ) self . level_expected_var . set ( \"Schalldruckpegel (soll): \" + str ( current_spl ) + \" dB\" )","title":"start_calibration"},{"location":"api/ui/#app.ui.CalibrationPage.stop_playing","text":"stop_playing () Stops playing audio. Source code in app\\ui.py 791 792 793 794 def stop_playing ( self ): \"\"\"Stops playing audio.\"\"\" self . cal_stop ()","title":"stop_playing"},{"location":"api/ui/#app.ui.DuringFamiliarizationView","text":"Bases: Frame Source code in app\\ui.py 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 class DuringFamiliarizationView ( ttk . Frame ): def __init__ ( self , parent , familiarization_func , progress_func ): \"\"\"Creates View during familiarization process. Args: parent (App): parent application familiarization_func (function): function to be called for familiarization progress_func (function): function to get the progress of the current process \"\"\" super () . __init__ ( parent ) self . parent = parent self . program = familiarization_func self . get_progress = progress_func self . text = \"Eingew\u00f6hnung l\u00e4uft...\" self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the view. \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 )","title":"DuringFamiliarizationView"},{"location":"api/ui/#app.ui.DuringFamiliarizationView.__init__","text":"__init__ ( parent , familiarization_func , progress_func ) Creates View during familiarization process. Parameters: parent ( App ) \u2013 parent application familiarization_func ( function ) \u2013 function to be called for familiarization progress_func ( function ) \u2013 function to get the progress of the current process Source code in app\\ui.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def __init__ ( self , parent , familiarization_func , progress_func ): \"\"\"Creates View during familiarization process. Args: parent (App): parent application familiarization_func (function): function to be called for familiarization progress_func (function): function to get the progress of the current process \"\"\" super () . __init__ ( parent ) self . parent = parent self . program = familiarization_func self . get_progress = progress_func self . text = \"Eingew\u00f6hnung l\u00e4uft...\" self . create_widgets ()","title":"__init__"},{"location":"api/ui/#app.ui.DuringFamiliarizationView.create_widgets","text":"create_widgets () Creates the widgets for the view. Source code in app\\ui.py 549 550 551 552 553 554 555 556 def create_widgets ( self ): \"\"\"Creates the widgets for the view. \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 )","title":"create_widgets"},{"location":"api/ui/#app.ui.DuringProcedureView","text":"Bases: Frame Source code in app\\ui.py 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 class DuringProcedureView ( ttk . Frame ): def __init__ ( self , parent , program_func , progress_func , text ): \"\"\"Creates View during main program. Args: parent (App): parent application program_func (function): function to be called for the main program progress_func (function): function to get the progress of the current process text (str): text to be displayed \"\"\" super () . __init__ ( parent ) self . parent = parent self . program = program_func self . get_progress = progress_func self . text = text self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the view. \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 )","title":"DuringProcedureView"},{"location":"api/ui/#app.ui.DuringProcedureView.__init__","text":"__init__ ( parent , program_func , progress_func , text ) Creates View during main program. Parameters: parent ( App ) \u2013 parent application program_func ( function ) \u2013 function to be called for the main program progress_func ( function ) \u2013 function to get the progress of the current process text ( str ) \u2013 text to be displayed Source code in app\\ui.py 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 def __init__ ( self , parent , program_func , progress_func , text ): \"\"\"Creates View during main program. Args: parent (App): parent application program_func (function): function to be called for the main program progress_func (function): function to get the progress of the current process text (str): text to be displayed \"\"\" super () . __init__ ( parent ) self . parent = parent self . program = program_func self . get_progress = progress_func self . text = text self . create_widgets ()","title":"__init__"},{"location":"api/ui/#app.ui.DuringProcedureView.create_widgets","text":"create_widgets () Creates the widgets for the view. Source code in app\\ui.py 577 578 579 580 581 582 583 584 def create_widgets ( self ): \"\"\"Creates the widgets for the view. \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 )","title":"create_widgets"},{"location":"api/ui/#app.ui.FamiliarizationPage","text":"Bases: Frame Source code in app\\ui.py 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 class FamiliarizationPage ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Creates Page for starting the familiarization process. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" button_width = 25 self . label = ttk . Label ( self , text = text_Familiarization , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . label . pack ( padx = 10 , pady = 10 ) self . play_button = ttk . Button ( self , text = \"Starte Eingew\u00f6hnung\" , command = self . run_familiarization , width = button_width ) self . play_button . pack ( padx = 10 , pady = 10 ) self . go_back_button = ttk . Button ( self , text = \"zur\u00fcck\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) self . go_back_button . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) def run_familiarization ( self ): \"\"\"Runs the familiarization process and goes to the next page. \"\"\" self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( DuringFamiliarizationView ) gender = self . parent . frames [ MainMenu ] . gender_dropdown . get () if gender == \"Geschlecht...\" or gender == \"Keine Angabe\" : gender = \"\" age = self . parent . frames [ MainMenu ] . age_entry . get () self . parent . wait_for_process ( lambda : self . parent . frames [ DuringFamiliarizationView ] . program ( id = self . parent . frames [ MainMenu ] . proband_number , calibrate = self . use_calibration , gender = gender , age = age ), lambda : self . parent . show_frame ( ProgramPage )) time . sleep ( 0.001 ) self . update () counter = 3000 # set a high value so that progress bar is updated once at the beginning sleep_time = random . uniform ( 0.1 , 0.5 ) # random time in seconds between 0.1 and 0.5 to update progress bar while self . parent . frames [ DuringFamiliarizationView ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ DuringFamiliarizationView ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ DuringFamiliarizationView ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False","title":"FamiliarizationPage"},{"location":"api/ui/#app.ui.FamiliarizationPage.__init__","text":"__init__ ( parent ) Creates Page for starting the familiarization process. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 404 405 406 407 408 409 410 411 412 def __init__ ( self , parent ): \"\"\"Creates Page for starting the familiarization process. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets ()","title":"__init__"},{"location":"api/ui/#app.ui.FamiliarizationPage.create_widgets","text":"create_widgets () Creates the widgets for the page. Source code in app\\ui.py 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" button_width = 25 self . label = ttk . Label ( self , text = text_Familiarization , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . label . pack ( padx = 10 , pady = 10 ) self . play_button = ttk . Button ( self , text = \"Starte Eingew\u00f6hnung\" , command = self . run_familiarization , width = button_width ) self . play_button . pack ( padx = 10 , pady = 10 ) self . go_back_button = ttk . Button ( self , text = \"zur\u00fcck\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) self . go_back_button . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' )","title":"create_widgets"},{"location":"api/ui/#app.ui.FamiliarizationPage.run_familiarization","text":"run_familiarization () Runs the familiarization process and goes to the next page. Source code in app\\ui.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 def run_familiarization ( self ): \"\"\"Runs the familiarization process and goes to the next page. \"\"\" self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( DuringFamiliarizationView ) gender = self . parent . frames [ MainMenu ] . gender_dropdown . get () if gender == \"Geschlecht...\" or gender == \"Keine Angabe\" : gender = \"\" age = self . parent . frames [ MainMenu ] . age_entry . get () self . parent . wait_for_process ( lambda : self . parent . frames [ DuringFamiliarizationView ] . program ( id = self . parent . frames [ MainMenu ] . proband_number , calibrate = self . use_calibration , gender = gender , age = age ), lambda : self . parent . show_frame ( ProgramPage )) time . sleep ( 0.001 ) self . update () counter = 3000 # set a high value so that progress bar is updated once at the beginning sleep_time = random . uniform ( 0.1 , 0.5 ) # random time in seconds between 0.1 and 0.5 to update progress bar while self . parent . frames [ DuringFamiliarizationView ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ DuringFamiliarizationView ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ DuringFamiliarizationView ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False","title":"run_familiarization"},{"location":"api/ui/#app.ui.MainMenu","text":"Bases: Frame Source code in app\\ui.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 class MainMenu ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Creates the Main menu page. \"\"\" super () . __init__ ( parent ) self . parent = parent self . button_width = 25 self . start_button = None self . binaural_test = tk . BooleanVar () self . use_calibration = tk . BooleanVar ( value = True ) self . selected_option = None self . proband_number = \"\" self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" self . proband_number_label = ttk . Label ( self , text = \"Probandennummer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . proband_number_label . pack ( padx = 10 , pady = 10 ) self . proband_number_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . proband_number_entry . pack ( padx = 10 , pady = 10 ) self . gender_label = ttk . Label ( self , text = \"Geschlecht (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . gender_label . pack ( padx = 10 , pady = 10 ) self . gender_dropdown = ttk . Combobox ( self , values = [ \"M\u00e4nnlich\" , \"Weiblich\" , \"Divers\" , \"Keine Angabe\" ], state = \"readonly\" , width = self . button_width - 1 ) self . gender_dropdown . set ( \"Geschlecht...\" ) self . gender_dropdown . pack ( padx = 10 , pady = 10 ) self . age_label = ttk . Label ( self , text = \"Alter (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . age_label . pack ( padx = 10 , pady = 10 ) self . age_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . age_entry . pack ( padx = 10 , pady = 10 ) self . label = ttk . Label ( self , text = \" \\n Bitte w\u00e4hlen Sie ein Programm\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . label . pack ( pady = 10 ) # Dropdown menu options = list ( self . parent . program_funcs . keys ()) self . dropdown = ttk . Combobox ( self , values = options , state = \"readonly\" , width = self . button_width - 1 ) self . dropdown . set ( \"Test w\u00e4hlen...\" ) self . dropdown . pack ( pady = 10 ) self . dropdown . bind ( \"<<ComboboxSelected>>\" , self . on_option_selected ) self . binaural_button = ttk . Checkbutton ( self , text = \"Binaurale Testung\" , variable = self . binaural_test ) self . binaural_button . pack ( pady = 10 ) # Use calibration button self . cal_button = ttk . Checkbutton ( self , text = \"Werte aus letzter Kalibrierung verwenden\" , variable = self . use_calibration ) self . cal_button . pack ( pady = 10 , side = \"bottom\" ) # Headphone selection self . headphone_dropdown = ttk . Combobox ( self , values = self . get_headphone_options (), state = \"readonly\" , width = self . button_width - 1 ) self . headphone_dropdown . set ( \"Sennheiser_HDA200\" ) self . headphone_dropdown . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) self . headphone_label = ttk . Label ( self , text = \"Kopfh\u00f6rer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . headphone_label . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) def get_headphone_options ( self ): \"\"\"Reads all possible headphone models from retspl.csv file. Returns: list of str: all headphone models listed in retspl.csv \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): messagebox . showwarning ( \"Warnung\" , f 'Die Datei \" { file_name } \" konnte nicht gefunden werden.' ) return headphone_options = [] try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : headphone_options . append ( row [ 'headphone_model' ]) headphone_options = list ( set ( headphone_options )) return headphone_options except Exception as e : messagebox . showwarning ( \"Warnung\" , f 'Fehler beim Lesen der Datei \" { file_name } \": { e } ' ) return def on_option_selected ( self , event ): \"\"\"Changes state of buttons and show start button depending on procedure selected. \"\"\" self . selected_option = self . dropdown . get () self . show_start_button () if self . selected_option == \"Kalibrierung\" : self . cal_button . config ( state = tk . DISABLED ) self . binaural_button . config ( state = tk . DISABLED ) self . gender_dropdown . config ( state = tk . DISABLED ) self . proband_number_entry . config ( state = tk . DISABLED ) else : self . cal_button . config ( state = tk . NORMAL ) self . binaural_button . config ( state = tk . NORMAL ) self . gender_dropdown . config ( state = tk . NORMAL ) self . proband_number_entry . config ( state = tk . NORMAL ) def show_start_button ( self ): \"\"\"Shows start button if not already visible. \"\"\" if self . start_button is None : self . start_button = ttk . Button ( self , text = \"Test starten\" , command = self . go_to_next_page , width = self . button_width ) self . start_button . pack ( pady = 10 ) def go_to_next_page ( self ): \"\"\"Go to next page depending on selected options. \"\"\" if self . selected_option == \"Kalibrierung\" : self . parent . show_frame ( CalibrationPage ) else : self . proband_number = self . proband_number_entry . get () if not self . proband_number : messagebox . showwarning ( \"Warnung\" , \"Bitte geben Sie eine Probandennummer ein.\" ) return # check if valide age is entered if self . age_entry . get (): try : i = int ( self . age_entry . get ()) if i > 110 or i < 0 : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei Alter eine g\u00fcltige Zahl oder gar nichts ein.' ) return except : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei Alter eine g\u00fcltige Zahl oder gar nichts ein.' ) return proband_folder = os . path . join ( self . parent . save_path , self . proband_number ) pics = self . parent . get_images_in_path ( proband_folder ) if pics : if messagebox . askyesno ( \"Proband vorhanden\" , \"F\u00fcr diese Probandennummer gibt es bereits Ergebnisse. M\u00f6chten Sie diese anzeigen?\" ): results_page = self . parent . frames [ ResultPage ] results_page . display_images ( self . proband_number ) self . parent . show_frame ( ResultPage ) return self . parent . show_frame ( FamiliarizationPage )","title":"MainMenu"},{"location":"api/ui/#app.ui.MainMenu.__init__","text":"__init__ ( parent ) Creates the Main menu page. Source code in app\\ui.py 254 255 256 257 258 259 260 261 262 263 264 265 def __init__ ( self , parent ): \"\"\"Creates the Main menu page. \"\"\" super () . __init__ ( parent ) self . parent = parent self . button_width = 25 self . start_button = None self . binaural_test = tk . BooleanVar () self . use_calibration = tk . BooleanVar ( value = True ) self . selected_option = None self . proband_number = \"\" self . create_widgets ()","title":"__init__"},{"location":"api/ui/#app.ui.MainMenu.create_widgets","text":"create_widgets () Creates the widgets for the page. Source code in app\\ui.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" self . proband_number_label = ttk . Label ( self , text = \"Probandennummer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . proband_number_label . pack ( padx = 10 , pady = 10 ) self . proband_number_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . proband_number_entry . pack ( padx = 10 , pady = 10 ) self . gender_label = ttk . Label ( self , text = \"Geschlecht (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . gender_label . pack ( padx = 10 , pady = 10 ) self . gender_dropdown = ttk . Combobox ( self , values = [ \"M\u00e4nnlich\" , \"Weiblich\" , \"Divers\" , \"Keine Angabe\" ], state = \"readonly\" , width = self . button_width - 1 ) self . gender_dropdown . set ( \"Geschlecht...\" ) self . gender_dropdown . pack ( padx = 10 , pady = 10 ) self . age_label = ttk . Label ( self , text = \"Alter (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . age_label . pack ( padx = 10 , pady = 10 ) self . age_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . age_entry . pack ( padx = 10 , pady = 10 ) self . label = ttk . Label ( self , text = \" \\n Bitte w\u00e4hlen Sie ein Programm\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . label . pack ( pady = 10 ) # Dropdown menu options = list ( self . parent . program_funcs . keys ()) self . dropdown = ttk . Combobox ( self , values = options , state = \"readonly\" , width = self . button_width - 1 ) self . dropdown . set ( \"Test w\u00e4hlen...\" ) self . dropdown . pack ( pady = 10 ) self . dropdown . bind ( \"<<ComboboxSelected>>\" , self . on_option_selected ) self . binaural_button = ttk . Checkbutton ( self , text = \"Binaurale Testung\" , variable = self . binaural_test ) self . binaural_button . pack ( pady = 10 ) # Use calibration button self . cal_button = ttk . Checkbutton ( self , text = \"Werte aus letzter Kalibrierung verwenden\" , variable = self . use_calibration ) self . cal_button . pack ( pady = 10 , side = \"bottom\" ) # Headphone selection self . headphone_dropdown = ttk . Combobox ( self , values = self . get_headphone_options (), state = \"readonly\" , width = self . button_width - 1 ) self . headphone_dropdown . set ( \"Sennheiser_HDA200\" ) self . headphone_dropdown . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) self . headphone_label = ttk . Label ( self , text = \"Kopfh\u00f6rer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . headphone_label . pack ( padx = 10 , pady = 10 , side = \"bottom\" )","title":"create_widgets"},{"location":"api/ui/#app.ui.MainMenu.get_headphone_options","text":"get_headphone_options () Reads all possible headphone models from retspl.csv file. Returns: \u2013 list of str: all headphone models listed in retspl.csv Source code in app\\ui.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def get_headphone_options ( self ): \"\"\"Reads all possible headphone models from retspl.csv file. Returns: list of str: all headphone models listed in retspl.csv \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): messagebox . showwarning ( \"Warnung\" , f 'Die Datei \" { file_name } \" konnte nicht gefunden werden.' ) return headphone_options = [] try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : headphone_options . append ( row [ 'headphone_model' ]) headphone_options = list ( set ( headphone_options )) return headphone_options except Exception as e : messagebox . showwarning ( \"Warnung\" , f 'Fehler beim Lesen der Datei \" { file_name } \": { e } ' ) return","title":"get_headphone_options"},{"location":"api/ui/#app.ui.MainMenu.go_to_next_page","text":"go_to_next_page () Go to next page depending on selected options. Source code in app\\ui.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def go_to_next_page ( self ): \"\"\"Go to next page depending on selected options. \"\"\" if self . selected_option == \"Kalibrierung\" : self . parent . show_frame ( CalibrationPage ) else : self . proband_number = self . proband_number_entry . get () if not self . proband_number : messagebox . showwarning ( \"Warnung\" , \"Bitte geben Sie eine Probandennummer ein.\" ) return # check if valide age is entered if self . age_entry . get (): try : i = int ( self . age_entry . get ()) if i > 110 or i < 0 : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei Alter eine g\u00fcltige Zahl oder gar nichts ein.' ) return except : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei Alter eine g\u00fcltige Zahl oder gar nichts ein.' ) return proband_folder = os . path . join ( self . parent . save_path , self . proband_number ) pics = self . parent . get_images_in_path ( proband_folder ) if pics : if messagebox . askyesno ( \"Proband vorhanden\" , \"F\u00fcr diese Probandennummer gibt es bereits Ergebnisse. M\u00f6chten Sie diese anzeigen?\" ): results_page = self . parent . frames [ ResultPage ] results_page . display_images ( self . proband_number ) self . parent . show_frame ( ResultPage ) return self . parent . show_frame ( FamiliarizationPage )","title":"go_to_next_page"},{"location":"api/ui/#app.ui.MainMenu.on_option_selected","text":"on_option_selected ( event ) Changes state of buttons and show start button depending on procedure selected. Source code in app\\ui.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 def on_option_selected ( self , event ): \"\"\"Changes state of buttons and show start button depending on procedure selected. \"\"\" self . selected_option = self . dropdown . get () self . show_start_button () if self . selected_option == \"Kalibrierung\" : self . cal_button . config ( state = tk . DISABLED ) self . binaural_button . config ( state = tk . DISABLED ) self . gender_dropdown . config ( state = tk . DISABLED ) self . proband_number_entry . config ( state = tk . DISABLED ) else : self . cal_button . config ( state = tk . NORMAL ) self . binaural_button . config ( state = tk . NORMAL ) self . gender_dropdown . config ( state = tk . NORMAL ) self . proband_number_entry . config ( state = tk . NORMAL )","title":"on_option_selected"},{"location":"api/ui/#app.ui.MainMenu.show_start_button","text":"show_start_button () Shows start button if not already visible. Source code in app\\ui.py 356 357 358 359 360 361 362 363 364 def show_start_button ( self ): \"\"\"Shows start button if not already visible. \"\"\" if self . start_button is None : self . start_button = ttk . Button ( self , text = \"Test starten\" , command = self . go_to_next_page , width = self . button_width ) self . start_button . pack ( pady = 10 )","title":"show_start_button"},{"location":"api/ui/#app.ui.ProgramPage","text":"Bases: Frame Source code in app\\ui.py 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 class ProgramPage ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Creates Page for starting the main program. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . selected_option = None self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" self . start_button = ttk . Button ( self , text = \"Starte Prozess\" , command = self . run_program ) self . start_button . pack ( padx = 10 , pady = 200 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) def run_program ( self ): \"\"\"Runs the main program. \"\"\" self . selected_option = self . parent . frames [ MainMenu ] . selected_option self . binaural_test = self . parent . frames [ MainMenu ] . binaural_test . get () self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( self . selected_option ) self . parent . wait_for_process ( lambda : self . parent . frames [ self . selected_option ] . program ( self . binaural_test , calibrate = self . use_calibration ), self . show_results ) time . sleep ( 0.001 ) self . update () counter = 3000 # set a high value so that progress bar is updated once at the beginning sleep_time = random . uniform ( 1 , 2.5 ) # random time in seconds between 1 and 2.5 to update progress bar while self . parent . frames [ self . selected_option ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ self . selected_option ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ self . selected_option ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False def show_results ( self ): \"\"\"Shows the results page with (all) images. \"\"\" proband_number = self . parent . frames [ MainMenu ] . proband_number results_page = self . parent . frames [ ResultPage ] results_page . display_images ( proband_number ) self . parent . show_frame ( ResultPage )","title":"ProgramPage"},{"location":"api/ui/#app.ui.ProgramPage.__init__","text":"__init__ ( parent ) Creates Page for starting the main program. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 473 474 475 476 477 478 479 480 481 482 def __init__ ( self , parent ): \"\"\"Creates Page for starting the main program. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . selected_option = None self . create_widgets ()","title":"__init__"},{"location":"api/ui/#app.ui.ProgramPage.create_widgets","text":"create_widgets () Creates the widgets for the page. Source code in app\\ui.py 484 485 486 487 488 489 490 491 def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" self . start_button = ttk . Button ( self , text = \"Starte Prozess\" , command = self . run_program ) self . start_button . pack ( padx = 10 , pady = 200 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' )","title":"create_widgets"},{"location":"api/ui/#app.ui.ProgramPage.run_program","text":"run_program () Runs the main program. Source code in app\\ui.py 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 def run_program ( self ): \"\"\"Runs the main program. \"\"\" self . selected_option = self . parent . frames [ MainMenu ] . selected_option self . binaural_test = self . parent . frames [ MainMenu ] . binaural_test . get () self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( self . selected_option ) self . parent . wait_for_process ( lambda : self . parent . frames [ self . selected_option ] . program ( self . binaural_test , calibrate = self . use_calibration ), self . show_results ) time . sleep ( 0.001 ) self . update () counter = 3000 # set a high value so that progress bar is updated once at the beginning sleep_time = random . uniform ( 1 , 2.5 ) # random time in seconds between 1 and 2.5 to update progress bar while self . parent . frames [ self . selected_option ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ self . selected_option ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ self . selected_option ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False","title":"run_program"},{"location":"api/ui/#app.ui.ProgramPage.show_results","text":"show_results () Shows the results page with (all) images. Source code in app\\ui.py 521 522 523 524 525 526 527 def show_results ( self ): \"\"\"Shows the results page with (all) images. \"\"\" proband_number = self . parent . frames [ MainMenu ] . proband_number results_page = self . parent . frames [ ResultPage ] results_page . display_images ( proband_number ) self . parent . show_frame ( ResultPage )","title":"show_results"},{"location":"api/ui/#app.ui.ResultPage","text":"Bases: Frame Source code in app\\ui.py 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 class ResultPage ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Creates Page for showing the results of the program. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the view. \"\"\" self . info = ttk . Label ( self , text = \"Ergebnisse\" , font = ( FONT_FAMILY , HEADER_SIZE )) self . info . pack ( padx = 10 , pady = 10 ) # Set the title on the parent window self . parent . title ( \"Audiogramm\" ) # Create a frame for the images self . image_frame = ttk . Frame ( self ) self . image_frame . pack ( anchor = \"center\" ) #,fill=\"both\", expand=True) # Button to go back to the main menu self . BackToMainMenu = ttk . Button ( self , text = \"Zur\u00fcck zur Startseite\" , command = lambda : self . parent . show_frame ( MainMenu )) self . BackToMainMenu . pack ( padx = 10 , pady = 10 ) def display_images ( self , folder_name ): \"\"\"Display all images in the given folder. Args: folder_name (str): name of the folder containing the images \"\"\" folder_path = os . path . join ( self . parent . save_path , folder_name ) for widget in self . image_frame . winfo_children (): widget . destroy () pics = self . parent . get_images_in_path ( folder_path ) if pics : for file in pics : img = Image . open ( file ) photo = ImageTk . PhotoImage ( img ) label = ttk . Label ( self . image_frame , image = photo ) label . image = photo label . pack ( padx = 10 , pady = 10 , side = \"left\" ) def back_to_MainMenu ( self ): \"\"\"Goes back to main menu. \"\"\" self . parent . show_frame ( MainMenu )","title":"ResultPage"},{"location":"api/ui/#app.ui.ResultPage.__init__","text":"__init__ ( parent ) Creates Page for showing the results of the program. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 589 590 591 592 593 594 595 596 597 598 def __init__ ( self , parent ): \"\"\"Creates Page for showing the results of the program. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets ()","title":"__init__"},{"location":"api/ui/#app.ui.ResultPage.back_to_MainMenu","text":"back_to_MainMenu () Goes back to main menu. Source code in app\\ui.py 637 638 639 640 def back_to_MainMenu ( self ): \"\"\"Goes back to main menu. \"\"\" self . parent . show_frame ( MainMenu )","title":"back_to_MainMenu"},{"location":"api/ui/#app.ui.ResultPage.create_widgets","text":"create_widgets () Creates the widgets for the view. Source code in app\\ui.py 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 def create_widgets ( self ): \"\"\"Creates the widgets for the view. \"\"\" self . info = ttk . Label ( self , text = \"Ergebnisse\" , font = ( FONT_FAMILY , HEADER_SIZE )) self . info . pack ( padx = 10 , pady = 10 ) # Set the title on the parent window self . parent . title ( \"Audiogramm\" ) # Create a frame for the images self . image_frame = ttk . Frame ( self ) self . image_frame . pack ( anchor = \"center\" ) #,fill=\"both\", expand=True) # Button to go back to the main menu self . BackToMainMenu = ttk . Button ( self , text = \"Zur\u00fcck zur Startseite\" , command = lambda : self . parent . show_frame ( MainMenu )) self . BackToMainMenu . pack ( padx = 10 , pady = 10 )","title":"create_widgets"},{"location":"api/ui/#app.ui.ResultPage.display_images","text":"display_images ( folder_name ) Display all images in the given folder. Parameters: folder_name ( str ) \u2013 name of the folder containing the images Source code in app\\ui.py 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 def display_images ( self , folder_name ): \"\"\"Display all images in the given folder. Args: folder_name (str): name of the folder containing the images \"\"\" folder_path = os . path . join ( self . parent . save_path , folder_name ) for widget in self . image_frame . winfo_children (): widget . destroy () pics = self . parent . get_images_in_path ( folder_path ) if pics : for file in pics : img = Image . open ( file ) photo = ImageTk . PhotoImage ( img ) label = ttk . Label ( self . image_frame , image = photo ) label . image = photo label . pack ( padx = 10 , pady = 10 , side = \"left\" )","title":"display_images"},{"location":"api/ui/#app.ui.setup_ui","text":"setup_ui ( startfunc , programfuncs , calibrationfuncs , progressfunc ) Creates tkinter app and return it. Parameters: startfunc ( function ) \u2013 function to be called for familiarization programfuncs ( dict of str ) \u2013 function): function(s) to be called for the main program calibrationfuncs ( list function ) \u2013 list of function(s) for calibration in this order: start, next, repeat, stop, set_level progressfunc ( function ) \u2013 function to get the progress of the current process Source code in app\\ui.py 796 797 798 799 800 801 802 803 804 805 806 807 def setup_ui ( startfunc , programfuncs , calibrationfuncs , progressfunc ): \"\"\" Creates tkinter app and return it. Args: startfunc (function): function to be called for familiarization programfuncs (dict of str:function): function(s) to be called for the main program calibrationfuncs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level progressfunc (function): function to get the progress of the current process \"\"\" app = App ( startfunc , programfuncs , calibrationfuncs , progressfunc ) return app","title":"setup_ui"},{"location":"user_guide/hardware/","text":"Hardware Anforderungen \u00b6 1. Computer System \u00b6 Operating System : Windows 10 oder h\u00f6her, macOS Processor : Intel i5 oder gleichwertiger AMD processor oder h\u00f6her RAM : Mindestens 8 GB (16 GB recommended for optimal performance) Storage : 200 MB freier Festplattenspeicher f\u00fcr die Softwareinstallation, zus\u00e4tzlicher Speicherplatz f\u00fcr die Speicherung von Testergebnissen 2. Audio Interface \u00b6 Soundkarte : Hochwertige externe oder interne Soundkarte, die pr\u00e4zise Audioausgabe erm\u00f6glicht Kopfh\u00f6rer : Kalibrierte Koph\u00f6rer, empfohlen Sennheiser HDA 200. Auch unterst\u00fctzt: Beyer_DT_48, Sennheiser_HDA_280,RadioEar_DD_45,Telephonics_TDH_39 3. Display \u00b6 Monitor : Mindestaufl\u00f6sung von 1280 x 720; 1920 x 1080 oder h\u00f6her 4. Eingabeger\u00e4te \u00b6 Tastatur und Maus : Standardtastatur und Maus zur Navigation durch die GUI und zur Bereitstellung von Feedback. 5. Kalibrierungsausr\u00fcstung \u00b6 Kunstkopf oder akustischer Kuppler : Ein Kunstkopf oder ein akustischer Kuppler zur Messung und Kalibrierung der Ausgabelevel Hardware Requirements \u00b6 1. Computer System \u00b6 Operating System : Windows 10 or higher, macOS Processor : Intel i5 or equivalent AMD processor or higher RAM : 8 GB minimum (16 GB recommended for optimal performance) Storage : 200 MB of free disk space for software installation, additional space for storing test results 2. Audio Interface \u00b6 Sound Card : High-quality external or internal sound card capable of precise audio output Headphones : Calibrated headphones, such as Sennheiser HDA 200, for accurate frequency response Microphone (Optional) : For calibration purposes or voice commands 3. Display \u00b6 Monitor : Minimum resolution of 1280 x 720; 1920 x 1080 or higher recommended for better GUI experience 4. Input Devices \u00b6 Keyboard and Mouse : Standard keyboard and mouse for navigating the GUI and providing feedback 5. Calibration Equipment \u00b6 Head and Torso Simulator or acoustic coupler : An artificial head or an acoustic coupler for measuring and calibrating the output levels","title":"Hardware"},{"location":"user_guide/hardware/#hardware-anforderungen","text":"","title":"Hardware Anforderungen"},{"location":"user_guide/hardware/#1-computer-system","text":"Operating System : Windows 10 oder h\u00f6her, macOS Processor : Intel i5 oder gleichwertiger AMD processor oder h\u00f6her RAM : Mindestens 8 GB (16 GB recommended for optimal performance) Storage : 200 MB freier Festplattenspeicher f\u00fcr die Softwareinstallation, zus\u00e4tzlicher Speicherplatz f\u00fcr die Speicherung von Testergebnissen","title":"1. Computer System"},{"location":"user_guide/hardware/#2-audio-interface","text":"Soundkarte : Hochwertige externe oder interne Soundkarte, die pr\u00e4zise Audioausgabe erm\u00f6glicht Kopfh\u00f6rer : Kalibrierte Koph\u00f6rer, empfohlen Sennheiser HDA 200. Auch unterst\u00fctzt: Beyer_DT_48, Sennheiser_HDA_280,RadioEar_DD_45,Telephonics_TDH_39","title":"2. Audio Interface"},{"location":"user_guide/hardware/#3-display","text":"Monitor : Mindestaufl\u00f6sung von 1280 x 720; 1920 x 1080 oder h\u00f6her","title":"3. Display"},{"location":"user_guide/hardware/#4-eingabegerate","text":"Tastatur und Maus : Standardtastatur und Maus zur Navigation durch die GUI und zur Bereitstellung von Feedback.","title":"4. Eingabeger\u00e4te"},{"location":"user_guide/hardware/#5-kalibrierungsausrustung","text":"Kunstkopf oder akustischer Kuppler : Ein Kunstkopf oder ein akustischer Kuppler zur Messung und Kalibrierung der Ausgabelevel","title":"5. Kalibrierungsausr\u00fcstung"},{"location":"user_guide/hardware/#hardware-requirements","text":"","title":"Hardware Requirements"},{"location":"user_guide/hardware/#1-computer-system_1","text":"Operating System : Windows 10 or higher, macOS Processor : Intel i5 or equivalent AMD processor or higher RAM : 8 GB minimum (16 GB recommended for optimal performance) Storage : 200 MB of free disk space for software installation, additional space for storing test results","title":"1. Computer System"},{"location":"user_guide/hardware/#2-audio-interface_1","text":"Sound Card : High-quality external or internal sound card capable of precise audio output Headphones : Calibrated headphones, such as Sennheiser HDA 200, for accurate frequency response Microphone (Optional) : For calibration purposes or voice commands","title":"2. Audio Interface"},{"location":"user_guide/hardware/#3-display_1","text":"Monitor : Minimum resolution of 1280 x 720; 1920 x 1080 or higher recommended for better GUI experience","title":"3. Display"},{"location":"user_guide/hardware/#4-input-devices","text":"Keyboard and Mouse : Standard keyboard and mouse for navigating the GUI and providing feedback","title":"4. Input Devices"},{"location":"user_guide/hardware/#5-calibration-equipment","text":"Head and Torso Simulator or acoustic coupler : An artificial head or an acoustic coupler for measuring and calibrating the output levels","title":"5. Calibration Equipment"},{"location":"user_guide/installation/","text":"Installation \u00b6 Schnelle Installation mit venv \u00b6 Repository klonen: git clone https://github.com/Satur42/Audiometer.git cd Audiometer Virtuelle Umgebung erstellen: python -m venv venv Virtuelle Umgebung aktivieren: Auf Windows: venv\\Scripts\\activate Auf macOS und Linux:: source venv/bin/activate Ben\u00f6tigte Abh\u00e4ngigkeiten installieren: pip install -r requirements.txt Skript ausf\u00fchren: python run_app.py Installation \u00b6 Quick Installation with venv \u00b6 Clone the repository: git clone https://github.com/Satur42/Audiometer.git cd Audiometer Create a virtual environment: python -m venv venv Activate virtual environment: On Windows: venv\\Scripts\\activate On macOS and Linux:: source venv/bin/activate Install the required dependencies: pip install -r requirements.txt Run script: python run_app.py","title":"Installation"},{"location":"user_guide/installation/#installation","text":"","title":"Installation"},{"location":"user_guide/installation/#schnelle-installation-mit-venv","text":"Repository klonen: git clone https://github.com/Satur42/Audiometer.git cd Audiometer Virtuelle Umgebung erstellen: python -m venv venv Virtuelle Umgebung aktivieren: Auf Windows: venv\\Scripts\\activate Auf macOS und Linux:: source venv/bin/activate Ben\u00f6tigte Abh\u00e4ngigkeiten installieren: pip install -r requirements.txt Skript ausf\u00fchren: python run_app.py","title":"Schnelle Installation mit venv"},{"location":"user_guide/installation/#installation_1","text":"","title":"Installation"},{"location":"user_guide/installation/#quick-installation-with-venv","text":"Clone the repository: git clone https://github.com/Satur42/Audiometer.git cd Audiometer Create a virtual environment: python -m venv venv Activate virtual environment: On Windows: venv\\Scripts\\activate On macOS and Linux:: source venv/bin/activate Install the required dependencies: pip install -r requirements.txt Run script: python run_app.py","title":"Quick Installation with venv"},{"location":"user_guide/intro/","text":"Einleitung \u00b6 Willkommen zur Dokumentation des Audiometer-Projekts, das im Rahmen des \"Projekt Python und Akustik 2024\" an der Technischen Universit\u00e4t Berlin entwickelt wurde. Dieses Projekt zielt darauf ab, ein automatisiertes Audiometer zu programmieren, das die H\u00f6rf\u00e4higkeit von Probanden pr\u00e4zise und benutzerfreundlich ermittelt. Ein Audiometer ist ein diagnostisches Ger\u00e4t, das verwendet wird, um die H\u00f6rschwellen eines Menschen zu bestimmen. Es gibt verschiedene Methoden zur Durchf\u00fchrung von H\u00f6rtests, in diesem Projekt wurde das Einzelton-Verfahren mit ansteigendem Pegel, \u00fcber Kopfh\u00f6rer und ohne Verdeckung, realisiert. Dieses Verfahren ist gem\u00e4\u00df der DIN EN ISO 8253-1 normiert. Das Audiometer testet die Frequenzb\u00e4nder von 125 Hz bis 8000 Hz. Es wird als Output ein Audiogramm erstellt in welchem die H\u00f6rschwellen abgelesen werden k\u00f6nnen und eine CSV Datei gespeichert, die zur weiteren Verabeitung der Daten verwendet werden kann. Neben dem klassichen Audiometer-Testverfahren gibt es au\u00dferdem die M\u00f6glichkeit der binauralen Testung und eine Screening-Audiometrie. Zudem wird eine Eingew\u00f6hnung des Probanden durch eine Einweisung und einen Testlauf im Frequenzband von 1000 Hz durchgef\u00fchrt, um sicherzustellen, dass der Proband den Testablauf verstanden hat. Grunds\u00e4tzlich ist das Programm so konzipiert, dass es \u00fcber die GUI selbst\u00e4ndig vom Probanden durchgef\u00fchrt werden kann. Wir empfehlen jedoch eine Betreuung von Fachkundigen um validierte Ergebnisse zu erhalten. Es ist zu beachten, dass diese computergesteuerte Audiometer nur dazu dient, Ihr H\u00f6rverm\u00f6gen zu beurteilen, und eine genaue Diagnose durch einen Facharzt nicht ersetzt. F\u00fcr eine genauere Diagnose konsultieren Sie bitte Ihren Arzt. Introduction \u00b6 Welcome to the documentation of the audiometer project, which was developed as part of the \"Project Python and Acoustics 2024\" at the Technical University of Berlin. This project aims to programme an automated audiometer that determines the hearing ability of test persons in a precise and user-friendly way. An audiometer is a diagnostic device that is used to determine a person's hearing thresholds. There are various methods for carrying out hearing tests; in this project, the single-tone method with increasing level, via headphones and without masking, was realised. This method is standardised in accordance with DIN EN ISO 8253-1. The audiometer tests the frequency bands from 125 Hz to 8000 Hz. The output is an audiogram in which the hearing thresholds can be read and a CSV file is saved, which can be used for further processing of the data. In addition to the classic audiometer test procedure, there is also the option of binaural testing and screening audiometry. In addition, the respondent is familiarised with the programme by means of a briefing and a test run in the 1000 Hz frequency band to ensure that the respondent has understood the test procedure. In principle, the programme is designed so that it can be carried out independently by the respondent using the GUI. However, we recommend supervision by a specialist in order to obtain validated results. Please note that this computerised audiometer is only intended to assess your hearing and does not replace an accurate diagnosis by a specialist. For a more accurate diagnosis, please consult your doctor. Installation Hardware Requirements","title":"Einleitung (Introduction)"},{"location":"user_guide/intro/#einleitung","text":"Willkommen zur Dokumentation des Audiometer-Projekts, das im Rahmen des \"Projekt Python und Akustik 2024\" an der Technischen Universit\u00e4t Berlin entwickelt wurde. Dieses Projekt zielt darauf ab, ein automatisiertes Audiometer zu programmieren, das die H\u00f6rf\u00e4higkeit von Probanden pr\u00e4zise und benutzerfreundlich ermittelt. Ein Audiometer ist ein diagnostisches Ger\u00e4t, das verwendet wird, um die H\u00f6rschwellen eines Menschen zu bestimmen. Es gibt verschiedene Methoden zur Durchf\u00fchrung von H\u00f6rtests, in diesem Projekt wurde das Einzelton-Verfahren mit ansteigendem Pegel, \u00fcber Kopfh\u00f6rer und ohne Verdeckung, realisiert. Dieses Verfahren ist gem\u00e4\u00df der DIN EN ISO 8253-1 normiert. Das Audiometer testet die Frequenzb\u00e4nder von 125 Hz bis 8000 Hz. Es wird als Output ein Audiogramm erstellt in welchem die H\u00f6rschwellen abgelesen werden k\u00f6nnen und eine CSV Datei gespeichert, die zur weiteren Verabeitung der Daten verwendet werden kann. Neben dem klassichen Audiometer-Testverfahren gibt es au\u00dferdem die M\u00f6glichkeit der binauralen Testung und eine Screening-Audiometrie. Zudem wird eine Eingew\u00f6hnung des Probanden durch eine Einweisung und einen Testlauf im Frequenzband von 1000 Hz durchgef\u00fchrt, um sicherzustellen, dass der Proband den Testablauf verstanden hat. Grunds\u00e4tzlich ist das Programm so konzipiert, dass es \u00fcber die GUI selbst\u00e4ndig vom Probanden durchgef\u00fchrt werden kann. Wir empfehlen jedoch eine Betreuung von Fachkundigen um validierte Ergebnisse zu erhalten. Es ist zu beachten, dass diese computergesteuerte Audiometer nur dazu dient, Ihr H\u00f6rverm\u00f6gen zu beurteilen, und eine genaue Diagnose durch einen Facharzt nicht ersetzt. F\u00fcr eine genauere Diagnose konsultieren Sie bitte Ihren Arzt.","title":"Einleitung"},{"location":"user_guide/intro/#introduction","text":"Welcome to the documentation of the audiometer project, which was developed as part of the \"Project Python and Acoustics 2024\" at the Technical University of Berlin. This project aims to programme an automated audiometer that determines the hearing ability of test persons in a precise and user-friendly way. An audiometer is a diagnostic device that is used to determine a person's hearing thresholds. There are various methods for carrying out hearing tests; in this project, the single-tone method with increasing level, via headphones and without masking, was realised. This method is standardised in accordance with DIN EN ISO 8253-1. The audiometer tests the frequency bands from 125 Hz to 8000 Hz. The output is an audiogram in which the hearing thresholds can be read and a CSV file is saved, which can be used for further processing of the data. In addition to the classic audiometer test procedure, there is also the option of binaural testing and screening audiometry. In addition, the respondent is familiarised with the programme by means of a briefing and a test run in the 1000 Hz frequency band to ensure that the respondent has understood the test procedure. In principle, the programme is designed so that it can be carried out independently by the respondent using the GUI. However, we recommend supervision by a specialist in order to obtain validated results. Please note that this computerised audiometer is only intended to assess your hearing and does not replace an accurate diagnosis by a specialist. For a more accurate diagnosis, please consult your doctor. Installation Hardware Requirements","title":"Introduction"}]}