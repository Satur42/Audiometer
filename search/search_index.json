{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Willkommen zur Audiometer-Dokumentation \u00b6 Willkommen zur Audiometer-Dokumentation! Hier finden Sie alle Informationen zur Nutzung und den Funktionen der Audiometer-Anwendung. Diese Dokumentation enth\u00e4lt Anleitungen zur Installation, Nutzung und Fehlerbehebung. Sections \u00b6 Benutzerhandbuch Referenzhandbuch \u00dcber Audiometer Welcome to Audiometer Documentation \u00b6 Welcome to the Audiometer documentation! Here you will find all information on the use and functions of the Audiometer application. This documentation contains instructions for installation, use and troubleshooting. Sections \u00b6 User Guide Reference Manual About","title":"Home"},{"location":"#willkommen-zur-audiometer-dokumentation","text":"Willkommen zur Audiometer-Dokumentation! Hier finden Sie alle Informationen zur Nutzung und den Funktionen der Audiometer-Anwendung. Diese Dokumentation enth\u00e4lt Anleitungen zur Installation, Nutzung und Fehlerbehebung.","title":"Willkommen zur Audiometer-Dokumentation"},{"location":"#sections","text":"Benutzerhandbuch Referenzhandbuch \u00dcber Audiometer","title":"Sections"},{"location":"#welcome-to-audiometer-documentation","text":"Welcome to the Audiometer documentation! Here you will find all information on the use and functions of the Audiometer application. This documentation contains instructions for installation, use and troubleshooting.","title":"Welcome to Audiometer Documentation"},{"location":"#sections_1","text":"User Guide Reference Manual About","title":"Sections"},{"location":"about/","text":"Technische Universit\u00e4t Berlin Fakult\u00e4t V - Verkehrs- und Maschinensysteme Institut f\u00fcr Str\u00f6mungsmechanik und Technische Akustik Projekt Python und Akustik Stra\u00dfe des 17. Juni 135 10623 Berlin","title":"About"},{"location":"api/audio_player/","text":"Audioplayer \u00b6 AudioPlayer \u00b6 Source code in app\\audio_player.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class AudioPlayer : def __init__ ( self ): \"\"\"An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False def generate_tone ( self ): \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone def play_beep ( self , frequency , volume , duration , channel = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs ) def stop ( self ): \"\"\"Stops the current playback \"\"\" sd . stop () def int_or_str ( self , text ): \"\"\"Helper function for argument parsing.\"\"\" try : return int ( text ) except ValueError : return text def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ] __init__ \u00b6 __init__ () An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. Source code in app\\audio_player.py 7 8 9 10 11 12 13 14 15 16 def __init__ ( self ): \"\"\"An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False generate_tone \u00b6 generate_tone () Generates a sine tone with current audio player settings. Returns: array \u2013 sine wave as numpy array Source code in app\\audio_player.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def generate_tone ( self ): \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone get_device_samplerate \u00b6 get_device_samplerate () Gets current samplerate from the selected audio output device. Returns: float \u2013 samplerate of current sound device Source code in app\\audio_player.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ] int_or_str \u00b6 int_or_str ( text ) Helper function for argument parsing. Source code in app\\audio_player.py 69 70 71 72 73 74 def int_or_str ( self , text ): \"\"\"Helper function for argument parsing.\"\"\" try : return int ( text ) except ValueError : return text play_beep \u00b6 play_beep ( frequency , volume , duration , channel = 'lr' ) Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Parameters: frequency ( int ) \u2013 frequency in Hz volume ( float ) \u2013 volume multiplier (between 0 and 1) duration ( int ) \u2013 duration of the beep in seconds channel ( string , default: 'lr' ) \u2013 'l', 'r' or 'lr' for only left, only right or both channels respectively Source code in app\\audio_player.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def play_beep ( self , frequency , volume , duration , channel = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs ) stop \u00b6 stop () Stops the current playback Source code in app\\audio_player.py 63 64 65 66 def stop ( self ): \"\"\"Stops the current playback \"\"\" sd . stop ()","title":"audio_player"},{"location":"api/audio_player/#audioplayer","text":"","title":"Audioplayer"},{"location":"api/audio_player/#app.audio_player.AudioPlayer","text":"Source code in app\\audio_player.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class AudioPlayer : def __init__ ( self ): \"\"\"An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False def generate_tone ( self ): \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone def play_beep ( self , frequency , volume , duration , channel = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs ) def stop ( self ): \"\"\"Stops the current playback \"\"\" sd . stop () def int_or_str ( self , text ): \"\"\"Helper function for argument parsing.\"\"\" try : return int ( text ) except ValueError : return text def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ]","title":"AudioPlayer"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.__init__","text":"__init__ () An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. Source code in app\\audio_player.py 7 8 9 10 11 12 13 14 15 16 def __init__ ( self ): \"\"\"An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False","title":"__init__"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.generate_tone","text":"generate_tone () Generates a sine tone with current audio player settings. Returns: array \u2013 sine wave as numpy array Source code in app\\audio_player.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def generate_tone ( self ): \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone","title":"generate_tone"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.get_device_samplerate","text":"get_device_samplerate () Gets current samplerate from the selected audio output device. Returns: float \u2013 samplerate of current sound device Source code in app\\audio_player.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ]","title":"get_device_samplerate"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.int_or_str","text":"int_or_str ( text ) Helper function for argument parsing. Source code in app\\audio_player.py 69 70 71 72 73 74 def int_or_str ( self , text ): \"\"\"Helper function for argument parsing.\"\"\" try : return int ( text ) except ValueError : return text","title":"int_or_str"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.play_beep","text":"play_beep ( frequency , volume , duration , channel = 'lr' ) Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Parameters: frequency ( int ) \u2013 frequency in Hz volume ( float ) \u2013 volume multiplier (between 0 and 1) duration ( int ) \u2013 duration of the beep in seconds channel ( string , default: 'lr' ) \u2013 'l', 'r' or 'lr' for only left, only right or both channels respectively Source code in app\\audio_player.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def play_beep ( self , frequency , volume , duration , channel = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs )","title":"play_beep"},{"location":"api/audio_player/#app.audio_player.AudioPlayer.stop","text":"stop () Stops the current playback Source code in app\\audio_player.py 63 64 65 66 def stop ( self ): \"\"\"Stops the current playback \"\"\" sd . stop ()","title":"stop"},{"location":"api/audiogram/","text":"audiogram Module \u00b6 create_audiogram \u00b6 create_audiogram ( freqs , left_values = None , right_values = None , binaural = False , name = 'audiogram.png' , freq_levels = freq_levels , subtitle = None ) Erstellt ein Audiogramm basierend auf den gegebenen Frequenzen und H\u00f6rschwellenwerten mit benutzerdefinierten x-Achsen-Beschriftungen. Parameters: freqs ( list of int ) \u2013 Eine Liste von Frequenzen in Hz. right_values ( list of int , default: None ) \u2013 Eine Liste von H\u00f6rschwellen in dB HL vom rechten Ohr. left_values ( list of int , default: None ) \u2013 Eine Liste von H\u00f6rschwellen in dB HL vom linken Ohr save ( bool ) \u2013 Ob das Diagramm gespeichert werden soll name ( str , default: 'audiogram.png' ) \u2013 Der Name der Datei, wenn das Diagramm gespeichert werden soll Source code in app\\audiogram.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def create_audiogram ( freqs , left_values = None , right_values = None , binaural = False , name = \"audiogram.png\" , freq_levels = freq_levels , subtitle = None ): \"\"\"Erstellt ein Audiogramm basierend auf den gegebenen Frequenzen und H\u00f6rschwellenwerten mit benutzerdefinierten x-Achsen-Beschriftungen. Args: freqs (list of int): Eine Liste von Frequenzen in Hz. right_values (list of int): Eine Liste von H\u00f6rschwellen in dB HL vom rechten Ohr. left_values (list of int): Eine Liste von H\u00f6rschwellen in dB HL vom linken Ohr save (bool): Ob das Diagramm gespeichert werden soll name (str): Der Name der Datei, wenn das Diagramm gespeichert werden soll \"\"\" print ( \"Creating audiogram with frequencies:\" , freqs ) print ( \"Left ear values:\" , left_values ) print ( \"Right ear values:\" , right_values ) fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . axhspan ( - 10 , 20 , facecolor = 'lightgreen' , alpha = 0.2 ) ax . axhspan ( 20 , 40 , facecolor = 'lightskyblue' , alpha = 0.2 ) ax . axhspan ( 40 , 70 , facecolor = 'yellow' , alpha = 0.2 ) ax . axhspan ( 70 , 90 , facecolor = 'orange' , alpha = 0.2 ) ax . axhspan ( 90 , 120 , facecolor = 'red' , alpha = 0.2 ) t1 = ax . text ( 6.4 , 5 , 'Normalh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t2 = ax . text ( 6.4 , 30 , 'Leichte \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t3 = ax . text ( 6.4 , 55 , 'Mittlere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t4 = ax . text ( 6.4 , 80 , 'Schwere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t5 = ax . text ( 6.4 , 105 , 'Hochgradige \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) x_vals = range ( len ( freqs )) target_values = np . array ( list ( freq_levels . values ())) nan_freqs_left = [ freq for i , freq in zip ( left_values , freqs ) if i == 'NaN' ] nan_freqs_right = [ freq for i , freq in zip ( right_values , freqs ) if i == 'NaN' ] nan_text = \"\" nan_t = False if 'NH' in left_values or 'NH' in right_values : heard_i_left , heard_level_left , not_heard_i_left , not_heard_level_left = split_values ( x_vals , left_values , target_values ) heard_i_right , heard_level_right , not_heard_i_right , not_heard_level_right = split_values ( x_vals , right_values , target_values ) if binaural : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_BINAURAL ) ax . plot ( heard_i_left , heard_level_left , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left , marker = NOT_HEARD_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'nicht geh\u00f6rt' ) else : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_RIGHT ) ax . plot ( heard_i_right , heard_level_right , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markerfacecolor = 'none' , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts geh\u00f6rt' ) ax . plot ( not_heard_i_right , not_heard_level_right , marker = NOT_HEARD_RIGHT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts nicht geh\u00f6rt' ) ax . plot ( x_vals , target_values + SHIFT , linestyle = '-' , color = COLOR_LEFT ) ax . plot ( heard_i_left , heard_level_left + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left + SHIFT , marker = NOT_HEARD_LEFT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links nicht geh\u00f6rt' ) else : x_vals_left , left_values = filter_none ( x_vals , left_values ) x_vals_right , right_values = filter_none ( x_vals , right_values ) if binaural : ax . plot ( x_vals_left , left_values , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = '-' , color = COLOR_BINAURAL , label = 'binaural' ) else : ax . plot ( x_vals_right , right_values , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , markerfacecolor = 'none' , label = 'rechtes Ohr' ) ax . plot ( x_vals_left , left_values + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'linkes Ohr' ) if nan_freqs_left or nan_freqs_right : and_str = \"\" nan_text = \"Bei folgenden Frequenzen konnte kein Wert ermittelt werden: \\n \" print ( nan_freqs_left , nan_freqs_right ) if nan_freqs_left : nan_text += f \"links: { ', ' . join ( map ( str , nan_freqs_left )) } \" and_str = \"und \" if nan_freqs_right : nan_text += f \" { and_str } rechts: { ', ' . join ( map ( str , nan_freqs_right )) } \" nan_t = ax . text ( 0.05 , - 0.2 , nan_text , transform = ax . transAxes , fontsize = TEXT_FONT_SIZE , ha = 'left' , va = 'top' , bbox = dict ( facecolor = 'None' , edgecolor = 'None' )) ax . invert_yaxis () if subtitle : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE , y = 1.02 ) ax . set_title ( subtitle , fontsize = LABEL_FONT_SIZE , pad = 20 ) else : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE ) ax . set_xlabel ( 'Frequenzen (Hz)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylabel ( 'H\u00f6rschwelle (dB HL)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylim ( 120 , - 10 ) ax . set_xticks ( range ( len ( freqs ))) ax . set_xticklabels ([ f \" { int ( freq ) } \" for freq in freqs ], fontsize = TICK_FONT_SIZE ) ax . set_yticks ( np . arange ( 0 , 121 , 10 )) ax . set_yticklabels ( np . arange ( 0 , 121 , 10 ), fontsize = TICK_FONT_SIZE ) ax . grid ( True , which = 'both' , linestyle = '--' , linewidth = 0.5 ) lgd = ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1.15 , 0.205 ), fontsize = LEGEND_FONT_SIZE , frameon = False , labelspacing = 1 ) if nan_t : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 , nan_t ), bbox_inches = 'tight' ) else : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 ), bbox_inches = 'tight' ) plt . close ( fig )","title":"audiogram"},{"location":"api/audiogram/#audiogram-module","text":"","title":"audiogram Module"},{"location":"api/audiogram/#app.audiogram.create_audiogram","text":"create_audiogram ( freqs , left_values = None , right_values = None , binaural = False , name = 'audiogram.png' , freq_levels = freq_levels , subtitle = None ) Erstellt ein Audiogramm basierend auf den gegebenen Frequenzen und H\u00f6rschwellenwerten mit benutzerdefinierten x-Achsen-Beschriftungen. Parameters: freqs ( list of int ) \u2013 Eine Liste von Frequenzen in Hz. right_values ( list of int , default: None ) \u2013 Eine Liste von H\u00f6rschwellen in dB HL vom rechten Ohr. left_values ( list of int , default: None ) \u2013 Eine Liste von H\u00f6rschwellen in dB HL vom linken Ohr save ( bool ) \u2013 Ob das Diagramm gespeichert werden soll name ( str , default: 'audiogram.png' ) \u2013 Der Name der Datei, wenn das Diagramm gespeichert werden soll Source code in app\\audiogram.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def create_audiogram ( freqs , left_values = None , right_values = None , binaural = False , name = \"audiogram.png\" , freq_levels = freq_levels , subtitle = None ): \"\"\"Erstellt ein Audiogramm basierend auf den gegebenen Frequenzen und H\u00f6rschwellenwerten mit benutzerdefinierten x-Achsen-Beschriftungen. Args: freqs (list of int): Eine Liste von Frequenzen in Hz. right_values (list of int): Eine Liste von H\u00f6rschwellen in dB HL vom rechten Ohr. left_values (list of int): Eine Liste von H\u00f6rschwellen in dB HL vom linken Ohr save (bool): Ob das Diagramm gespeichert werden soll name (str): Der Name der Datei, wenn das Diagramm gespeichert werden soll \"\"\" print ( \"Creating audiogram with frequencies:\" , freqs ) print ( \"Left ear values:\" , left_values ) print ( \"Right ear values:\" , right_values ) fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . axhspan ( - 10 , 20 , facecolor = 'lightgreen' , alpha = 0.2 ) ax . axhspan ( 20 , 40 , facecolor = 'lightskyblue' , alpha = 0.2 ) ax . axhspan ( 40 , 70 , facecolor = 'yellow' , alpha = 0.2 ) ax . axhspan ( 70 , 90 , facecolor = 'orange' , alpha = 0.2 ) ax . axhspan ( 90 , 120 , facecolor = 'red' , alpha = 0.2 ) t1 = ax . text ( 6.4 , 5 , 'Normalh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t2 = ax . text ( 6.4 , 30 , 'Leichte \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t3 = ax . text ( 6.4 , 55 , 'Mittlere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t4 = ax . text ( 6.4 , 80 , 'Schwere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t5 = ax . text ( 6.4 , 105 , 'Hochgradige \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) x_vals = range ( len ( freqs )) target_values = np . array ( list ( freq_levels . values ())) nan_freqs_left = [ freq for i , freq in zip ( left_values , freqs ) if i == 'NaN' ] nan_freqs_right = [ freq for i , freq in zip ( right_values , freqs ) if i == 'NaN' ] nan_text = \"\" nan_t = False if 'NH' in left_values or 'NH' in right_values : heard_i_left , heard_level_left , not_heard_i_left , not_heard_level_left = split_values ( x_vals , left_values , target_values ) heard_i_right , heard_level_right , not_heard_i_right , not_heard_level_right = split_values ( x_vals , right_values , target_values ) if binaural : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_BINAURAL ) ax . plot ( heard_i_left , heard_level_left , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left , marker = NOT_HEARD_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'nicht geh\u00f6rt' ) else : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_RIGHT ) ax . plot ( heard_i_right , heard_level_right , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markerfacecolor = 'none' , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts geh\u00f6rt' ) ax . plot ( not_heard_i_right , not_heard_level_right , marker = NOT_HEARD_RIGHT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts nicht geh\u00f6rt' ) ax . plot ( x_vals , target_values + SHIFT , linestyle = '-' , color = COLOR_LEFT ) ax . plot ( heard_i_left , heard_level_left + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left + SHIFT , marker = NOT_HEARD_LEFT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links nicht geh\u00f6rt' ) else : x_vals_left , left_values = filter_none ( x_vals , left_values ) x_vals_right , right_values = filter_none ( x_vals , right_values ) if binaural : ax . plot ( x_vals_left , left_values , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = '-' , color = COLOR_BINAURAL , label = 'binaural' ) else : ax . plot ( x_vals_right , right_values , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , markerfacecolor = 'none' , label = 'rechtes Ohr' ) ax . plot ( x_vals_left , left_values + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'linkes Ohr' ) if nan_freqs_left or nan_freqs_right : and_str = \"\" nan_text = \"Bei folgenden Frequenzen konnte kein Wert ermittelt werden: \\n \" print ( nan_freqs_left , nan_freqs_right ) if nan_freqs_left : nan_text += f \"links: { ', ' . join ( map ( str , nan_freqs_left )) } \" and_str = \"und \" if nan_freqs_right : nan_text += f \" { and_str } rechts: { ', ' . join ( map ( str , nan_freqs_right )) } \" nan_t = ax . text ( 0.05 , - 0.2 , nan_text , transform = ax . transAxes , fontsize = TEXT_FONT_SIZE , ha = 'left' , va = 'top' , bbox = dict ( facecolor = 'None' , edgecolor = 'None' )) ax . invert_yaxis () if subtitle : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE , y = 1.02 ) ax . set_title ( subtitle , fontsize = LABEL_FONT_SIZE , pad = 20 ) else : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE ) ax . set_xlabel ( 'Frequenzen (Hz)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylabel ( 'H\u00f6rschwelle (dB HL)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylim ( 120 , - 10 ) ax . set_xticks ( range ( len ( freqs ))) ax . set_xticklabels ([ f \" { int ( freq ) } \" for freq in freqs ], fontsize = TICK_FONT_SIZE ) ax . set_yticks ( np . arange ( 0 , 121 , 10 )) ax . set_yticklabels ( np . arange ( 0 , 121 , 10 ), fontsize = TICK_FONT_SIZE ) ax . grid ( True , which = 'both' , linestyle = '--' , linewidth = 0.5 ) lgd = ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1.15 , 0.205 ), fontsize = LEGEND_FONT_SIZE , frameon = False , labelspacing = 1 ) if nan_t : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 , nan_t ), bbox_inches = 'tight' ) else : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 ), bbox_inches = 'tight' ) plt . close ( fig )","title":"create_audiogram"},{"location":"api/main/","text":"main Module \u00b6 hallo AudioPlayer \u00b6 Source code in app\\audio_player.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class AudioPlayer : def __init__ ( self ): \"\"\"An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False def generate_tone ( self ): \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone def play_beep ( self , frequency , volume , duration , channel = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs ) def stop ( self ): \"\"\"Stops the current playback \"\"\" sd . stop () def int_or_str ( self , text ): \"\"\"Helper function for argument parsing.\"\"\" try : return int ( text ) except ValueError : return text def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ] __init__ \u00b6 __init__ () An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. Source code in app\\audio_player.py 7 8 9 10 11 12 13 14 15 16 def __init__ ( self ): \"\"\"An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False generate_tone \u00b6 generate_tone () Generates a sine tone with current audio player settings. Returns: array \u2013 sine wave as numpy array Source code in app\\audio_player.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def generate_tone ( self ): \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone get_device_samplerate \u00b6 get_device_samplerate () Gets current samplerate from the selected audio output device. Returns: float \u2013 samplerate of current sound device Source code in app\\audio_player.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ] int_or_str \u00b6 int_or_str ( text ) Helper function for argument parsing. Source code in app\\audio_player.py 69 70 71 72 73 74 def int_or_str ( self , text ): \"\"\"Helper function for argument parsing.\"\"\" try : return int ( text ) except ValueError : return text play_beep \u00b6 play_beep ( frequency , volume , duration , channel = 'lr' ) Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Parameters: frequency ( int ) \u2013 frequency in Hz volume ( float ) \u2013 volume multiplier (between 0 and 1) duration ( int ) \u2013 duration of the beep in seconds channel ( string , default: 'lr' ) \u2013 'l', 'r' or 'lr' for only left, only right or both channels respectively Source code in app\\audio_player.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def play_beep ( self , frequency , volume , duration , channel = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs ) stop \u00b6 stop () Stops the current playback Source code in app\\audio_player.py 63 64 65 66 def stop ( self ): \"\"\"Stops the current playback \"\"\" sd . stop () Calibration \u00b6 Bases: Procedure Source code in app\\model.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 class Calibration ( Procedure ): def __init__ ( self , startlevel = 60 , signal_length = 10 , headphone_name = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ] def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2 def play_one_freq ( self ): \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) def set_calibration_value ( self , measured_value ): \"\"\"Rights the given calibration value into temporary csv file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile ) def finish_calibration ( self ): \"\"\"Makes a permanent csv file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary csv file \"\"\" #TODO csv name self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename ) def stop_playing ( self ): self . ap . stop () __init__ \u00b6 __init__ ( startlevel = 60 , signal_length = 10 , headphone_name = 'Sennheiser_HDA200' , ** additional_data ) Process for calibrating system. Parameters: startlevel ( int , default: 60 ) \u2013 starting level of procedure in dB HL. Defaults to 60. signal_length ( int , default: 10 ) \u2013 length of played signals in seconds. Defaults to 10. Source code in app\\model.py 660 661 662 663 664 665 666 667 668 669 670 def __init__ ( self , startlevel = 60 , signal_length = 10 , headphone_name = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ] finish_calibration \u00b6 finish_calibration () Makes a permanent csv file from the temporary file that overwrites calibration.csv. Parameters: temp_filename ( str ) \u2013 name of temporary csv file Source code in app\\model.py 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 def finish_calibration ( self ): \"\"\"Makes a permanent csv file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary csv file \"\"\" #TODO csv name self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename ) get_next_freq \u00b6 get_next_freq () Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int \u2013 frequency Source code in app\\model.py 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2 play_one_freq \u00b6 play_one_freq () Get the next frequency and play it. Returns: bool \u2013 False if no more frequencies left int \u2013 current frequency float \u2013 expected SPL value in dB Source code in app\\model.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 def play_one_freq ( self ): \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl repeat_freq \u00b6 repeat_freq () Repeats the last played frequency. Source code in app\\model.py 717 718 719 720 721 722 def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) set_calibration_value \u00b6 set_calibration_value ( measured_value ) Rights the given calibration value into temporary csv file Parameters: measured_value ( float ) \u2013 measured SPL value in dB Source code in app\\model.py 725 726 727 728 729 730 731 732 def set_calibration_value ( self , measured_value ): \"\"\"Rights the given calibration value into temporary csv file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile ) Familiarization \u00b6 Bases: Procedure Source code in app\\model.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 class Familiarization ( Procedure ): def __init__ ( self , startlevel = 40 , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True , id = \"\" , ** additional_data ): \"\"\"Familiarization process Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies def get_temp_csv_filename ( self ): return self . tempfile def familiarize ( self ): \"\"\"Main function Returns: bool: familiarization successful \"\"\" while True : self . progress = 0.01 self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 else : self . level += 10 self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True __init__ \u00b6 __init__ ( startlevel = 40 , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True , id = '' , ** additional_data ) Familiarization process Parameters: startlevel ( int , default: 40 ) \u2013 starting level of procedure in dB HL. Defaults to 40. signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. Source code in app\\model.py 332 333 334 335 336 337 338 339 340 341 def __init__ ( self , startlevel = 40 , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True , id = \"\" , ** additional_data ): \"\"\"Familiarization process Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies familiarize \u00b6 familiarize () Main function Returns: bool \u2013 familiarization successful Source code in app\\model.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def familiarize ( self ): \"\"\"Main function Returns: bool: familiarization successful \"\"\" while True : self . progress = 0.01 self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 else : self . level += 10 self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True Procedure \u00b6 Source code in app\\model.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 class Procedure : def __init__ ( self , startlevel , signal_length , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"The parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. Needs to be calibrated! self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = True # TODO turn off for delivery self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = os . getcwd () # Initialize save_path def get_retspl_values ( self , headphone_name ): \"\"\"Read the correct RETSPL values from the retspl.csv file Args: headphone_name (str): exact name of headphone as it appears in csv file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values def get_calibration_values ( self ): \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values def dbhl_to_volume ( self , dbhl ): \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl def key_press ( self , key ): if key == keyboard . Key . space : self . tone_heard = True print ( \"Tone heard!\" ) elif self . test_mode and key == keyboard . Key . right : self . jump_to_end = True def play_tone ( self ): \"\"\"Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times def create_temp_csv ( self , id = \"\" , ** additional_data ): \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (string, optional): id to be stored, that will later be used for naming exported csv file Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name def add_to_temp_csv ( self , value , frequency , side , temp_filename ): \"\"\"Add a value in for a specific frequency to the temporary csv file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary csv file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ]) def get_value_from_csv ( self , frequency , temp_filename , side = 'l' ): \"\"\"Get the value at a specific frequency from the temporary csv file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary csv file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ] def create_final_csv_and_audiogram ( self , temp_filename , binaural = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels ) def parse_dbhl_value ( self , value ): \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None def get_progress ( self ): \"\"\"gets the current progress Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress __init__ \u00b6 __init__ ( startlevel , signal_length , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) The parent class for the familiarization, the main procedure, and the screening. Parameters: startlevel ( float ) \u2013 starting level of procedure in dB HL signal_length ( float ) \u2013 length of played signals in seconds Source code in app\\model.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , startlevel , signal_length , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"The parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. Needs to be calibrated! self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = True # TODO turn off for delivery self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = os . getcwd () # Initialize save_path add_to_temp_csv \u00b6 add_to_temp_csv ( value , frequency , side , temp_filename ) Add a value in for a specific frequency to the temporary csv file Parameters: value ( str ) \u2013 level in dB HL at specific frequency frequency ( str ) \u2013 frequency where value should be added side ( str ) \u2013 specify which ear ('l' or 'r') temp_filename ( str ) \u2013 name of temporary csv file Source code in app\\model.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def add_to_temp_csv ( self , value , frequency , side , temp_filename ): \"\"\"Add a value in for a specific frequency to the temporary csv file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary csv file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ]) create_final_csv_and_audiogram \u00b6 create_final_csv_and_audiogram ( temp_filename , binaural = False ) Creates a permanent CSV file and audiogram from the temporary file. Parameters: temp_filename ( str ) \u2013 Name of the temporary CSV file. binaural ( bool , default: False ) \u2013 If the test is binaural. Source code in app\\model.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 def create_final_csv_and_audiogram ( self , temp_filename , binaural = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels ) create_temp_csv \u00b6 create_temp_csv ( id = '' , ** additional_data ) Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Parameters: id ( string , default: '' ) \u2013 id to be stored, that will later be used for naming exported csv file Returns: str \u2013 name of temporary file Source code in app\\model.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def create_temp_csv ( self , id = \"\" , ** additional_data ): \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (string, optional): id to be stored, that will later be used for naming exported csv file Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name dbhl_to_volume \u00b6 dbhl_to_volume ( dbhl ) Calculate dB HL into absolute numbers. Parameters: dbhl ( float ) \u2013 value in dB HL Returns: float \u2013 value in absolute numbers Source code in app\\model.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def dbhl_to_volume ( self , dbhl ): \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl get_calibration_values \u00b6 get_calibration_values () Read the correct calibration values from the calibration.csv file. Returns: \u2013 dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def get_calibration_values ( self ): \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values get_progress \u00b6 get_progress () gets the current progress Returns: float \u2013 progress value between 0.0 and 1.0 Source code in app\\model.py 320 321 322 323 324 325 326 def get_progress ( self ): \"\"\"gets the current progress Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress get_retspl_values \u00b6 get_retspl_values ( headphone_name ) Read the correct RETSPL values from the retspl.csv file Parameters: headphone_name ( str ) \u2013 exact name of headphone as it appears in csv file Returns: \u2013 dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def get_retspl_values ( self , headphone_name ): \"\"\"Read the correct RETSPL values from the retspl.csv file Args: headphone_name (str): exact name of headphone as it appears in csv file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values get_value_from_csv \u00b6 get_value_from_csv ( frequency , temp_filename , side = 'l' ) Get the value at a specific frequency from the temporary csv file. Parameters: frequency ( str ) \u2013 frequency where value is stored temp_filename ( str ) \u2013 name of temporary csv file side ( str , default: 'l' ) \u2013 specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str \u2013 dB HL value at specified frequency Source code in app\\model.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_value_from_csv ( self , frequency , temp_filename , side = 'l' ): \"\"\"Get the value at a specific frequency from the temporary csv file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary csv file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ] parse_dbhl_value \u00b6 parse_dbhl_value ( value ) Parses the dBHL value from the CSV file. Parameters: value ( str ) \u2013 the value from the CSV file Returns: \u2013 int or None: the parsed value or None if 'NH' Source code in app\\model.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def parse_dbhl_value ( self , value ): \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None play_tone \u00b6 play_tone () Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized). Source code in app\\model.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def play_tone ( self ): \"\"\"Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times ScreeningProcedure \u00b6 Bases: Procedure Source code in app\\model.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 class ScreeningProcedure ( Procedure ): def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14 def screen_test ( self , binaural = False ): \"\"\"main functions Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) def screen_one_ear ( self ): success = [] for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . screen_one_freq ( f ) success . append ( s ) def screen_one_freq ( self , freq ): \"\"\"screening for one frequency Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step __init__ \u00b6 __init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Short screening process to check if subject can hear specific frequencies at certain levels. Parameters: signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. Source code in app\\model.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14 screen_one_freq \u00b6 screen_one_freq ( freq ) screening for one frequency Parameters: freq ( int ) \u2013 frequency to be tested Returns: bool \u2013 tone heard Source code in app\\model.py 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def screen_one_freq ( self , freq ): \"\"\"screening for one frequency Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step screen_test \u00b6 screen_test ( binaural = False ) main functions Returns: bool \u2013 test successful Source code in app\\model.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 def screen_test ( self , binaural = False ): \"\"\"main functions Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) StandardProcedure \u00b6 Bases: Procedure Source code in app\\model.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 class StandardProcedure ( Procedure ): def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary csv file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14 def standard_test ( self , binaural = False ): \"\"\"Main function Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False def standard_test_one_ear ( self ): \"\"\"Audiometer for one ear Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False def standard_test_one_freq ( self , freq , retest = False ): \"\"\"Test for one frequency Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True # TODO Wenn Streuung mehr als 10 dB: Vermerk im Audiogramm self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False __init__ \u00b6 __init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Standard audiometer process (rising level). Parameters: temp_filename ( str ) \u2013 name of temporary csv file where starting level is stored and future values will be stored signal_length ( int , default: 1 ) \u2013 length of played signal in seconds. Defaults to 1. Source code in app\\model.py 403 404 405 406 407 408 409 410 411 412 413 414 415 def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary csv file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14 standard_test \u00b6 standard_test ( binaural = False ) Main function Returns: bool \u2013 test successful Source code in app\\model.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 def standard_test ( self , binaural = False ): \"\"\"Main function Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False standard_test_one_ear \u00b6 standard_test_one_ear () Audiometer for one ear Returns: bool \u2013 test successful Source code in app\\model.py 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 def standard_test_one_ear ( self ): \"\"\"Audiometer for one ear Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False standard_test_one_freq \u00b6 standard_test_one_freq ( freq , retest = False ) Test for one frequency Parameters: freq ( int ) \u2013 frequency at which hearing is tested retest ( bool , default: False ) \u2013 this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool \u2013 test successful Source code in app\\model.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 def standard_test_one_freq ( self , freq , retest = False ): \"\"\"Test for one frequency Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True # TODO Wenn Streuung mehr als 10 dB: Vermerk im Audiogramm self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False create_audiogram \u00b6 create_audiogram ( freqs , left_values = None , right_values = None , binaural = False , name = 'audiogram.png' , freq_levels = freq_levels , subtitle = None ) Erstellt ein Audiogramm basierend auf den gegebenen Frequenzen und H\u00f6rschwellenwerten mit benutzerdefinierten x-Achsen-Beschriftungen. Parameters: freqs ( list of int ) \u2013 Eine Liste von Frequenzen in Hz. right_values ( list of int , default: None ) \u2013 Eine Liste von H\u00f6rschwellen in dB HL vom rechten Ohr. left_values ( list of int , default: None ) \u2013 Eine Liste von H\u00f6rschwellen in dB HL vom linken Ohr save ( bool ) \u2013 Ob das Diagramm gespeichert werden soll name ( str , default: 'audiogram.png' ) \u2013 Der Name der Datei, wenn das Diagramm gespeichert werden soll Source code in app\\audiogram.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def create_audiogram ( freqs , left_values = None , right_values = None , binaural = False , name = \"audiogram.png\" , freq_levels = freq_levels , subtitle = None ): \"\"\"Erstellt ein Audiogramm basierend auf den gegebenen Frequenzen und H\u00f6rschwellenwerten mit benutzerdefinierten x-Achsen-Beschriftungen. Args: freqs (list of int): Eine Liste von Frequenzen in Hz. right_values (list of int): Eine Liste von H\u00f6rschwellen in dB HL vom rechten Ohr. left_values (list of int): Eine Liste von H\u00f6rschwellen in dB HL vom linken Ohr save (bool): Ob das Diagramm gespeichert werden soll name (str): Der Name der Datei, wenn das Diagramm gespeichert werden soll \"\"\" print ( \"Creating audiogram with frequencies:\" , freqs ) print ( \"Left ear values:\" , left_values ) print ( \"Right ear values:\" , right_values ) fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . axhspan ( - 10 , 20 , facecolor = 'lightgreen' , alpha = 0.2 ) ax . axhspan ( 20 , 40 , facecolor = 'lightskyblue' , alpha = 0.2 ) ax . axhspan ( 40 , 70 , facecolor = 'yellow' , alpha = 0.2 ) ax . axhspan ( 70 , 90 , facecolor = 'orange' , alpha = 0.2 ) ax . axhspan ( 90 , 120 , facecolor = 'red' , alpha = 0.2 ) t1 = ax . text ( 6.4 , 5 , 'Normalh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t2 = ax . text ( 6.4 , 30 , 'Leichte \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t3 = ax . text ( 6.4 , 55 , 'Mittlere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t4 = ax . text ( 6.4 , 80 , 'Schwere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t5 = ax . text ( 6.4 , 105 , 'Hochgradige \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) x_vals = range ( len ( freqs )) target_values = np . array ( list ( freq_levels . values ())) nan_freqs_left = [ freq for i , freq in zip ( left_values , freqs ) if i == 'NaN' ] nan_freqs_right = [ freq for i , freq in zip ( right_values , freqs ) if i == 'NaN' ] nan_text = \"\" nan_t = False if 'NH' in left_values or 'NH' in right_values : heard_i_left , heard_level_left , not_heard_i_left , not_heard_level_left = split_values ( x_vals , left_values , target_values ) heard_i_right , heard_level_right , not_heard_i_right , not_heard_level_right = split_values ( x_vals , right_values , target_values ) if binaural : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_BINAURAL ) ax . plot ( heard_i_left , heard_level_left , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left , marker = NOT_HEARD_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'nicht geh\u00f6rt' ) else : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_RIGHT ) ax . plot ( heard_i_right , heard_level_right , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markerfacecolor = 'none' , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts geh\u00f6rt' ) ax . plot ( not_heard_i_right , not_heard_level_right , marker = NOT_HEARD_RIGHT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts nicht geh\u00f6rt' ) ax . plot ( x_vals , target_values + SHIFT , linestyle = '-' , color = COLOR_LEFT ) ax . plot ( heard_i_left , heard_level_left + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left + SHIFT , marker = NOT_HEARD_LEFT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links nicht geh\u00f6rt' ) else : x_vals_left , left_values = filter_none ( x_vals , left_values ) x_vals_right , right_values = filter_none ( x_vals , right_values ) if binaural : ax . plot ( x_vals_left , left_values , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = '-' , color = COLOR_BINAURAL , label = 'binaural' ) else : ax . plot ( x_vals_right , right_values , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , markerfacecolor = 'none' , label = 'rechtes Ohr' ) ax . plot ( x_vals_left , left_values + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'linkes Ohr' ) if nan_freqs_left or nan_freqs_right : and_str = \"\" nan_text = \"Bei folgenden Frequenzen konnte kein Wert ermittelt werden: \\n \" print ( nan_freqs_left , nan_freqs_right ) if nan_freqs_left : nan_text += f \"links: { ', ' . join ( map ( str , nan_freqs_left )) } \" and_str = \"und \" if nan_freqs_right : nan_text += f \" { and_str } rechts: { ', ' . join ( map ( str , nan_freqs_right )) } \" nan_t = ax . text ( 0.05 , - 0.2 , nan_text , transform = ax . transAxes , fontsize = TEXT_FONT_SIZE , ha = 'left' , va = 'top' , bbox = dict ( facecolor = 'None' , edgecolor = 'None' )) ax . invert_yaxis () if subtitle : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE , y = 1.02 ) ax . set_title ( subtitle , fontsize = LABEL_FONT_SIZE , pad = 20 ) else : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE ) ax . set_xlabel ( 'Frequenzen (Hz)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylabel ( 'H\u00f6rschwelle (dB HL)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylim ( 120 , - 10 ) ax . set_xticks ( range ( len ( freqs ))) ax . set_xticklabels ([ f \" { int ( freq ) } \" for freq in freqs ], fontsize = TICK_FONT_SIZE ) ax . set_yticks ( np . arange ( 0 , 121 , 10 )) ax . set_yticklabels ( np . arange ( 0 , 121 , 10 ), fontsize = TICK_FONT_SIZE ) ax . grid ( True , which = 'both' , linestyle = '--' , linewidth = 0.5 ) lgd = ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1.15 , 0.205 ), fontsize = LEGEND_FONT_SIZE , frameon = False , labelspacing = 1 ) if nan_t : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 , nan_t ), bbox_inches = 'tight' ) else : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 ), bbox_inches = 'tight' ) plt . close ( fig )","title":"main"},{"location":"api/main/#main-module","text":"hallo","title":"main Module"},{"location":"api/main/#app.main.AudioPlayer","text":"Source code in app\\audio_player.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class AudioPlayer : def __init__ ( self ): \"\"\"An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False def generate_tone ( self ): \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone def play_beep ( self , frequency , volume , duration , channel = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs ) def stop ( self ): \"\"\"Stops the current playback \"\"\" sd . stop () def int_or_str ( self , text ): \"\"\"Helper function for argument parsing.\"\"\" try : return int ( text ) except ValueError : return text def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ]","title":"AudioPlayer"},{"location":"api/main/#app.main.AudioPlayer.__init__","text":"__init__ () An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. Source code in app\\audio_player.py 7 8 9 10 11 12 13 14 15 16 def __init__ ( self ): \"\"\"An audio player that can play sine beeps at various frequencies, volumes and with various durations. Automatically detects current samplerate of selected sound device. \"\"\" self . fs = self . get_device_samplerate () self . beep_duration = 10 self . volume = 0 self . frequency = 440 self . stream = None self . is_playing = False","title":"__init__"},{"location":"api/main/#app.main.AudioPlayer.generate_tone","text":"generate_tone () Generates a sine tone with current audio player settings. Returns: array \u2013 sine wave as numpy array Source code in app\\audio_player.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def generate_tone ( self ): \"\"\"Generates a sine tone with current audio player settings. Returns: array: sine wave as numpy array \"\"\" t = np . linspace ( start = 0 , stop = self . beep_duration , num = int ( self . fs * self . beep_duration ), endpoint = False ) tone = np . sin ( 2 * np . pi * self . frequency * t ) * self . volume # Create fade-out envelope fade_duration = 0.003 # 3 ms fade-out fade_samples = int ( self . fs * fade_duration ) fade_out = np . linspace ( 1 , 0 , fade_samples ) envelope = np . ones_like ( tone ) envelope [ - fade_samples :] = fade_out # Apply the envelope to the tone tone = tone * envelope return tone","title":"generate_tone"},{"location":"api/main/#app.main.AudioPlayer.get_device_samplerate","text":"get_device_samplerate () Gets current samplerate from the selected audio output device. Returns: float \u2013 samplerate of current sound device Source code in app\\audio_player.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def get_device_samplerate ( self ): \"\"\"Gets current samplerate from the selected audio output device. Returns: float: samplerate of current sound device \"\"\" parser = argparse . ArgumentParser ( add_help = False ) parser . add_argument ( '-l' , '--list-devices' , action = 'store_true' , help = 'show list of audio devices and exit' ) args , remaining = parser . parse_known_args () if args . list_devices : print ( sd . query_devices ()) parser . exit ( 0 ) parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . RawDescriptionHelpFormatter , parents = [ parser ]) parser . add_argument ( 'frequency' , nargs = '?' , metavar = 'FREQUENCY' , type = float , default = 500 , help = 'frequency in Hz (default: %(default)s )' ) parser . add_argument ( '-d' , '--device' , type = self . int_or_str , help = 'output device (numeric ID or substring)' ) parser . add_argument ( '-a' , '--amplitude' , type = float , default = 0.2 , help = 'amplitude (default: %(default)s )' ) args = parser . parse_args ( remaining ) return sd . query_devices ( args . device , 'output' )[ 'default_samplerate' ]","title":"get_device_samplerate"},{"location":"api/main/#app.main.AudioPlayer.int_or_str","text":"int_or_str ( text ) Helper function for argument parsing. Source code in app\\audio_player.py 69 70 71 72 73 74 def int_or_str ( self , text ): \"\"\"Helper function for argument parsing.\"\"\" try : return int ( text ) except ValueError : return text","title":"int_or_str"},{"location":"api/main/#app.main.AudioPlayer.play_beep","text":"play_beep ( frequency , volume , duration , channel = 'lr' ) Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Parameters: frequency ( int ) \u2013 frequency in Hz volume ( float ) \u2013 volume multiplier (between 0 and 1) duration ( int ) \u2013 duration of the beep in seconds channel ( string , default: 'lr' ) \u2013 'l', 'r' or 'lr' for only left, only right or both channels respectively Source code in app\\audio_player.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def play_beep ( self , frequency , volume , duration , channel = 'lr' ): \"\"\"Sets the frequency, volume and beep duration of the audio player and then plays a beep with those parameters. Args: frequency (int): frequency in Hz volume (float): volume multiplier (between 0 and 1) duration (int): duration of the beep in seconds channel (string): 'l', 'r' or 'lr' for only left, only right or both channels respectively \"\"\" self . frequency = frequency self . volume = volume self . beep_duration = duration tone = self . generate_tone () if channel == 'l' : sd . play ( np . array ([ tone , np . zeros ( len ( tone ))]) . T , self . fs ) elif channel == 'r' : sd . play ( np . array ([ np . zeros ( len ( tone )), tone ]) . T , self . fs ) else : sd . play ( tone , self . fs )","title":"play_beep"},{"location":"api/main/#app.main.AudioPlayer.stop","text":"stop () Stops the current playback Source code in app\\audio_player.py 63 64 65 66 def stop ( self ): \"\"\"Stops the current playback \"\"\" sd . stop ()","title":"stop"},{"location":"api/main/#app.main.Calibration","text":"Bases: Procedure Source code in app\\model.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 class Calibration ( Procedure ): def __init__ ( self , startlevel = 60 , signal_length = 10 , headphone_name = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ] def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2 def play_one_freq ( self ): \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) def set_calibration_value ( self , measured_value ): \"\"\"Rights the given calibration value into temporary csv file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile ) def finish_calibration ( self ): \"\"\"Makes a permanent csv file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary csv file \"\"\" #TODO csv name self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename ) def stop_playing ( self ): self . ap . stop ()","title":"Calibration"},{"location":"api/main/#app.main.Calibration.__init__","text":"__init__ ( startlevel = 60 , signal_length = 10 , headphone_name = 'Sennheiser_HDA200' , ** additional_data ) Process for calibrating system. Parameters: startlevel ( int , default: 60 ) \u2013 starting level of procedure in dB HL. Defaults to 60. signal_length ( int , default: 10 ) \u2013 length of played signals in seconds. Defaults to 10. Source code in app\\model.py 660 661 662 663 664 665 666 667 668 669 670 def __init__ ( self , startlevel = 60 , signal_length = 10 , headphone_name = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ]","title":"__init__"},{"location":"api/main/#app.main.Calibration.finish_calibration","text":"finish_calibration () Makes a permanent csv file from the temporary file that overwrites calibration.csv. Parameters: temp_filename ( str ) \u2013 name of temporary csv file Source code in app\\model.py 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 def finish_calibration ( self ): \"\"\"Makes a permanent csv file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary csv file \"\"\" #TODO csv name self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename )","title":"finish_calibration"},{"location":"api/main/#app.main.Calibration.get_next_freq","text":"get_next_freq () Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int \u2013 frequency Source code in app\\model.py 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2","title":"get_next_freq"},{"location":"api/main/#app.main.Calibration.play_one_freq","text":"play_one_freq () Get the next frequency and play it. Returns: bool \u2013 False if no more frequencies left int \u2013 current frequency float \u2013 expected SPL value in dB Source code in app\\model.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 def play_one_freq ( self ): \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl","title":"play_one_freq"},{"location":"api/main/#app.main.Calibration.repeat_freq","text":"repeat_freq () Repeats the last played frequency. Source code in app\\model.py 717 718 719 720 721 722 def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side )","title":"repeat_freq"},{"location":"api/main/#app.main.Calibration.set_calibration_value","text":"set_calibration_value ( measured_value ) Rights the given calibration value into temporary csv file Parameters: measured_value ( float ) \u2013 measured SPL value in dB Source code in app\\model.py 725 726 727 728 729 730 731 732 def set_calibration_value ( self , measured_value ): \"\"\"Rights the given calibration value into temporary csv file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile )","title":"set_calibration_value"},{"location":"api/main/#app.main.Familiarization","text":"Bases: Procedure Source code in app\\model.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 class Familiarization ( Procedure ): def __init__ ( self , startlevel = 40 , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True , id = \"\" , ** additional_data ): \"\"\"Familiarization process Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies def get_temp_csv_filename ( self ): return self . tempfile def familiarize ( self ): \"\"\"Main function Returns: bool: familiarization successful \"\"\" while True : self . progress = 0.01 self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 else : self . level += 10 self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True","title":"Familiarization"},{"location":"api/main/#app.main.Familiarization.__init__","text":"__init__ ( startlevel = 40 , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True , id = '' , ** additional_data ) Familiarization process Parameters: startlevel ( int , default: 40 ) \u2013 starting level of procedure in dB HL. Defaults to 40. signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. Source code in app\\model.py 332 333 334 335 336 337 338 339 340 341 def __init__ ( self , startlevel = 40 , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True , id = \"\" , ** additional_data ): \"\"\"Familiarization process Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies","title":"__init__"},{"location":"api/main/#app.main.Familiarization.familiarize","text":"familiarize () Main function Returns: bool \u2013 familiarization successful Source code in app\\model.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def familiarize ( self ): \"\"\"Main function Returns: bool: familiarization successful \"\"\" while True : self . progress = 0.01 self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 else : self . level += 10 self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True","title":"familiarize"},{"location":"api/main/#app.main.Procedure","text":"Source code in app\\model.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 class Procedure : def __init__ ( self , startlevel , signal_length , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"The parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. Needs to be calibrated! self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = True # TODO turn off for delivery self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = os . getcwd () # Initialize save_path def get_retspl_values ( self , headphone_name ): \"\"\"Read the correct RETSPL values from the retspl.csv file Args: headphone_name (str): exact name of headphone as it appears in csv file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values def get_calibration_values ( self ): \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values def dbhl_to_volume ( self , dbhl ): \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl def key_press ( self , key ): if key == keyboard . Key . space : self . tone_heard = True print ( \"Tone heard!\" ) elif self . test_mode and key == keyboard . Key . right : self . jump_to_end = True def play_tone ( self ): \"\"\"Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times def create_temp_csv ( self , id = \"\" , ** additional_data ): \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (string, optional): id to be stored, that will later be used for naming exported csv file Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name def add_to_temp_csv ( self , value , frequency , side , temp_filename ): \"\"\"Add a value in for a specific frequency to the temporary csv file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary csv file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ]) def get_value_from_csv ( self , frequency , temp_filename , side = 'l' ): \"\"\"Get the value at a specific frequency from the temporary csv file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary csv file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ] def create_final_csv_and_audiogram ( self , temp_filename , binaural = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels ) def parse_dbhl_value ( self , value ): \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None def get_progress ( self ): \"\"\"gets the current progress Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress","title":"Procedure"},{"location":"api/main/#app.main.Procedure.__init__","text":"__init__ ( startlevel , signal_length , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) The parent class for the familiarization, the main procedure, and the screening. Parameters: startlevel ( float ) \u2013 starting level of procedure in dB HL signal_length ( float ) \u2013 length of played signals in seconds Source code in app\\model.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , startlevel , signal_length , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"The parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. Needs to be calibrated! self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = True # TODO turn off for delivery self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = os . getcwd () # Initialize save_path","title":"__init__"},{"location":"api/main/#app.main.Procedure.add_to_temp_csv","text":"add_to_temp_csv ( value , frequency , side , temp_filename ) Add a value in for a specific frequency to the temporary csv file Parameters: value ( str ) \u2013 level in dB HL at specific frequency frequency ( str ) \u2013 frequency where value should be added side ( str ) \u2013 specify which ear ('l' or 'r') temp_filename ( str ) \u2013 name of temporary csv file Source code in app\\model.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def add_to_temp_csv ( self , value , frequency , side , temp_filename ): \"\"\"Add a value in for a specific frequency to the temporary csv file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary csv file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ])","title":"add_to_temp_csv"},{"location":"api/main/#app.main.Procedure.create_final_csv_and_audiogram","text":"create_final_csv_and_audiogram ( temp_filename , binaural = False ) Creates a permanent CSV file and audiogram from the temporary file. Parameters: temp_filename ( str ) \u2013 Name of the temporary CSV file. binaural ( bool , default: False ) \u2013 If the test is binaural. Source code in app\\model.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 def create_final_csv_and_audiogram ( self , temp_filename , binaural = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels )","title":"create_final_csv_and_audiogram"},{"location":"api/main/#app.main.Procedure.create_temp_csv","text":"create_temp_csv ( id = '' , ** additional_data ) Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Parameters: id ( string , default: '' ) \u2013 id to be stored, that will later be used for naming exported csv file Returns: str \u2013 name of temporary file Source code in app\\model.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def create_temp_csv ( self , id = \"\" , ** additional_data ): \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (string, optional): id to be stored, that will later be used for naming exported csv file Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name","title":"create_temp_csv"},{"location":"api/main/#app.main.Procedure.dbhl_to_volume","text":"dbhl_to_volume ( dbhl ) Calculate dB HL into absolute numbers. Parameters: dbhl ( float ) \u2013 value in dB HL Returns: float \u2013 value in absolute numbers Source code in app\\model.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def dbhl_to_volume ( self , dbhl ): \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl","title":"dbhl_to_volume"},{"location":"api/main/#app.main.Procedure.get_calibration_values","text":"get_calibration_values () Read the correct calibration values from the calibration.csv file. Returns: \u2013 dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def get_calibration_values ( self ): \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values","title":"get_calibration_values"},{"location":"api/main/#app.main.Procedure.get_progress","text":"get_progress () gets the current progress Returns: float \u2013 progress value between 0.0 and 1.0 Source code in app\\model.py 320 321 322 323 324 325 326 def get_progress ( self ): \"\"\"gets the current progress Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress","title":"get_progress"},{"location":"api/main/#app.main.Procedure.get_retspl_values","text":"get_retspl_values ( headphone_name ) Read the correct RETSPL values from the retspl.csv file Parameters: headphone_name ( str ) \u2013 exact name of headphone as it appears in csv file Returns: \u2013 dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def get_retspl_values ( self , headphone_name ): \"\"\"Read the correct RETSPL values from the retspl.csv file Args: headphone_name (str): exact name of headphone as it appears in csv file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values","title":"get_retspl_values"},{"location":"api/main/#app.main.Procedure.get_value_from_csv","text":"get_value_from_csv ( frequency , temp_filename , side = 'l' ) Get the value at a specific frequency from the temporary csv file. Parameters: frequency ( str ) \u2013 frequency where value is stored temp_filename ( str ) \u2013 name of temporary csv file side ( str , default: 'l' ) \u2013 specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str \u2013 dB HL value at specified frequency Source code in app\\model.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_value_from_csv ( self , frequency , temp_filename , side = 'l' ): \"\"\"Get the value at a specific frequency from the temporary csv file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary csv file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ]","title":"get_value_from_csv"},{"location":"api/main/#app.main.Procedure.parse_dbhl_value","text":"parse_dbhl_value ( value ) Parses the dBHL value from the CSV file. Parameters: value ( str ) \u2013 the value from the CSV file Returns: \u2013 int or None: the parsed value or None if 'NH' Source code in app\\model.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def parse_dbhl_value ( self , value ): \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None","title":"parse_dbhl_value"},{"location":"api/main/#app.main.Procedure.play_tone","text":"play_tone () Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized). Source code in app\\model.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def play_tone ( self ): \"\"\"Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times","title":"play_tone"},{"location":"api/main/#app.main.ScreeningProcedure","text":"Bases: Procedure Source code in app\\model.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 class ScreeningProcedure ( Procedure ): def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14 def screen_test ( self , binaural = False ): \"\"\"main functions Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) def screen_one_ear ( self ): success = [] for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . screen_one_freq ( f ) success . append ( s ) def screen_one_freq ( self , freq ): \"\"\"screening for one frequency Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step","title":"ScreeningProcedure"},{"location":"api/main/#app.main.ScreeningProcedure.__init__","text":"__init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Short screening process to check if subject can hear specific frequencies at certain levels. Parameters: signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. Source code in app\\model.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14","title":"__init__"},{"location":"api/main/#app.main.ScreeningProcedure.screen_one_freq","text":"screen_one_freq ( freq ) screening for one frequency Parameters: freq ( int ) \u2013 frequency to be tested Returns: bool \u2013 tone heard Source code in app\\model.py 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def screen_one_freq ( self , freq ): \"\"\"screening for one frequency Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step","title":"screen_one_freq"},{"location":"api/main/#app.main.ScreeningProcedure.screen_test","text":"screen_test ( binaural = False ) main functions Returns: bool \u2013 test successful Source code in app\\model.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 def screen_test ( self , binaural = False ): \"\"\"main functions Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural )","title":"screen_test"},{"location":"api/main/#app.main.StandardProcedure","text":"Bases: Procedure Source code in app\\model.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 class StandardProcedure ( Procedure ): def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary csv file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14 def standard_test ( self , binaural = False ): \"\"\"Main function Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False def standard_test_one_ear ( self ): \"\"\"Audiometer for one ear Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False def standard_test_one_freq ( self , freq , retest = False ): \"\"\"Test for one frequency Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True # TODO Wenn Streuung mehr als 10 dB: Vermerk im Audiogramm self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False","title":"StandardProcedure"},{"location":"api/main/#app.main.StandardProcedure.__init__","text":"__init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Standard audiometer process (rising level). Parameters: temp_filename ( str ) \u2013 name of temporary csv file where starting level is stored and future values will be stored signal_length ( int , default: 1 ) \u2013 length of played signal in seconds. Defaults to 1. Source code in app\\model.py 403 404 405 406 407 408 409 410 411 412 413 414 415 def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary csv file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14","title":"__init__"},{"location":"api/main/#app.main.StandardProcedure.standard_test","text":"standard_test ( binaural = False ) Main function Returns: bool \u2013 test successful Source code in app\\model.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 def standard_test ( self , binaural = False ): \"\"\"Main function Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False","title":"standard_test"},{"location":"api/main/#app.main.StandardProcedure.standard_test_one_ear","text":"standard_test_one_ear () Audiometer for one ear Returns: bool \u2013 test successful Source code in app\\model.py 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 def standard_test_one_ear ( self ): \"\"\"Audiometer for one ear Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False","title":"standard_test_one_ear"},{"location":"api/main/#app.main.StandardProcedure.standard_test_one_freq","text":"standard_test_one_freq ( freq , retest = False ) Test for one frequency Parameters: freq ( int ) \u2013 frequency at which hearing is tested retest ( bool , default: False ) \u2013 this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool \u2013 test successful Source code in app\\model.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 def standard_test_one_freq ( self , freq , retest = False ): \"\"\"Test for one frequency Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True # TODO Wenn Streuung mehr als 10 dB: Vermerk im Audiogramm self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False","title":"standard_test_one_freq"},{"location":"api/main/#app.main.create_audiogram","text":"create_audiogram ( freqs , left_values = None , right_values = None , binaural = False , name = 'audiogram.png' , freq_levels = freq_levels , subtitle = None ) Erstellt ein Audiogramm basierend auf den gegebenen Frequenzen und H\u00f6rschwellenwerten mit benutzerdefinierten x-Achsen-Beschriftungen. Parameters: freqs ( list of int ) \u2013 Eine Liste von Frequenzen in Hz. right_values ( list of int , default: None ) \u2013 Eine Liste von H\u00f6rschwellen in dB HL vom rechten Ohr. left_values ( list of int , default: None ) \u2013 Eine Liste von H\u00f6rschwellen in dB HL vom linken Ohr save ( bool ) \u2013 Ob das Diagramm gespeichert werden soll name ( str , default: 'audiogram.png' ) \u2013 Der Name der Datei, wenn das Diagramm gespeichert werden soll Source code in app\\audiogram.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def create_audiogram ( freqs , left_values = None , right_values = None , binaural = False , name = \"audiogram.png\" , freq_levels = freq_levels , subtitle = None ): \"\"\"Erstellt ein Audiogramm basierend auf den gegebenen Frequenzen und H\u00f6rschwellenwerten mit benutzerdefinierten x-Achsen-Beschriftungen. Args: freqs (list of int): Eine Liste von Frequenzen in Hz. right_values (list of int): Eine Liste von H\u00f6rschwellen in dB HL vom rechten Ohr. left_values (list of int): Eine Liste von H\u00f6rschwellen in dB HL vom linken Ohr save (bool): Ob das Diagramm gespeichert werden soll name (str): Der Name der Datei, wenn das Diagramm gespeichert werden soll \"\"\" print ( \"Creating audiogram with frequencies:\" , freqs ) print ( \"Left ear values:\" , left_values ) print ( \"Right ear values:\" , right_values ) fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . axhspan ( - 10 , 20 , facecolor = 'lightgreen' , alpha = 0.2 ) ax . axhspan ( 20 , 40 , facecolor = 'lightskyblue' , alpha = 0.2 ) ax . axhspan ( 40 , 70 , facecolor = 'yellow' , alpha = 0.2 ) ax . axhspan ( 70 , 90 , facecolor = 'orange' , alpha = 0.2 ) ax . axhspan ( 90 , 120 , facecolor = 'red' , alpha = 0.2 ) t1 = ax . text ( 6.4 , 5 , 'Normalh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t2 = ax . text ( 6.4 , 30 , 'Leichte \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t3 = ax . text ( 6.4 , 55 , 'Mittlere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t4 = ax . text ( 6.4 , 80 , 'Schwere \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) t5 = ax . text ( 6.4 , 105 , 'Hochgradige \\n Schwerh\u00f6rigkeit' , ha = 'left' , va = 'center' , fontsize = TEXT_FONT_SIZE ) x_vals = range ( len ( freqs )) target_values = np . array ( list ( freq_levels . values ())) nan_freqs_left = [ freq for i , freq in zip ( left_values , freqs ) if i == 'NaN' ] nan_freqs_right = [ freq for i , freq in zip ( right_values , freqs ) if i == 'NaN' ] nan_text = \"\" nan_t = False if 'NH' in left_values or 'NH' in right_values : heard_i_left , heard_level_left , not_heard_i_left , not_heard_level_left = split_values ( x_vals , left_values , target_values ) heard_i_right , heard_level_right , not_heard_i_right , not_heard_level_right = split_values ( x_vals , right_values , target_values ) if binaural : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_BINAURAL ) ax . plot ( heard_i_left , heard_level_left , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left , marker = NOT_HEARD_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , color = COLOR_BINAURAL , label = 'nicht geh\u00f6rt' ) else : ax . plot ( x_vals , target_values , linestyle = '-' , color = COLOR_RIGHT ) ax . plot ( heard_i_right , heard_level_right , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markerfacecolor = 'none' , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts geh\u00f6rt' ) ax . plot ( not_heard_i_right , not_heard_level_right , marker = NOT_HEARD_RIGHT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'rechts nicht geh\u00f6rt' ) ax . plot ( x_vals , target_values + SHIFT , linestyle = '-' , color = COLOR_LEFT ) ax . plot ( heard_i_left , heard_level_left + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links geh\u00f6rt' ) ax . plot ( not_heard_i_left , not_heard_level_left + SHIFT , marker = NOT_HEARD_LEFT_MARKER , markersize = NOT_HEARD_MARKER_SIZE , linestyle = 'None' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'links nicht geh\u00f6rt' ) else : x_vals_left , left_values = filter_none ( x_vals , left_values ) x_vals_right , right_values = filter_none ( x_vals , right_values ) if binaural : ax . plot ( x_vals_left , left_values , marker = MARKER_BINAURAL , markersize = MARKER_SIZE , linestyle = '-' , color = COLOR_BINAURAL , label = 'binaural' ) else : ax . plot ( x_vals_right , right_values , marker = MARKER_RIGHT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_RIGHT , markeredgewidth = MARKER_EDGE_WIDTH , markerfacecolor = 'none' , label = 'rechtes Ohr' ) ax . plot ( x_vals_left , left_values + SHIFT , marker = MARKER_LEFT , markersize = MARKER_SIZE , linestyle = '-' , linewidth = LINE_WIDTH , color = COLOR_LEFT , markeredgewidth = MARKER_EDGE_WIDTH , label = 'linkes Ohr' ) if nan_freqs_left or nan_freqs_right : and_str = \"\" nan_text = \"Bei folgenden Frequenzen konnte kein Wert ermittelt werden: \\n \" print ( nan_freqs_left , nan_freqs_right ) if nan_freqs_left : nan_text += f \"links: { ', ' . join ( map ( str , nan_freqs_left )) } \" and_str = \"und \" if nan_freqs_right : nan_text += f \" { and_str } rechts: { ', ' . join ( map ( str , nan_freqs_right )) } \" nan_t = ax . text ( 0.05 , - 0.2 , nan_text , transform = ax . transAxes , fontsize = TEXT_FONT_SIZE , ha = 'left' , va = 'top' , bbox = dict ( facecolor = 'None' , edgecolor = 'None' )) ax . invert_yaxis () if subtitle : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE , y = 1.02 ) ax . set_title ( subtitle , fontsize = LABEL_FONT_SIZE , pad = 20 ) else : title = fig . suptitle ( 'Audiogramm' , fontsize = HEADER_SIZE ) ax . set_xlabel ( 'Frequenzen (Hz)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylabel ( 'H\u00f6rschwelle (dB HL)' , fontsize = LABEL_FONT_SIZE ) ax . set_ylim ( 120 , - 10 ) ax . set_xticks ( range ( len ( freqs ))) ax . set_xticklabels ([ f \" { int ( freq ) } \" for freq in freqs ], fontsize = TICK_FONT_SIZE ) ax . set_yticks ( np . arange ( 0 , 121 , 10 )) ax . set_yticklabels ( np . arange ( 0 , 121 , 10 ), fontsize = TICK_FONT_SIZE ) ax . grid ( True , which = 'both' , linestyle = '--' , linewidth = 0.5 ) lgd = ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1.15 , 0.205 ), fontsize = LEGEND_FONT_SIZE , frameon = False , labelspacing = 1 ) if nan_t : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 , nan_t ), bbox_inches = 'tight' ) else : fig . savefig ( name , bbox_extra_artists = ( title , lgd , t1 , t2 , t3 , t4 , t5 ), bbox_inches = 'tight' ) plt . close ( fig )","title":"create_audiogram"},{"location":"api/model/","text":"model Module \u00b6 Calibration \u00b6 Bases: Procedure Source code in app\\model.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 class Calibration ( Procedure ): def __init__ ( self , startlevel = 60 , signal_length = 10 , headphone_name = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ] def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2 def play_one_freq ( self ): \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) def set_calibration_value ( self , measured_value ): \"\"\"Rights the given calibration value into temporary csv file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile ) def finish_calibration ( self ): \"\"\"Makes a permanent csv file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary csv file \"\"\" #TODO csv name self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename ) def stop_playing ( self ): self . ap . stop () __init__ \u00b6 __init__ ( startlevel = 60 , signal_length = 10 , headphone_name = 'Sennheiser_HDA200' , ** additional_data ) Process for calibrating system. Parameters: startlevel ( int , default: 60 ) \u2013 starting level of procedure in dB HL. Defaults to 60. signal_length ( int , default: 10 ) \u2013 length of played signals in seconds. Defaults to 10. Source code in app\\model.py 660 661 662 663 664 665 666 667 668 669 670 def __init__ ( self , startlevel = 60 , signal_length = 10 , headphone_name = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ] finish_calibration \u00b6 finish_calibration () Makes a permanent csv file from the temporary file that overwrites calibration.csv. Parameters: temp_filename ( str ) \u2013 name of temporary csv file Source code in app\\model.py 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 def finish_calibration ( self ): \"\"\"Makes a permanent csv file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary csv file \"\"\" #TODO csv name self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename ) get_next_freq \u00b6 get_next_freq () Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int \u2013 frequency Source code in app\\model.py 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2 play_one_freq \u00b6 play_one_freq () Get the next frequency and play it. Returns: bool \u2013 False if no more frequencies left int \u2013 current frequency float \u2013 expected SPL value in dB Source code in app\\model.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 def play_one_freq ( self ): \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl repeat_freq \u00b6 repeat_freq () Repeats the last played frequency. Source code in app\\model.py 717 718 719 720 721 722 def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) set_calibration_value \u00b6 set_calibration_value ( measured_value ) Rights the given calibration value into temporary csv file Parameters: measured_value ( float ) \u2013 measured SPL value in dB Source code in app\\model.py 725 726 727 728 729 730 731 732 def set_calibration_value ( self , measured_value ): \"\"\"Rights the given calibration value into temporary csv file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile ) Familiarization \u00b6 Bases: Procedure Source code in app\\model.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 class Familiarization ( Procedure ): def __init__ ( self , startlevel = 40 , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True , id = \"\" , ** additional_data ): \"\"\"Familiarization process Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies def get_temp_csv_filename ( self ): return self . tempfile def familiarize ( self ): \"\"\"Main function Returns: bool: familiarization successful \"\"\" while True : self . progress = 0.01 self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 else : self . level += 10 self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True __init__ \u00b6 __init__ ( startlevel = 40 , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True , id = '' , ** additional_data ) Familiarization process Parameters: startlevel ( int , default: 40 ) \u2013 starting level of procedure in dB HL. Defaults to 40. signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. Source code in app\\model.py 332 333 334 335 336 337 338 339 340 341 def __init__ ( self , startlevel = 40 , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True , id = \"\" , ** additional_data ): \"\"\"Familiarization process Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies familiarize \u00b6 familiarize () Main function Returns: bool \u2013 familiarization successful Source code in app\\model.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def familiarize ( self ): \"\"\"Main function Returns: bool: familiarization successful \"\"\" while True : self . progress = 0.01 self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 else : self . level += 10 self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True Procedure \u00b6 Source code in app\\model.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 class Procedure : def __init__ ( self , startlevel , signal_length , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"The parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. Needs to be calibrated! self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = True # TODO turn off for delivery self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = os . getcwd () # Initialize save_path def get_retspl_values ( self , headphone_name ): \"\"\"Read the correct RETSPL values from the retspl.csv file Args: headphone_name (str): exact name of headphone as it appears in csv file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values def get_calibration_values ( self ): \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values def dbhl_to_volume ( self , dbhl ): \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl def key_press ( self , key ): if key == keyboard . Key . space : self . tone_heard = True print ( \"Tone heard!\" ) elif self . test_mode and key == keyboard . Key . right : self . jump_to_end = True def play_tone ( self ): \"\"\"Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times def create_temp_csv ( self , id = \"\" , ** additional_data ): \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (string, optional): id to be stored, that will later be used for naming exported csv file Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name def add_to_temp_csv ( self , value , frequency , side , temp_filename ): \"\"\"Add a value in for a specific frequency to the temporary csv file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary csv file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ]) def get_value_from_csv ( self , frequency , temp_filename , side = 'l' ): \"\"\"Get the value at a specific frequency from the temporary csv file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary csv file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ] def create_final_csv_and_audiogram ( self , temp_filename , binaural = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels ) def parse_dbhl_value ( self , value ): \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None def get_progress ( self ): \"\"\"gets the current progress Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress __init__ \u00b6 __init__ ( startlevel , signal_length , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) The parent class for the familiarization, the main procedure, and the screening. Parameters: startlevel ( float ) \u2013 starting level of procedure in dB HL signal_length ( float ) \u2013 length of played signals in seconds Source code in app\\model.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , startlevel , signal_length , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"The parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. Needs to be calibrated! self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = True # TODO turn off for delivery self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = os . getcwd () # Initialize save_path add_to_temp_csv \u00b6 add_to_temp_csv ( value , frequency , side , temp_filename ) Add a value in for a specific frequency to the temporary csv file Parameters: value ( str ) \u2013 level in dB HL at specific frequency frequency ( str ) \u2013 frequency where value should be added side ( str ) \u2013 specify which ear ('l' or 'r') temp_filename ( str ) \u2013 name of temporary csv file Source code in app\\model.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def add_to_temp_csv ( self , value , frequency , side , temp_filename ): \"\"\"Add a value in for a specific frequency to the temporary csv file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary csv file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ]) create_final_csv_and_audiogram \u00b6 create_final_csv_and_audiogram ( temp_filename , binaural = False ) Creates a permanent CSV file and audiogram from the temporary file. Parameters: temp_filename ( str ) \u2013 Name of the temporary CSV file. binaural ( bool , default: False ) \u2013 If the test is binaural. Source code in app\\model.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 def create_final_csv_and_audiogram ( self , temp_filename , binaural = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels ) create_temp_csv \u00b6 create_temp_csv ( id = '' , ** additional_data ) Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Parameters: id ( string , default: '' ) \u2013 id to be stored, that will later be used for naming exported csv file Returns: str \u2013 name of temporary file Source code in app\\model.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def create_temp_csv ( self , id = \"\" , ** additional_data ): \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (string, optional): id to be stored, that will later be used for naming exported csv file Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name dbhl_to_volume \u00b6 dbhl_to_volume ( dbhl ) Calculate dB HL into absolute numbers. Parameters: dbhl ( float ) \u2013 value in dB HL Returns: float \u2013 value in absolute numbers Source code in app\\model.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def dbhl_to_volume ( self , dbhl ): \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl get_calibration_values \u00b6 get_calibration_values () Read the correct calibration values from the calibration.csv file. Returns: \u2013 dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def get_calibration_values ( self ): \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values get_progress \u00b6 get_progress () gets the current progress Returns: float \u2013 progress value between 0.0 and 1.0 Source code in app\\model.py 320 321 322 323 324 325 326 def get_progress ( self ): \"\"\"gets the current progress Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress get_retspl_values \u00b6 get_retspl_values ( headphone_name ) Read the correct RETSPL values from the retspl.csv file Parameters: headphone_name ( str ) \u2013 exact name of headphone as it appears in csv file Returns: \u2013 dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def get_retspl_values ( self , headphone_name ): \"\"\"Read the correct RETSPL values from the retspl.csv file Args: headphone_name (str): exact name of headphone as it appears in csv file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values get_value_from_csv \u00b6 get_value_from_csv ( frequency , temp_filename , side = 'l' ) Get the value at a specific frequency from the temporary csv file. Parameters: frequency ( str ) \u2013 frequency where value is stored temp_filename ( str ) \u2013 name of temporary csv file side ( str , default: 'l' ) \u2013 specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str \u2013 dB HL value at specified frequency Source code in app\\model.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_value_from_csv ( self , frequency , temp_filename , side = 'l' ): \"\"\"Get the value at a specific frequency from the temporary csv file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary csv file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ] parse_dbhl_value \u00b6 parse_dbhl_value ( value ) Parses the dBHL value from the CSV file. Parameters: value ( str ) \u2013 the value from the CSV file Returns: \u2013 int or None: the parsed value or None if 'NH' Source code in app\\model.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def parse_dbhl_value ( self , value ): \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None play_tone \u00b6 play_tone () Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized). Source code in app\\model.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def play_tone ( self ): \"\"\"Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times ScreeningProcedure \u00b6 Bases: Procedure Source code in app\\model.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 class ScreeningProcedure ( Procedure ): def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14 def screen_test ( self , binaural = False ): \"\"\"main functions Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) def screen_one_ear ( self ): success = [] for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . screen_one_freq ( f ) success . append ( s ) def screen_one_freq ( self , freq ): \"\"\"screening for one frequency Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step __init__ \u00b6 __init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Short screening process to check if subject can hear specific frequencies at certain levels. Parameters: signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. Source code in app\\model.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14 screen_one_freq \u00b6 screen_one_freq ( freq ) screening for one frequency Parameters: freq ( int ) \u2013 frequency to be tested Returns: bool \u2013 tone heard Source code in app\\model.py 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def screen_one_freq ( self , freq ): \"\"\"screening for one frequency Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step screen_test \u00b6 screen_test ( binaural = False ) main functions Returns: bool \u2013 test successful Source code in app\\model.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 def screen_test ( self , binaural = False ): \"\"\"main functions Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) StandardProcedure \u00b6 Bases: Procedure Source code in app\\model.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 class StandardProcedure ( Procedure ): def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary csv file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14 def standard_test ( self , binaural = False ): \"\"\"Main function Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False def standard_test_one_ear ( self ): \"\"\"Audiometer for one ear Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False def standard_test_one_freq ( self , freq , retest = False ): \"\"\"Test for one frequency Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True # TODO Wenn Streuung mehr als 10 dB: Vermerk im Audiogramm self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False __init__ \u00b6 __init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Standard audiometer process (rising level). Parameters: temp_filename ( str ) \u2013 name of temporary csv file where starting level is stored and future values will be stored signal_length ( int , default: 1 ) \u2013 length of played signal in seconds. Defaults to 1. Source code in app\\model.py 403 404 405 406 407 408 409 410 411 412 413 414 415 def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary csv file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14 standard_test \u00b6 standard_test ( binaural = False ) Main function Returns: bool \u2013 test successful Source code in app\\model.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 def standard_test ( self , binaural = False ): \"\"\"Main function Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False standard_test_one_ear \u00b6 standard_test_one_ear () Audiometer for one ear Returns: bool \u2013 test successful Source code in app\\model.py 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 def standard_test_one_ear ( self ): \"\"\"Audiometer for one ear Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False standard_test_one_freq \u00b6 standard_test_one_freq ( freq , retest = False ) Test for one frequency Parameters: freq ( int ) \u2013 frequency at which hearing is tested retest ( bool , default: False ) \u2013 this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool \u2013 test successful Source code in app\\model.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 def standard_test_one_freq ( self , freq , retest = False ): \"\"\"Test for one frequency Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True # TODO Wenn Streuung mehr als 10 dB: Vermerk im Audiogramm self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False","title":"model"},{"location":"api/model/#model-module","text":"","title":"model Module"},{"location":"api/model/#app.model.Calibration","text":"Bases: Procedure Source code in app\\model.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 class Calibration ( Procedure ): def __init__ ( self , startlevel = 60 , signal_length = 10 , headphone_name = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ] def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2 def play_one_freq ( self ): \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) def set_calibration_value ( self , measured_value ): \"\"\"Rights the given calibration value into temporary csv file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile ) def finish_calibration ( self ): \"\"\"Makes a permanent csv file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary csv file \"\"\" #TODO csv name self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename ) def stop_playing ( self ): self . ap . stop ()","title":"Calibration"},{"location":"api/model/#app.model.Calibration.__init__","text":"__init__ ( startlevel = 60 , signal_length = 10 , headphone_name = 'Sennheiser_HDA200' , ** additional_data ) Process for calibrating system. Parameters: startlevel ( int , default: 60 ) \u2013 starting level of procedure in dB HL. Defaults to 60. signal_length ( int , default: 10 ) \u2013 length of played signals in seconds. Defaults to 10. Source code in app\\model.py 660 661 662 663 664 665 666 667 668 669 670 def __init__ ( self , startlevel = 60 , signal_length = 10 , headphone_name = \"Sennheiser_HDA200\" , ** additional_data ): \"\"\"Process for calibrating system. Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 60. signal_length (int, optional): length of played signals in seconds. Defaults to 10. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = False ) self . tempfile = self . create_temp_csv ( id = \"\" , ** additional_data ) # create a temporary file to store level at frequencies self . generator = self . get_next_freq () self . dbspl = self . level + self . retspl [ self . frequency ]","title":"__init__"},{"location":"api/model/#app.model.Calibration.finish_calibration","text":"finish_calibration () Makes a permanent csv file from the temporary file that overwrites calibration.csv. Parameters: temp_filename ( str ) \u2013 name of temporary csv file Source code in app\\model.py 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 def finish_calibration ( self ): \"\"\"Makes a permanent csv file from the temporary file that overwrites calibration.csv. Args: temp_filename (str): name of temporary csv file \"\"\" #TODO csv name self . ap . stop () # read temp file with open ( self . tempfile , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) filename = \"calibration.csv\" with open ( filename , mode = 'w' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( \"Datei gespeicher als \" + filename )","title":"finish_calibration"},{"location":"api/model/#app.model.Calibration.get_next_freq","text":"get_next_freq () Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int \u2013 frequency Source code in app\\model.py 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 def get_next_freq ( self ): \"\"\"Generator that goes through all frequencies twice. Changes self.side to 'r' after going through all frequencies the first time. Yields: int: frequency \"\"\" self . side = 'l' frequency = 125 while frequency <= 8000 : yield frequency frequency *= 2 frequency = 125 self . side = 'r' while frequency <= 8000 : yield frequency frequency *= 2","title":"get_next_freq"},{"location":"api/model/#app.model.Calibration.play_one_freq","text":"play_one_freq () Get the next frequency and play it. Returns: bool \u2013 False if no more frequencies left int \u2013 current frequency float \u2013 expected SPL value in dB Source code in app\\model.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 def play_one_freq ( self ): \"\"\"Get the next frequency and play it. Returns: bool: False if no more frequencies left int: current frequency float: expected SPL value in dB \"\"\" self . ap . stop () try : self . frequency = next ( self . generator ) except : return False , self . frequency , self . dbspl self . dbspl = self . level + self . retspl [ self . frequency ] print ( f \"Side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) if self . frequency >= 8000 and self . side == 'r' : return False , self . frequency , self . dbspl else : return True , self . frequency , self . dbspl","title":"play_one_freq"},{"location":"api/model/#app.model.Calibration.repeat_freq","text":"repeat_freq () Repeats the last played frequency. Source code in app\\model.py 717 718 719 720 721 722 def repeat_freq ( self ): \"\"\"Repeats the last played frequency. \"\"\" self . ap . stop () print ( f \" Repeating side { self . side } at { self . frequency } Hz: The SPL value should be { self . dbspl } dB.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side )","title":"repeat_freq"},{"location":"api/model/#app.model.Calibration.set_calibration_value","text":"set_calibration_value ( measured_value ) Rights the given calibration value into temporary csv file Parameters: measured_value ( float ) \u2013 measured SPL value in dB Source code in app\\model.py 725 726 727 728 729 730 731 732 def set_calibration_value ( self , measured_value ): \"\"\"Rights the given calibration value into temporary csv file Args: measured_value (float): measured SPL value in dB \"\"\" value = measured_value - self . dbspl self . add_to_temp_csv ( str ( value ), str ( self . frequency ), self . side , self . tempfile )","title":"set_calibration_value"},{"location":"api/model/#app.model.Familiarization","text":"Bases: Procedure Source code in app\\model.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 class Familiarization ( Procedure ): def __init__ ( self , startlevel = 40 , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True , id = \"\" , ** additional_data ): \"\"\"Familiarization process Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies def get_temp_csv_filename ( self ): return self . tempfile def familiarize ( self ): \"\"\"Main function Returns: bool: familiarization successful \"\"\" while True : self . progress = 0.01 self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 else : self . level += 10 self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True","title":"Familiarization"},{"location":"api/model/#app.model.Familiarization.__init__","text":"__init__ ( startlevel = 40 , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True , id = '' , ** additional_data ) Familiarization process Parameters: startlevel ( int , default: 40 ) \u2013 starting level of procedure in dB HL. Defaults to 40. signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. Source code in app\\model.py 332 333 334 335 336 337 338 339 340 341 def __init__ ( self , startlevel = 40 , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True , id = \"\" , ** additional_data ): \"\"\"Familiarization process Args: startlevel (int, optional): starting level of procedure in dB HL. Defaults to 40. signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . fails = 0 # number of times familiarization failed self . tempfile = self . create_temp_csv ( id = id , ** additional_data ) # create a temporary file to store level at frequencies","title":"__init__"},{"location":"api/model/#app.model.Familiarization.familiarize","text":"familiarize () Main function Returns: bool \u2013 familiarization successful Source code in app\\model.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def familiarize ( self ): \"\"\"Main function Returns: bool: familiarization successful \"\"\" while True : self . progress = 0.01 self . tone_heard = True # first loop (always -20dBHL) while self . tone_heard : self . play_tone () if self . jump_to_end == True : for f in self . freq_bands : self . add_to_temp_csv ( 20 , f , 'lr' , self . get_temp_csv_filename ()) return True if self . tone_heard : self . level -= 20 else : self . level += 10 self . progress = 1 / 3 # second loop (always +10dBHL) while not self . tone_heard : self . play_tone () if not self . tone_heard : self . level += 10 self . progress = 2 / 3 # replay tone with same level self . play_tone () if not self . tone_heard : self . fails += 1 if self . fails >= 2 : self . progress = 1 print ( \"Familiarization unsuccessful. Please read rules and start again.\" ) return False else : self . level = self . startlevel else : print ( \"Familiarization successful!\" ) self . progress = 1 self . add_to_temp_csv ( self . level , '1000' , 'l' , self . tempfile ) return True","title":"familiarize"},{"location":"api/model/#app.model.Procedure","text":"Source code in app\\model.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 class Procedure : def __init__ ( self , startlevel , signal_length , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"The parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. Needs to be calibrated! self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = True # TODO turn off for delivery self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = os . getcwd () # Initialize save_path def get_retspl_values ( self , headphone_name ): \"\"\"Read the correct RETSPL values from the retspl.csv file Args: headphone_name (str): exact name of headphone as it appears in csv file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values def get_calibration_values ( self ): \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values def dbhl_to_volume ( self , dbhl ): \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl def key_press ( self , key ): if key == keyboard . Key . space : self . tone_heard = True print ( \"Tone heard!\" ) elif self . test_mode and key == keyboard . Key . right : self . jump_to_end = True def play_tone ( self ): \"\"\"Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times def create_temp_csv ( self , id = \"\" , ** additional_data ): \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (string, optional): id to be stored, that will later be used for naming exported csv file Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name def add_to_temp_csv ( self , value , frequency , side , temp_filename ): \"\"\"Add a value in for a specific frequency to the temporary csv file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary csv file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ]) def get_value_from_csv ( self , frequency , temp_filename , side = 'l' ): \"\"\"Get the value at a specific frequency from the temporary csv file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary csv file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ] def create_final_csv_and_audiogram ( self , temp_filename , binaural = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels ) def parse_dbhl_value ( self , value ): \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None def get_progress ( self ): \"\"\"gets the current progress Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress","title":"Procedure"},{"location":"api/model/#app.model.Procedure.__init__","text":"__init__ ( startlevel , signal_length , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) The parent class for the familiarization, the main procedure, and the screening. Parameters: startlevel ( float ) \u2013 starting level of procedure in dB HL signal_length ( float ) \u2013 length of played signals in seconds Source code in app\\model.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , startlevel , signal_length , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"The parent class for the familiarization, the main procedure, and the screening. Args: startlevel (float): starting level of procedure in dB HL signal_length (float): length of played signals in seconds \"\"\" self . ap = AudioPlayer () self . startlevel = startlevel self . level = startlevel self . signal_length = signal_length self . frequency = 1000 self . zero_dbhl = 0.000005 # zero_dbhl in absolute numbers. Needs to be calibrated! self . tone_heard = False self . freq_bands = [ '125' , '250' , '500' , '1000' , '2000' , '4000' , '8000' ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } # screening levels self . side = 'l' self . test_mode = True # TODO turn off for delivery self . jump_to_end = False self . use_calibration = calibrate self . progress = 0 # value for progressbar self . retspl = self . get_retspl_values ( headphone_name ) self . calibration = self . get_calibration_values () self . save_path = os . getcwd () # Initialize save_path","title":"__init__"},{"location":"api/model/#app.model.Procedure.add_to_temp_csv","text":"add_to_temp_csv ( value , frequency , side , temp_filename ) Add a value in for a specific frequency to the temporary csv file Parameters: value ( str ) \u2013 level in dB HL at specific frequency frequency ( str ) \u2013 frequency where value should be added side ( str ) \u2013 specify which ear ('l' or 'r') temp_filename ( str ) \u2013 name of temporary csv file Source code in app\\model.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def add_to_temp_csv ( self , value , frequency , side , temp_filename ): \"\"\"Add a value in for a specific frequency to the temporary csv file Args: value (str): level in dB HL at specific frequency frequency (str): frequency where value should be added side (str): specify which ear ('l' or 'r') temp_filename (str): name of temporary csv file \"\"\" # Read all rows from the CSV file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Update the relevant row based on the side parameter if side == 'l' : rows [ 0 ][ frequency ] = value elif side == 'r' : rows [ 1 ][ frequency ] = value else : rows [ 0 ][ frequency ] = value rows [ 1 ][ frequency ] = value # Write all rows back to the CSV file with open ( temp_filename , mode = 'w' , newline = '' ) as temp_file : dict_writer = csv . DictWriter ( temp_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) print ( rows [ 0 ], rows [ 1 ]) for row in rows [ 2 :]: print ( row [ '125' ], row [ '250' ])","title":"add_to_temp_csv"},{"location":"api/model/#app.model.Procedure.create_final_csv_and_audiogram","text":"create_final_csv_and_audiogram ( temp_filename , binaural = False ) Creates a permanent CSV file and audiogram from the temporary file. Parameters: temp_filename ( str ) \u2013 Name of the temporary CSV file. binaural ( bool , default: False ) \u2013 If the test is binaural. Source code in app\\model.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 def create_final_csv_and_audiogram ( self , temp_filename , binaural = False ): \"\"\"Creates a permanent CSV file and audiogram from the temporary file. Args: temp_filename (str): Name of the temporary CSV file. binaural (bool): If the test is binaural. \"\"\" # Read the temporary file with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) rows = list ( dict_reader ) # Get date and time now = datetime . now () date_str = now . strftime ( \"%Y%m %d _%H%M%S\" ) try : id = rows [ 2 ][ '250' ] except : id = \"missingID\" # Create folder for the subject folder_name = os . path . join ( self . save_path , f \" { id } \" ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) final_csv_filename = os . path . join ( folder_name , f \" { id } _audiogramm_ { date_str } .csv\" ) # Write the permanent CSV file with open ( final_csv_filename , mode = 'x' , newline = '' ) as final_file : dict_writer = csv . DictWriter ( final_file , fieldnames = self . freq_bands ) dict_writer . writeheader () dict_writer . writerows ( rows ) freqs = [ int ( x ) for x in self . freq_bands ] left_levels = [ self . parse_dbhl_value ( rows [ 0 ][ freq ]) for freq in self . freq_bands ] right_levels = [ self . parse_dbhl_value ( rows [ 1 ][ freq ]) for freq in self . freq_bands ] # Generate the audiogram filename audiogram_filename = os . path . join ( folder_name , f \" { id } _audiogram_ { date_str } .png\" ) print ( left_levels , right_levels ) create_audiogram ( freqs , left_levels , right_levels , binaural = binaural , name = audiogram_filename , freq_levels = self . freq_levels )","title":"create_final_csv_and_audiogram"},{"location":"api/model/#app.model.Procedure.create_temp_csv","text":"create_temp_csv ( id = '' , ** additional_data ) Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Parameters: id ( string , default: '' ) \u2013 id to be stored, that will later be used for naming exported csv file Returns: str \u2013 name of temporary file Source code in app\\model.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def create_temp_csv ( self , id = \"\" , ** additional_data ): \"\"\"Creates a temporary CSV file with the relevant frequency bands as a header and NaN in the second and third line as starting value for each band. (second line: left ear, third line: right ear) ID and additional data will be stored in subsequent lines in the format: key, value. Args: id (string, optional): id to be stored, that will later be used for naming exported csv file Returns: str: name of temporary file \"\"\" with tfile . NamedTemporaryFile ( mode = 'w+' , delete = False , newline = '' , suffix = '.csv' ) as temp_file : # Define the CSV writer csv_writer = csv . writer ( temp_file ) # Write header csv_writer . writerow ( self . freq_bands ) # Write value NaN for each frequency in second and third row csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) csv_writer . writerow ([ 'NaN' for _ in range ( len ( self . freq_bands ))]) # Write id and additional data if id : csv_writer . writerow ([ \"id\" , id ]) if additional_data : for key , value in additional_data . items (): csv_writer . writerow ([ key , value ]) return temp_file . name","title":"create_temp_csv"},{"location":"api/model/#app.model.Procedure.dbhl_to_volume","text":"dbhl_to_volume ( dbhl ) Calculate dB HL into absolute numbers. Parameters: dbhl ( float ) \u2013 value in dB HL Returns: float \u2013 value in absolute numbers Source code in app\\model.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def dbhl_to_volume ( self , dbhl ): \"\"\"Calculate dB HL into absolute numbers. Args: dbhl (float): value in dB HL Returns: float: value in absolute numbers \"\"\" if self . use_calibration : # add RETSPL and values from calibration file at that frequency dbspl = dbhl + self . retspl [ self . frequency ] - self . calibration [ self . side ][ self . frequency ] else : # only add RETSPL dbspl = dbhl + self . retspl [ self . frequency ] return self . zero_dbhl * 10 ** ( dbspl / 20 ) # calculate from dB to absolute numbers using the reference point self.zero_dbhl","title":"dbhl_to_volume"},{"location":"api/model/#app.model.Procedure.get_calibration_values","text":"get_calibration_values () Read the correct calibration values from the calibration.csv file. Returns: \u2013 dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def get_calibration_values ( self ): \"\"\"Read the correct calibration values from the calibration.csv file. Returns: dict of int:float : calibration values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'calibration.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) calibration_str_values_l = next ( reader ) calibration_str_values_r = next ( reader ) # convert dictionary to int:float and put into extra dictionary for left and right side calibration_values = {} calibration_values [ 'l' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_l . items ()} calibration_values [ 'r' ] = { int ( k ): float ( v ) for k , v in calibration_str_values_r . items ()} # if both sides are used, calculate average between both sides calibration_values [ 'lr' ] = {} for k , v in calibration_values [ 'l' ] . items (): calibration_values [ 'lr' ][ k ] = ( 10 * np . log10 (( 10 ** ( v / 10 ) + 10 ** ( calibration_values [ 'r' ][ k ] / 10 )) / 2 )) except Exception as e : print ( f \"Error reading the file: { e } \" ) return print ( calibration_values ) return calibration_values","title":"get_calibration_values"},{"location":"api/model/#app.model.Procedure.get_progress","text":"get_progress () gets the current progress Returns: float \u2013 progress value between 0.0 and 1.0 Source code in app\\model.py 320 321 322 323 324 325 326 def get_progress ( self ): \"\"\"gets the current progress Returns: float: progress value between 0.0 and 1.0 \"\"\" return self . progress","title":"get_progress"},{"location":"api/model/#app.model.Procedure.get_retspl_values","text":"get_retspl_values ( headphone_name ) Read the correct RETSPL values from the retspl.csv file Parameters: headphone_name ( str ) \u2013 exact name of headphone as it appears in csv file Returns: \u2013 dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz Source code in app\\model.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def get_retspl_values ( self , headphone_name ): \"\"\"Read the correct RETSPL values from the retspl.csv file Args: headphone_name (str): exact name of headphone as it appears in csv file Returns: dict of int:float : RETSPL values for each frequency band from 125 Hz to 8000 Hz \"\"\" file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): print ( f \"File ' { file_name } ' not found.\" ) return retspl_values = {} try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : if row [ 'headphone_model' ] == headphone_name : retspl_values [ int ( row [ 'frequency' ])] = float ( row [ 'retspl' ]) except Exception as e : print ( f \"Error reading the file: { e } \" ) return # Check if the headphone model was found if not retspl_values : print ( f \"Headphone model ' { headphone_name } ' not found.\" ) return print ( retspl_values ) return retspl_values","title":"get_retspl_values"},{"location":"api/model/#app.model.Procedure.get_value_from_csv","text":"get_value_from_csv ( frequency , temp_filename , side = 'l' ) Get the value at a specific frequency from the temporary csv file. Parameters: frequency ( str ) \u2013 frequency where value is stored temp_filename ( str ) \u2013 name of temporary csv file side ( str , default: 'l' ) \u2013 specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str \u2013 dB HL value at specified frequency Source code in app\\model.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_value_from_csv ( self , frequency , temp_filename , side = 'l' ): \"\"\"Get the value at a specific frequency from the temporary csv file. Args: frequency (str): frequency where value is stored temp_filename (str): name of temporary csv file side (str, optional): specify which ear ('l' or 'r'). Defaults to 'l'. Returns: str: dB HL value at specified frequency \"\"\" with open ( temp_filename , mode = 'r' , newline = '' ) as temp_file : dict_reader = csv . DictReader ( temp_file ) freq_dict = next ( dict_reader ) # left ear if side == 'r' : # go to next line if right side freq_dict = next ( dict_reader ) return freq_dict [ frequency ]","title":"get_value_from_csv"},{"location":"api/model/#app.model.Procedure.parse_dbhl_value","text":"parse_dbhl_value ( value ) Parses the dBHL value from the CSV file. Parameters: value ( str ) \u2013 the value from the CSV file Returns: \u2013 int or None: the parsed value or None if 'NH' Source code in app\\model.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def parse_dbhl_value ( self , value ): \"\"\"Parses the dBHL value from the CSV file. Args: value (str): the value from the CSV file Returns: int or None: the parsed value or None if 'NH' \"\"\" if value == 'NH' : return 'NH' try : return int ( value ) except ValueError : return None","title":"parse_dbhl_value"},{"location":"api/model/#app.model.Procedure.play_tone","text":"play_tone () Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized). Source code in app\\model.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def play_tone ( self ): \"\"\"Set tone_heard to False, play beep, then wait max 4s for keypress. If key is pressed, set tone_heard to True. Then wait for around about 2s (randomized). \"\"\" self . tone_heard = False print ( self . frequency , \"Hz - playing tone at\" , self . level , \"dBHL.\" ) self . ap . play_beep ( self . frequency , self . dbhl_to_volume ( self . level ), self . signal_length , self . side ) listener = keyboard . Listener ( on_press = self . key_press , on_release = None ) listener . start () current_wait_time = 0 max_wait_time = 4000 # in ms step_size = 50 # in ms while current_wait_time < max_wait_time and not self . tone_heard : # wait for keypress time . sleep ( step_size / 1000 ) current_wait_time += step_size listener . stop () self . ap . stop () if not self . tone_heard : print ( \"Tone not heard :(\" ) else : sleep_time = random . uniform ( 1 , 2.5 ) # random wait time between 1 and 2.5 time . sleep ( sleep_time ) # wait before next tone is played. #TODO test times","title":"play_tone"},{"location":"api/model/#app.model.ScreeningProcedure","text":"Bases: Procedure Source code in app\\model.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 class ScreeningProcedure ( Procedure ): def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14 def screen_test ( self , binaural = False ): \"\"\"main functions Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) def screen_one_ear ( self ): success = [] for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . screen_one_freq ( f ) success . append ( s ) def screen_one_freq ( self , freq ): \"\"\"screening for one frequency Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step","title":"ScreeningProcedure"},{"location":"api/model/#app.model.ScreeningProcedure.__init__","text":"__init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Short screening process to check if subject can hear specific frequencies at certain levels. Parameters: signal_length ( int , default: 1 ) \u2013 length of played signals in seconds. Defaults to 1. Source code in app\\model.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Short screening process to check if subject can hear specific frequencies at certain levels. Args: signal_length (int, optional): length of played signals in seconds. Defaults to 1. \"\"\" super () . __init__ ( startlevel = 0 , signal_length = signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] #TODO das als default, aber variabel in der GUI? self . freq_levels = { 125 : 20 , 250 : 20 , 500 : 20 , 1000 : 20 , 2000 : 20 , 4000 : 20 , 8000 : 20 } self . progress_step = 1 / 14","title":"__init__"},{"location":"api/model/#app.model.ScreeningProcedure.screen_one_freq","text":"screen_one_freq ( freq ) screening for one frequency Parameters: freq ( int ) \u2013 frequency to be tested Returns: bool \u2013 tone heard Source code in app\\model.py 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def screen_one_freq ( self , freq ): \"\"\"screening for one frequency Args: freq (int): frequency to be tested Returns: bool: tone heard \"\"\" self . frequency = freq self . level = self . freq_levels [ freq ] self . tone_heard = False self . num_heard = 0 for i in range ( 2 ): self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard == 1 : self . play_tone () if self . tone_heard : self . num_heard += 1 if self . num_heard >= 2 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step return self . add_to_temp_csv ( 'NH' , str ( self . frequency ), self . side , self . temp_filename ) self . progress += self . progress_step","title":"screen_one_freq"},{"location":"api/model/#app.model.ScreeningProcedure.screen_test","text":"screen_test ( binaural = False ) main functions Returns: bool \u2013 test successful Source code in app\\model.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 def screen_test ( self , binaural = False ): \"\"\"main functions Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' self . screen_one_ear () self . side = 'r' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) return True if binaural : self . progress_step = 1 / 7 self . side = 'lr' self . screen_one_ear () self . progress = 1 self . create_final_csv_and_audiogram ( self . temp_filename , binaural )","title":"screen_test"},{"location":"api/model/#app.model.StandardProcedure","text":"Bases: Procedure Source code in app\\model.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 class StandardProcedure ( Procedure ): def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary csv file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14 def standard_test ( self , binaural = False ): \"\"\"Main function Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False def standard_test_one_ear ( self ): \"\"\"Audiometer for one ear Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False def standard_test_one_freq ( self , freq , retest = False ): \"\"\"Test for one frequency Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True # TODO Wenn Streuung mehr als 10 dB: Vermerk im Audiogramm self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False","title":"StandardProcedure"},{"location":"api/model/#app.model.StandardProcedure.__init__","text":"__init__ ( temp_filename , signal_length = 1 , headphone_name = 'Sennheiser_HDA200' , calibrate = True ) Standard audiometer process (rising level). Parameters: temp_filename ( str ) \u2013 name of temporary csv file where starting level is stored and future values will be stored signal_length ( int , default: 1 ) \u2013 length of played signal in seconds. Defaults to 1. Source code in app\\model.py 403 404 405 406 407 408 409 410 411 412 413 414 415 def __init__ ( self , temp_filename , signal_length = 1 , headphone_name = \"Sennheiser_HDA200\" , calibrate = True ): \"\"\"Standard audiometer process (rising level). Args: temp_filename (str): name of temporary csv file where starting level is stored and future values will be stored signal_length (int, optional): length of played signal in seconds. Defaults to 1. \"\"\" startlevel = int ( self . get_value_from_csv ( '1000' , temp_filename )) - 10 # 10 dB under level from familiarization super () . __init__ ( startlevel , signal_length , headphone_name = headphone_name , calibrate = calibrate ) self . temp_filename = temp_filename self . freq_order = [ 1000 , 2000 , 4000 , 8000 , 500 , 250 , 125 ] # order in which frequencies are tested self . progress_step = 0.95 / 14","title":"__init__"},{"location":"api/model/#app.model.StandardProcedure.standard_test","text":"standard_test ( binaural = False ) Main function Returns: bool \u2013 test successful Source code in app\\model.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 def standard_test ( self , binaural = False ): \"\"\"Main function Returns: bool: test successful \"\"\" if not binaural : self . side = 'l' success_l = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True self . side = 'r' success_r = self . standard_test_one_ear () if success_l and success_r : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if binaural : self . progress_step = 0.95 / 7 self . side = 'lr' success_lr = self . standard_test_one_ear () if self . test_mode == True and self . jump_to_end == True : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True if success_lr : self . create_final_csv_and_audiogram ( self . temp_filename , binaural ) self . progress = 1 return True return False","title":"standard_test"},{"location":"api/model/#app.model.StandardProcedure.standard_test_one_ear","text":"standard_test_one_ear () Audiometer for one ear Returns: bool \u2013 test successful Source code in app\\model.py 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 def standard_test_one_ear ( self ): \"\"\"Audiometer for one ear Returns: bool: test successful \"\"\" success = [] self . tone_heard = False self . frequency = 1000 self . level = self . startlevel # Step 1 (raise tone in 5 dB steps until it is heard) while not self . tone_heard : self . play_tone () if self . test_mode == True and self . jump_to_end == True : return True if not self . tone_heard : self . level += 5 self . startlevel = self . level print ( f \"Starting level: { self . startlevel } dBHL\" ) # test every frequency for f in self . freq_order : print ( f \"Testing frequency { f } Hz\" ) s = self . standard_test_one_freq ( f ) if self . test_mode == True and self . jump_to_end == True : return True success . append ( s ) # retest 1000 Hz (and more frequencies if discrepancy is too high) for f in self . freq_order : print ( f \"Retest at frequency { f } Hz\" ) s = self . standard_test_one_freq ( f , retest = True ) if s : break if all ( success ): return True else : return False","title":"standard_test_one_ear"},{"location":"api/model/#app.model.StandardProcedure.standard_test_one_freq","text":"standard_test_one_freq ( freq , retest = False ) Test for one frequency Parameters: freq ( int ) \u2013 frequency at which hearing is tested retest ( bool , default: False ) \u2013 this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool \u2013 test successful Source code in app\\model.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 def standard_test_one_freq ( self , freq , retest = False ): \"\"\"Test for one frequency Args: freq (int): frequency at which hearing is tested retest (bool, optional): this is the retest at the end of step 3 according to DIN. Defaults to False Returns: bool: test successful \"\"\" self . tone_heard = True self . frequency = freq self . level = self . startlevel # Step 2 answers = [] tries = 0 while tries < 6 : # reduce in 10dB steps until no answer while self . tone_heard : self . level -= 10 self . play_tone () # raise in 5 dB steps until answer while not self . tone_heard : self . level += 5 self . play_tone () tries += 1 answers . append ( self . level ) print ( f \"Try nr { tries } : level: { self . level } \" ) if answers . count ( self . level ) >= 2 : if retest : if abs ( self . level - int ( self . get_value_from_csv ( str ( self . frequency ), self . temp_filename , self . side ))) > 5 : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return False else : self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) return True # TODO Wenn Streuung mehr als 10 dB: Vermerk im Audiogramm self . add_to_temp_csv ( str ( self . level ), str ( self . frequency ), self . side , self . temp_filename ) if self . progress < 0.95 - self . progress_step : self . progress += self . progress_step return True # no two same answers in three tries if tries == 3 : self . level += 10 self . play_tone () answers = [] print ( \"Something went wrong, please try from the beginning again.\" ) return False","title":"standard_test_one_freq"},{"location":"api/ui/","text":"ui Module \u00b6 App \u00b6 Bases: Window Source code in app\\ui.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class App ( tb . Window ): def __init__ ( self , familiarization_func , program_funcs : dict , calibration_funcs : list , progress_func ): \"\"\"Main application window. Contains all pages and controls the flow of the program. Args: familiarization_func (function): function to be called for familiarization audiogram_func (function): function to be called for creating audiogram program_funcs (dict of str:function): function(s) to be called for the main program calibration_funcs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level \"\"\" super () . __init__ ( themename = LIGHT_THEME ) # General theme settings self . title ( \"Sound Player\" ) self . geometry ( GEOMETRY ) self . minsize ( 650 , 650 ) self . attributes ( '-fullscreen' , True ) self . bind ( \"<Escape>\" , self . exit_fullscreen ) self . save_path = os . path . join ( os . getcwd ()) # Ensure the default save path exists os . makedirs ( self . save_path , exist_ok = True ) #self.set_icon(\"app/00_TUBerlin_Logo_rot.jpg\") change the icon maybe? #TODO self . tk . call ( 'tk' , 'scaling' , 2.0 ) # Adjust for high-DPI displays # Dictionary to store all pages self . program_funcs = program_funcs self . frames = {} self . binaural_test = False # Interactive Pages for F in ( MainMenu , FamiliarizationPage , ProgramPage , ResultPage ): frame = F ( self ) self . frames [ F ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Calibration separately to give it its functions frame = CalibrationPage ( self , calibration_funcs ) self . frames [ CalibrationPage ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during familiarization frame = DuringFamiliarizationView ( self , familiarization_func , progress_func ) self . frames [ DuringFamiliarizationView ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during programs for name , program_func in program_funcs . items (): frame = DuringProcedureView ( self , program_func , progress_func , text = \"Programm l\u00e4uft...\" ) self . frames [ name ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Show MainMenu first self . show_frame ( MainMenu ) # Create menubar self . create_menubar () # Variable for threading self . process_done = False # Override the close button protocol self . protocol ( \"WM_DELETE_WINDOW\" , self . on_closing ) self . grid_rowconfigure ( 0 , weight = 1 ) self . grid_columnconfigure ( 0 , weight = 1 ) def create_menubar ( self ): \"\"\"Create a menubar with options for changing the theme and exiting the program\"\"\" menubar = tk . Menu ( self ) self . config ( menu = menubar ) file_menu = tk . Menu ( menubar , tearoff = 0 ) file_menu . add_command ( label = \"Startseite\" , command = lambda : self . show_frame ( MainMenu )) file_menu . add_command ( label = \"Speicherort \u00e4ndern\" , command = self . change_save_path ) # Settings for changing the theme Link: lighthttps://ttkbootstrap.readthedocs.io/en/latest/themes/dark/ ChangeTheme = tk . Menu ( file_menu , tearoff = 0 ) ChangeTheme . add_command ( label = \"light\" , command = lambda : self . change_theme ( LIGHT_THEME )) ChangeTheme . add_command ( label = \"dark\" , command = lambda : self . change_theme ( DARK_THEME )) file_menu . add_cascade ( label = \"Theme \u00e4ndern\" , menu = ChangeTheme ) file_menu . add_separator () file_menu . add_command ( label = \"Programm beenden\" , command = self . on_closing ) menubar . add_cascade ( label = \"Einstellungen\" , menu = file_menu ) def change_theme ( self , theme_name ): \"\"\"Change to the specified theme\"\"\" current_theme = self . style . theme_use () if current_theme == theme_name : messagebox . showwarning ( \"Oops..\" , \"Dieses Theme wird bereits verwendet.\" ) else : self . style . theme_use ( theme_name ) def exit_fullscreen ( self , event = None ): \"\"\"Exit fullscreen mode\"\"\" self . attributes ( '-fullscreen' , False ) def set_icon ( self , path ): \"\"\"Set the window icon using Pillow\"\"\" img = Image . open ( path ) photo = ImageTk . PhotoImage ( img ) self . iconphoto ( False , photo ) def show_frame ( self , page ): \"\"\"Show a frame for the given page name Args: page(class): class of the page to be shown \"\"\" frame = self . frames [ page ] frame . tkraise () def wait_for_process ( self , process , callback ): \"\"\"Starts a process in a new thread and calls a callback function when the process is done. Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" t = threading . Thread ( target = self . run_process , args = ( process , callback )) t . daemon = True t . start () def run_process ( self , process , callback ): \"\"\"Runs a process and calls a callback function when the process is done Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" process () self . process_done = True self . after ( 100 , callback ) def change_save_path ( self ): \"\"\"Ask the user to select a folder to save the files\"\"\" new_path = filedialog . askdirectory ( title = \"Select Folder to Save Files\" ) if new_path : self . save_path = new_path messagebox . showinfo ( \"Speicherort ge\u00e4ndert\" , f \"Neuer Speicherort: { self . save_path } \" ) def on_closing ( self ): \"\"\"Ask for confirmation before closing the program\"\"\" if messagebox . askyesno ( title = \"Quit\" , message = \"M\u00f6chten Sie wirklich das Programm beenden?\" ): self . destroy () def get_images_in_path ( self , directory , image_extensions = [ \".png\" , \".jpg\" , \".jpeg\" , \".gif\" , \".bmp\" ]): \"\"\" Get a list of image files in the specified directory. Args: directory (str): The path to the directory to check. image_extensions (list): List of image file extensions to check for. Returns: list: List of image file paths if any image files are found, False otherwise. \"\"\" if not os . path . exists ( directory ): return False image_files = [ os . path . join ( directory , file ) for file in os . listdir ( directory ) if any ( file . lower () . endswith ( ext ) for ext in image_extensions )] return image_files if image_files else False __init__ \u00b6 __init__ ( familiarization_func , program_funcs , calibration_funcs , progress_func ) Main application window. Contains all pages and controls the flow of the program. Parameters: familiarization_func ( function ) \u2013 function to be called for familiarization audiogram_func ( function ) \u2013 function to be called for creating audiogram program_funcs ( dict of str ) \u2013 function): function(s) to be called for the main program calibration_funcs ( list function ) \u2013 list of function(s) for calibration in this order: start, next, repeat, stop, set_level Source code in app\\ui.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def __init__ ( self , familiarization_func , program_funcs : dict , calibration_funcs : list , progress_func ): \"\"\"Main application window. Contains all pages and controls the flow of the program. Args: familiarization_func (function): function to be called for familiarization audiogram_func (function): function to be called for creating audiogram program_funcs (dict of str:function): function(s) to be called for the main program calibration_funcs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level \"\"\" super () . __init__ ( themename = LIGHT_THEME ) # General theme settings self . title ( \"Sound Player\" ) self . geometry ( GEOMETRY ) self . minsize ( 650 , 650 ) self . attributes ( '-fullscreen' , True ) self . bind ( \"<Escape>\" , self . exit_fullscreen ) self . save_path = os . path . join ( os . getcwd ()) # Ensure the default save path exists os . makedirs ( self . save_path , exist_ok = True ) #self.set_icon(\"app/00_TUBerlin_Logo_rot.jpg\") change the icon maybe? #TODO self . tk . call ( 'tk' , 'scaling' , 2.0 ) # Adjust for high-DPI displays # Dictionary to store all pages self . program_funcs = program_funcs self . frames = {} self . binaural_test = False # Interactive Pages for F in ( MainMenu , FamiliarizationPage , ProgramPage , ResultPage ): frame = F ( self ) self . frames [ F ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Calibration separately to give it its functions frame = CalibrationPage ( self , calibration_funcs ) self . frames [ CalibrationPage ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during familiarization frame = DuringFamiliarizationView ( self , familiarization_func , progress_func ) self . frames [ DuringFamiliarizationView ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during programs for name , program_func in program_funcs . items (): frame = DuringProcedureView ( self , program_func , progress_func , text = \"Programm l\u00e4uft...\" ) self . frames [ name ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Show MainMenu first self . show_frame ( MainMenu ) # Create menubar self . create_menubar () # Variable for threading self . process_done = False # Override the close button protocol self . protocol ( \"WM_DELETE_WINDOW\" , self . on_closing ) self . grid_rowconfigure ( 0 , weight = 1 ) self . grid_columnconfigure ( 0 , weight = 1 ) change_save_path \u00b6 change_save_path () Ask the user to select a folder to save the files Source code in app\\ui.py 183 184 185 186 187 188 def change_save_path ( self ): \"\"\"Ask the user to select a folder to save the files\"\"\" new_path = filedialog . askdirectory ( title = \"Select Folder to Save Files\" ) if new_path : self . save_path = new_path messagebox . showinfo ( \"Speicherort ge\u00e4ndert\" , f \"Neuer Speicherort: { self . save_path } \" ) change_theme \u00b6 change_theme ( theme_name ) Change to the specified theme Source code in app\\ui.py 127 128 129 130 131 132 133 134 def change_theme ( self , theme_name ): \"\"\"Change to the specified theme\"\"\" current_theme = self . style . theme_use () if current_theme == theme_name : messagebox . showwarning ( \"Oops..\" , \"Dieses Theme wird bereits verwendet.\" ) else : self . style . theme_use ( theme_name ) create_menubar \u00b6 create_menubar () Create a menubar with options for changing the theme and exiting the program Source code in app\\ui.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def create_menubar ( self ): \"\"\"Create a menubar with options for changing the theme and exiting the program\"\"\" menubar = tk . Menu ( self ) self . config ( menu = menubar ) file_menu = tk . Menu ( menubar , tearoff = 0 ) file_menu . add_command ( label = \"Startseite\" , command = lambda : self . show_frame ( MainMenu )) file_menu . add_command ( label = \"Speicherort \u00e4ndern\" , command = self . change_save_path ) # Settings for changing the theme Link: lighthttps://ttkbootstrap.readthedocs.io/en/latest/themes/dark/ ChangeTheme = tk . Menu ( file_menu , tearoff = 0 ) ChangeTheme . add_command ( label = \"light\" , command = lambda : self . change_theme ( LIGHT_THEME )) ChangeTheme . add_command ( label = \"dark\" , command = lambda : self . change_theme ( DARK_THEME )) file_menu . add_cascade ( label = \"Theme \u00e4ndern\" , menu = ChangeTheme ) file_menu . add_separator () file_menu . add_command ( label = \"Programm beenden\" , command = self . on_closing ) menubar . add_cascade ( label = \"Einstellungen\" , menu = file_menu ) exit_fullscreen \u00b6 exit_fullscreen ( event = None ) Exit fullscreen mode Source code in app\\ui.py 137 138 139 def exit_fullscreen ( self , event = None ): \"\"\"Exit fullscreen mode\"\"\" self . attributes ( '-fullscreen' , False ) get_images_in_path \u00b6 get_images_in_path ( directory , image_extensions = [ '.png' , '.jpg' , '.jpeg' , '.gif' , '.bmp' ]) Get a list of image files in the specified directory. Args: directory (str): The path to the directory to check. image_extensions (list): List of image file extensions to check for. Returns: list: List of image file paths if any image files are found, False otherwise. Source code in app\\ui.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def get_images_in_path ( self , directory , image_extensions = [ \".png\" , \".jpg\" , \".jpeg\" , \".gif\" , \".bmp\" ]): \"\"\" Get a list of image files in the specified directory. Args: directory (str): The path to the directory to check. image_extensions (list): List of image file extensions to check for. Returns: list: List of image file paths if any image files are found, False otherwise. \"\"\" if not os . path . exists ( directory ): return False image_files = [ os . path . join ( directory , file ) for file in os . listdir ( directory ) if any ( file . lower () . endswith ( ext ) for ext in image_extensions )] return image_files if image_files else False on_closing \u00b6 on_closing () Ask for confirmation before closing the program Source code in app\\ui.py 191 192 193 194 def on_closing ( self ): \"\"\"Ask for confirmation before closing the program\"\"\" if messagebox . askyesno ( title = \"Quit\" , message = \"M\u00f6chten Sie wirklich das Programm beenden?\" ): self . destroy () run_process \u00b6 run_process ( process , callback ) Runs a process and calls a callback function when the process is done Parameters: process ( function ) \u2013 function to be called callback ( function ) \u2013 function to be called when process is done Source code in app\\ui.py 171 172 173 174 175 176 177 178 179 180 def run_process ( self , process , callback ): \"\"\"Runs a process and calls a callback function when the process is done Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" process () self . process_done = True self . after ( 100 , callback ) set_icon \u00b6 set_icon ( path ) Set the window icon using Pillow Source code in app\\ui.py 142 143 144 145 146 def set_icon ( self , path ): \"\"\"Set the window icon using Pillow\"\"\" img = Image . open ( path ) photo = ImageTk . PhotoImage ( img ) self . iconphoto ( False , photo ) show_frame \u00b6 show_frame ( page ) Show a frame for the given page name Parameters: page(class) \u2013 class of the page to be shown Source code in app\\ui.py 149 150 151 152 153 154 155 156 def show_frame ( self , page ): \"\"\"Show a frame for the given page name Args: page(class): class of the page to be shown \"\"\" frame = self . frames [ page ] frame . tkraise () wait_for_process \u00b6 wait_for_process ( process , callback ) Starts a process in a new thread and calls a callback function when the process is done. Parameters: process ( function ) \u2013 function to be called callback ( function ) \u2013 function to be called when process is done Source code in app\\ui.py 159 160 161 162 163 164 165 166 167 168 def wait_for_process ( self , process , callback ): \"\"\"Starts a process in a new thread and calls a callback function when the process is done. Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" t = threading . Thread ( target = self . run_process , args = ( process , callback )) t . daemon = True t . start () CalibrationPage \u00b6 Bases: Frame Source code in app\\ui.py 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 class CalibrationPage ( ttk . Frame ): def __init__ ( self , parent , calibration_funcs ): \"\"\"Page for calibrating the audiometer. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . cal_start = calibration_funcs [ 0 ] self . cal_next = calibration_funcs [ 1 ] self . cal_repeat = calibration_funcs [ 2 ] self . cal_stop = calibration_funcs [ 3 ] self . cal_setlevel = calibration_funcs [ 4 ] self . create_widgets () self . finished = False def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" button_width = 25 self . intro = ttk . Label ( self , text = text_calibration , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . intro . pack ( padx = 10 , pady = 10 ) self . level_label = ttk . Label ( self , text = \"Wert in dBHL, bei dem kalibriert werden soll:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_label . pack ( padx = 10 , pady = 10 ) self . level_entry_var = tk . StringVar () self . level_entry_var . set ( \"10\" ) self . level_entry = ttk . Entry ( self , width = button_width - 10 , textvariable = self . level_entry_var ) self . level_entry . pack ( padx = 10 , pady = 10 ) self . start_button = ttk . Button ( self , text = \"Kalibrierung starten\" , command = self . start_calibration , width = button_width ) self . start_button . pack ( padx = 10 , pady = 10 ) self . next_button = ttk . Button ( self , text = \"N\u00e4chste Frequenz\" , command = self . next_frequency , width = button_width , state = tk . DISABLED ) self . next_button . pack ( padx = 10 , pady = 10 ) self . repeat_button = ttk . Button ( self , text = \"Erneut wiedergeben\" , command = self . repeat_frequency , width = button_width , state = tk . DISABLED ) self . repeat_button . pack ( padx = 10 , pady = 10 ) self . stop_button = ttk . Button ( self , text = \"Wiedergabe stoppen\" , command = self . stop_playing , width = button_width , state = tk . DISABLED ) self . stop_button . pack ( padx = 10 , pady = 10 ) self . back_button = ttk . Button ( self , text = \"Zur\u00fcck zum Hauptmen\u00fc\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) # TODO Kalibrierung resetten, damit man sie dann wieder von vorne anfangen kann self . back_button . pack ( padx = 10 , pady = 20 ) self . spacer_frame = tk . Frame ( self , width = 20 , height = 80 ) self . spacer_frame . pack () self . current_freq_var = tk . StringVar ( value = \"Aktuelle Frequenz:\" ) self . current_freq = ttk . Label ( self , textvariable = self . current_freq_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . current_freq . pack ( padx = 10 , pady = 10 ) self . level_expected_var = tk . StringVar ( value = \"Schalldruckpegel (soll):\" ) self . level_expected_label = ttk . Label ( self , textvariable = self . level_expected_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_expected_label . pack ( padx = 10 , pady = 10 ) self . level_measured_label = ttk . Label ( self , text = \"Gemessener Schalldruckpegel in dB:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_measured_label . pack ( padx = 10 , pady = 10 ) self . level_measured_var = tk . StringVar () self . level_measured_entry = ttk . Entry ( self , width = button_width - 10 , font = ( FONT_FAMILY , SUBHEADER_SIZE ), state = tk . DISABLED , textvariable = self . level_measured_var ) self . level_measured_entry . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) def start_calibration ( self ): try : current_freq , current_spl = self . cal_start ( float ( self . level_entry_var . get ())) except : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie eine Zahl ein.' ) return self . start_button . config ( state = tk . DISABLED ) self . next_button . config ( state = tk . NORMAL ) self . repeat_button . config ( state = tk . NORMAL ) self . stop_button . config ( state = tk . NORMAL ) self . level_measured_entry . config ( state = tk . NORMAL ) self . current_freq_var . set ( \"Aktuelle Frequenz: \" + str ( current_freq ) + \" Hz\" ) self . level_expected_var . set ( \"Schalldruckpegel (soll): \" + str ( current_spl ) + \" dB\" ) def next_frequency ( self ): try : if self . level_measured_var . get () != \"\" : self . cal_setlevel ( float ( self . level_measured_var . get ())) else : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei \"gemessener Schalldruckpegel\" eine Zahl ein.' ) return except ValueError : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei \"gemessener Schalldruck\" eine Zahl ein.' ) return self . level_measured_var . set ( \"\" ) more_freqs , current_freq , current_spl = self . cal_next () # Change Button when last frequency if not more_freqs : # Grey out all buttons when finished if self . finished : self . next_button . config ( state = tk . DISABLED ) self . repeat_button . config ( state = tk . DISABLED ) self . stop_button . config ( state = tk . DISABLED ) self . level_measured_entry . config ( state = tk . DISABLED ) messagebox . showwarning ( \"Kalibrierung abgeschlossen.\" , \"Die Kalibrierung wurde erfolgreich abgeschlossen. Datei gespeichert als calibration.csv\" ) return self . next_button . config ( text = \"Kalibrierung abschlie\u00dfen\" ) self . finished = True self . current_freq_var . set ( \"Aktuelle Frequenz: \" + str ( current_freq ) + \" Hz\" ) self . level_expected_var . set ( \"Schalldruckpegel (soll): \" + str ( current_spl ) + \" dB\" ) def repeat_frequency ( self ): self . cal_repeat () def stop_playing ( self ): self . cal_stop () __init__ \u00b6 __init__ ( parent , calibration_funcs ) Page for calibrating the audiometer. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 def __init__ ( self , parent , calibration_funcs ): \"\"\"Page for calibrating the audiometer. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . cal_start = calibration_funcs [ 0 ] self . cal_next = calibration_funcs [ 1 ] self . cal_repeat = calibration_funcs [ 2 ] self . cal_stop = calibration_funcs [ 3 ] self . cal_setlevel = calibration_funcs [ 4 ] self . create_widgets () self . finished = False create_widgets \u00b6 create_widgets () Creates the widgets for the page. Source code in app\\ui.py 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" button_width = 25 self . intro = ttk . Label ( self , text = text_calibration , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . intro . pack ( padx = 10 , pady = 10 ) self . level_label = ttk . Label ( self , text = \"Wert in dBHL, bei dem kalibriert werden soll:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_label . pack ( padx = 10 , pady = 10 ) self . level_entry_var = tk . StringVar () self . level_entry_var . set ( \"10\" ) self . level_entry = ttk . Entry ( self , width = button_width - 10 , textvariable = self . level_entry_var ) self . level_entry . pack ( padx = 10 , pady = 10 ) self . start_button = ttk . Button ( self , text = \"Kalibrierung starten\" , command = self . start_calibration , width = button_width ) self . start_button . pack ( padx = 10 , pady = 10 ) self . next_button = ttk . Button ( self , text = \"N\u00e4chste Frequenz\" , command = self . next_frequency , width = button_width , state = tk . DISABLED ) self . next_button . pack ( padx = 10 , pady = 10 ) self . repeat_button = ttk . Button ( self , text = \"Erneut wiedergeben\" , command = self . repeat_frequency , width = button_width , state = tk . DISABLED ) self . repeat_button . pack ( padx = 10 , pady = 10 ) self . stop_button = ttk . Button ( self , text = \"Wiedergabe stoppen\" , command = self . stop_playing , width = button_width , state = tk . DISABLED ) self . stop_button . pack ( padx = 10 , pady = 10 ) self . back_button = ttk . Button ( self , text = \"Zur\u00fcck zum Hauptmen\u00fc\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) # TODO Kalibrierung resetten, damit man sie dann wieder von vorne anfangen kann self . back_button . pack ( padx = 10 , pady = 20 ) self . spacer_frame = tk . Frame ( self , width = 20 , height = 80 ) self . spacer_frame . pack () self . current_freq_var = tk . StringVar ( value = \"Aktuelle Frequenz:\" ) self . current_freq = ttk . Label ( self , textvariable = self . current_freq_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . current_freq . pack ( padx = 10 , pady = 10 ) self . level_expected_var = tk . StringVar ( value = \"Schalldruckpegel (soll):\" ) self . level_expected_label = ttk . Label ( self , textvariable = self . level_expected_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_expected_label . pack ( padx = 10 , pady = 10 ) self . level_measured_label = ttk . Label ( self , text = \"Gemessener Schalldruckpegel in dB:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_measured_label . pack ( padx = 10 , pady = 10 ) self . level_measured_var = tk . StringVar () self . level_measured_entry = ttk . Entry ( self , width = button_width - 10 , font = ( FONT_FAMILY , SUBHEADER_SIZE ), state = tk . DISABLED , textvariable = self . level_measured_var ) self . level_measured_entry . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) DuringFamiliarizationView \u00b6 Bases: Frame Source code in app\\ui.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 class DuringFamiliarizationView ( ttk . Frame ): def __init__ ( self , parent , familiarization_func , progress_func ): \"\"\"View during familiarization process Args: parent (App): parent application familiarization_func (function): function to be called for familiarization\"\"\" super () . __init__ ( parent ) self . parent = parent self . program = familiarization_func self . get_progress = progress_func self . text = \"Eingew\u00f6hnung l\u00e4uft...\" self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the view \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 ) __init__ \u00b6 __init__ ( parent , familiarization_func , progress_func ) View during familiarization process Parameters: parent ( App ) \u2013 parent application familiarization_func ( function ) \u2013 function to be called for familiarization Source code in app\\ui.py 485 486 487 488 489 490 491 492 493 494 495 496 def __init__ ( self , parent , familiarization_func , progress_func ): \"\"\"View during familiarization process Args: parent (App): parent application familiarization_func (function): function to be called for familiarization\"\"\" super () . __init__ ( parent ) self . parent = parent self . program = familiarization_func self . get_progress = progress_func self . text = \"Eingew\u00f6hnung l\u00e4uft...\" self . create_widgets () create_widgets \u00b6 create_widgets () Creates the widgets for the view Source code in app\\ui.py 499 500 501 502 503 504 505 506 def create_widgets ( self ): \"\"\"Creates the widgets for the view \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 ) DuringProcedureView \u00b6 Bases: Frame Source code in app\\ui.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 class DuringProcedureView ( ttk . Frame ): def __init__ ( self , parent , program_func , progress_func , text ): \"\"\"View during main program Args: parent (App): parent application program_func (function): function to be called for the main program text (str): text to be displayed \"\"\" super () . __init__ ( parent ) self . parent = parent self . program = program_func self . get_progress = progress_func self . text = text self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the view \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 ) __init__ \u00b6 __init__ ( parent , program_func , progress_func , text ) View during main program Parameters: parent ( App ) \u2013 parent application program_func ( function ) \u2013 function to be called for the main program text ( str ) \u2013 text to be displayed Source code in app\\ui.py 511 512 513 514 515 516 517 518 519 520 521 522 523 524 def __init__ ( self , parent , program_func , progress_func , text ): \"\"\"View during main program Args: parent (App): parent application program_func (function): function to be called for the main program text (str): text to be displayed \"\"\" super () . __init__ ( parent ) self . parent = parent self . program = program_func self . get_progress = progress_func self . text = text self . create_widgets () create_widgets \u00b6 create_widgets () Creates the widgets for the view Source code in app\\ui.py 527 528 529 530 531 532 533 534 def create_widgets ( self ): \"\"\"Creates the widgets for the view \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 ) FamiliarizationPage \u00b6 Bases: Frame Source code in app\\ui.py 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 class FamiliarizationPage ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Page for starting the familiarization process. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the page \"\"\" button_width = 25 self . label = ttk . Label ( self , text = text_Familiarization , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . label . pack ( padx = 10 , pady = 10 ) self . play_button = ttk . Button ( self , text = \"Starte Eingew\u00f6hnung\" , command = self . run_familiarization , width = button_width ) self . play_button . pack ( padx = 10 , pady = 10 ) self . go_back_button = ttk . Button ( self , text = \"zur\u00fcck\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) self . go_back_button . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) def run_familiarization ( self ): \"\"\"Runs the familiarization process \"\"\" self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( DuringFamiliarizationView ) gender = self . parent . frames [ MainMenu ] . gender_dropdown . get () if gender == \"Geschlecht...\" or gender == \"Keine Angabe\" : gender = \"\" age = self . parent . frames [ MainMenu ] . age_entry . get () self . parent . wait_for_process ( lambda : self . parent . frames [ DuringFamiliarizationView ] . program ( id = self . parent . frames [ MainMenu ] . patient_number , calibrate = self . use_calibration , gender = gender , age = age ), lambda : self . parent . show_frame ( ProgramPage )) time . sleep ( 0.001 ) self . update () counter = 0 sleep_time = random . uniform ( 1 , 2.5 ) # random time in seconds between 1 and 2.5 to update progress bar while self . parent . frames [ DuringFamiliarizationView ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ DuringFamiliarizationView ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ DuringFamiliarizationView ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False __init__ \u00b6 __init__ ( parent ) Page for starting the familiarization process. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 359 360 361 362 363 364 365 366 367 def __init__ ( self , parent ): \"\"\"Page for starting the familiarization process. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets () create_widgets \u00b6 create_widgets () Creates the widgets for the page Source code in app\\ui.py 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 def create_widgets ( self ): \"\"\"Creates the widgets for the page \"\"\" button_width = 25 self . label = ttk . Label ( self , text = text_Familiarization , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . label . pack ( padx = 10 , pady = 10 ) self . play_button = ttk . Button ( self , text = \"Starte Eingew\u00f6hnung\" , command = self . run_familiarization , width = button_width ) self . play_button . pack ( padx = 10 , pady = 10 ) self . go_back_button = ttk . Button ( self , text = \"zur\u00fcck\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) self . go_back_button . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) run_familiarization \u00b6 run_familiarization () Runs the familiarization process Source code in app\\ui.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 def run_familiarization ( self ): \"\"\"Runs the familiarization process \"\"\" self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( DuringFamiliarizationView ) gender = self . parent . frames [ MainMenu ] . gender_dropdown . get () if gender == \"Geschlecht...\" or gender == \"Keine Angabe\" : gender = \"\" age = self . parent . frames [ MainMenu ] . age_entry . get () self . parent . wait_for_process ( lambda : self . parent . frames [ DuringFamiliarizationView ] . program ( id = self . parent . frames [ MainMenu ] . patient_number , calibrate = self . use_calibration , gender = gender , age = age ), lambda : self . parent . show_frame ( ProgramPage )) time . sleep ( 0.001 ) self . update () counter = 0 sleep_time = random . uniform ( 1 , 2.5 ) # random time in seconds between 1 and 2.5 to update progress bar while self . parent . frames [ DuringFamiliarizationView ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ DuringFamiliarizationView ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ DuringFamiliarizationView ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False MainMenu \u00b6 Bases: Frame Source code in app\\ui.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 class MainMenu ( ttk . Frame ): def __init__ ( self , parent ): super () . __init__ ( parent ) self . parent = parent self . button_width = 25 self . start_button = None self . binaural_test = tk . BooleanVar () self . use_calibration = tk . BooleanVar ( value = True ) self . selected_option = None self . patient_number = \"\" self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the page \"\"\" self . patient_number_label = ttk . Label ( self , text = \"Probandennummer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . patient_number_label . pack ( padx = 10 , pady = 10 ) self . patient_number_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . patient_number_entry . pack ( padx = 10 , pady = 10 ) self . gender_label = ttk . Label ( self , text = \"Geschlecht (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . gender_label . pack ( padx = 10 , pady = 10 ) self . gender_dropdown = ttk . Combobox ( self , values = [ \"M\u00e4nnlich\" , \"Weiblich\" , \"Divers\" , \"Keine Angabe\" ], state = \"readonly\" , width = self . button_width - 1 ) self . gender_dropdown . set ( \"Geschlecht...\" ) self . gender_dropdown . pack ( padx = 10 , pady = 10 ) self . age_label = ttk . Label ( self , text = \"Alter (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . age_label . pack ( padx = 10 , pady = 10 ) self . age_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . age_entry . pack ( padx = 10 , pady = 10 ) self . label = ttk . Label ( self , text = \" \\n Bitte w\u00e4hlen Sie ein Programm\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . label . pack ( pady = 10 ) # Dropdown menu options = list ( self . parent . program_funcs . keys ()) self . dropdown = ttk . Combobox ( self , values = options , state = \"readonly\" , width = self . button_width - 1 ) self . dropdown . set ( \"Test w\u00e4hlen...\" ) self . dropdown . pack ( pady = 10 ) self . dropdown . bind ( \"<<ComboboxSelected>>\" , self . on_option_selected ) self . binaural_button = ttk . Checkbutton ( self , text = \"Binaurale Testung\" , variable = self . binaural_test ) self . binaural_button . pack ( pady = 10 ) # Use calibration button self . cal_button = ttk . Checkbutton ( self , text = \"Werte aus letzter Kalibrierung verwenden\" , variable = self . use_calibration ) self . cal_button . pack ( pady = 10 , side = \"bottom\" ) # Headphone selection self . headphone_dropdown = ttk . Combobox ( self , values = self . get_headphone_options (), state = \"readonly\" , width = self . button_width - 1 ) self . headphone_dropdown . set ( \"Sennheiser_HDA200\" ) self . headphone_dropdown . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) self . headphone_label = ttk . Label ( self , text = \"Kopfh\u00f6rer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . headphone_label . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) def get_headphone_options ( self ): file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): messagebox . showwarning ( \"Warnung\" , f 'Die Datei \" { file_name } \" konnte nicht gefunden werden.' ) return headphone_options = [] try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : headphone_options . append ( row [ 'headphone_model' ]) headphone_options = list ( set ( headphone_options )) return headphone_options except Exception as e : messagebox . showwarning ( \"Warnung\" , f 'Fehler beim Lesen der Datei \" { file_name } \": { e } ' ) return def on_option_selected ( self , event ): self . selected_option = self . dropdown . get () self . show_start_button () if self . selected_option == \"Kalibrierung\" : self . cal_button . config ( state = tk . DISABLED ) self . binaural_button . config ( state = tk . DISABLED ) self . gender_dropdown . config ( state = tk . DISABLED ) self . patient_number_entry . config ( state = tk . DISABLED ) else : self . cal_button . config ( state = tk . NORMAL ) self . binaural_button . config ( state = tk . NORMAL ) self . gender_dropdown . config ( state = tk . NORMAL ) self . patient_number_entry . config ( state = tk . NORMAL ) def show_start_button ( self ): if self . start_button is None : self . start_button = ttk . Button ( self , text = \"Test starten\" , command = self . go_to_next_page , width = self . button_width ) self . start_button . pack ( pady = 10 ) def go_to_next_page ( self ): if self . selected_option == \"Kalibrierung\" : self . parent . show_frame ( CalibrationPage ) else : self . patient_number = self . patient_number_entry . get () if not self . patient_number : messagebox . showwarning ( \"Warnung\" , \"Bitte geben Sie eine Probandennummer ein.\" ) return # check if valide age is entered if self . age_entry . get (): try : i = int ( self . age_entry . get ()) if i > 110 or i < 0 : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei Alter eine g\u00fcltige Zahl oder gar nichts ein.' ) return except : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei Alter eine g\u00fcltige Zahl oder gar nichts ein.' ) return patient_folder = os . path . join ( self . parent . save_path , self . patient_number ) pics = self . parent . get_images_in_path ( patient_folder ) if pics : if messagebox . askyesno ( \"Proband vorhanden\" , \"F\u00fcr diese Probandennummer gibt es bereits Ergebnisse. M\u00f6chten Sie diese anzeigen?\" ): results_page = self . parent . frames [ ResultPage ] results_page . display_images ( self . patient_number ) self . parent . show_frame ( ResultPage ) return self . parent . show_frame ( FamiliarizationPage ) create_widgets \u00b6 create_widgets () Creates the widgets for the page Source code in app\\ui.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def create_widgets ( self ): \"\"\"Creates the widgets for the page \"\"\" self . patient_number_label = ttk . Label ( self , text = \"Probandennummer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . patient_number_label . pack ( padx = 10 , pady = 10 ) self . patient_number_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . patient_number_entry . pack ( padx = 10 , pady = 10 ) self . gender_label = ttk . Label ( self , text = \"Geschlecht (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . gender_label . pack ( padx = 10 , pady = 10 ) self . gender_dropdown = ttk . Combobox ( self , values = [ \"M\u00e4nnlich\" , \"Weiblich\" , \"Divers\" , \"Keine Angabe\" ], state = \"readonly\" , width = self . button_width - 1 ) self . gender_dropdown . set ( \"Geschlecht...\" ) self . gender_dropdown . pack ( padx = 10 , pady = 10 ) self . age_label = ttk . Label ( self , text = \"Alter (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . age_label . pack ( padx = 10 , pady = 10 ) self . age_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . age_entry . pack ( padx = 10 , pady = 10 ) self . label = ttk . Label ( self , text = \" \\n Bitte w\u00e4hlen Sie ein Programm\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . label . pack ( pady = 10 ) # Dropdown menu options = list ( self . parent . program_funcs . keys ()) self . dropdown = ttk . Combobox ( self , values = options , state = \"readonly\" , width = self . button_width - 1 ) self . dropdown . set ( \"Test w\u00e4hlen...\" ) self . dropdown . pack ( pady = 10 ) self . dropdown . bind ( \"<<ComboboxSelected>>\" , self . on_option_selected ) self . binaural_button = ttk . Checkbutton ( self , text = \"Binaurale Testung\" , variable = self . binaural_test ) self . binaural_button . pack ( pady = 10 ) # Use calibration button self . cal_button = ttk . Checkbutton ( self , text = \"Werte aus letzter Kalibrierung verwenden\" , variable = self . use_calibration ) self . cal_button . pack ( pady = 10 , side = \"bottom\" ) # Headphone selection self . headphone_dropdown = ttk . Combobox ( self , values = self . get_headphone_options (), state = \"readonly\" , width = self . button_width - 1 ) self . headphone_dropdown . set ( \"Sennheiser_HDA200\" ) self . headphone_dropdown . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) self . headphone_label = ttk . Label ( self , text = \"Kopfh\u00f6rer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . headphone_label . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) ProgramPage \u00b6 Bases: Frame Source code in app\\ui.py 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 class ProgramPage ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Page for starting the main program. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . selected_option = None self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the page\"\"\" self . start_button = ttk . Button ( self , text = \"Starte Prozess\" , command = self . run_program ) self . start_button . pack ( padx = 10 , pady = 200 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) def run_program ( self ): \"\"\"Runs the main program\"\"\" self . selected_option = self . parent . frames [ MainMenu ] . selected_option self . binaural_test = self . parent . frames [ MainMenu ] . binaural_test . get () self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( self . selected_option ) self . parent . wait_for_process ( lambda : self . parent . frames [ self . selected_option ] . program ( self . binaural_test , calibrate = self . use_calibration ), self . show_results ) time . sleep ( 0.001 ) self . update () counter = 0 sleep_time = random . uniform ( 1 , 2.5 ) # random time in seconds between 1 and 2.5 to update progress bar while self . parent . frames [ self . selected_option ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ self . selected_option ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ self . selected_option ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False def show_results ( self ): \"\"\"Show the results page with the images\"\"\" patient_number = self . parent . frames [ MainMenu ] . patient_number results_page = self . parent . frames [ ResultPage ] results_page . display_images ( patient_number ) self . parent . show_frame ( ResultPage ) __init__ \u00b6 __init__ ( parent ) Page for starting the main program. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 426 427 428 429 430 431 432 433 434 435 def __init__ ( self , parent ): \"\"\"Page for starting the main program. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . selected_option = None self . create_widgets () create_widgets \u00b6 create_widgets () Creates the widgets for the page Source code in app\\ui.py 438 439 440 441 442 443 444 def create_widgets ( self ): \"\"\"Creates the widgets for the page\"\"\" self . start_button = ttk . Button ( self , text = \"Starte Prozess\" , command = self . run_program ) self . start_button . pack ( padx = 10 , pady = 200 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) run_program \u00b6 run_program () Runs the main program Source code in app\\ui.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 def run_program ( self ): \"\"\"Runs the main program\"\"\" self . selected_option = self . parent . frames [ MainMenu ] . selected_option self . binaural_test = self . parent . frames [ MainMenu ] . binaural_test . get () self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( self . selected_option ) self . parent . wait_for_process ( lambda : self . parent . frames [ self . selected_option ] . program ( self . binaural_test , calibrate = self . use_calibration ), self . show_results ) time . sleep ( 0.001 ) self . update () counter = 0 sleep_time = random . uniform ( 1 , 2.5 ) # random time in seconds between 1 and 2.5 to update progress bar while self . parent . frames [ self . selected_option ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ self . selected_option ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ self . selected_option ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False show_results \u00b6 show_results () Show the results page with the images Source code in app\\ui.py 472 473 474 475 476 477 def show_results ( self ): \"\"\"Show the results page with the images\"\"\" patient_number = self . parent . frames [ MainMenu ] . patient_number results_page = self . parent . frames [ ResultPage ] results_page . display_images ( patient_number ) self . parent . show_frame ( ResultPage ) ResultPage \u00b6 Bases: Frame Source code in app\\ui.py 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 class ResultPage ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Page for showing the results of the program. Args: parent (App): parent application\"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the view\"\"\" self . info = ttk . Label ( self , text = \"Ergebnisse\" , font = ( FONT_FAMILY , HEADER_SIZE )) self . info . pack ( padx = 10 , pady = 10 ) # Set the title on the parent window self . parent . title ( \"Audiogramm\" ) # Create a frame for the images self . image_frame = ttk . Frame ( self ) self . image_frame . pack ( anchor = \"center\" ) #,fill=\"both\", expand=True) # Button to go back to the main menu self . BackToMainMenu = ttk . Button ( self , text = \"Zur\u00fcck zur Startseite\" , command = lambda : self . parent . show_frame ( MainMenu )) self . BackToMainMenu . pack ( padx = 10 , pady = 10 ) def display_images ( self , folder_name ): \"\"\"Display all images in the given folder\"\"\" folder_path = os . path . join ( self . parent . save_path , folder_name ) for widget in self . image_frame . winfo_children (): widget . destroy () # TODO das muss viel sch\u00f6ner angezeigt werden, mittig, gro\u00df, Datum und Uhrzeit etc. ... pics = self . parent . get_images_in_path ( folder_path ) if pics : for file in pics : img = Image . open ( file ) #img = img.resize((400, 300), Image.LANCZOS) photo = ImageTk . PhotoImage ( img ) label = ttk . Label ( self . image_frame , image = photo ) label . image = photo label . pack ( padx = 10 , pady = 10 , side = \"left\" ) def back_to_MainMenu ( self ): self . parent . show_frame ( MainMenu ) __init__ \u00b6 __init__ ( parent ) Page for showing the results of the program. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 539 540 541 542 543 544 545 546 547 548 def __init__ ( self , parent ): \"\"\"Page for showing the results of the program. Args: parent (App): parent application\"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets () create_widgets \u00b6 create_widgets () Creates the widgets for the view Source code in app\\ui.py 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 def create_widgets ( self ): \"\"\"Creates the widgets for the view\"\"\" self . info = ttk . Label ( self , text = \"Ergebnisse\" , font = ( FONT_FAMILY , HEADER_SIZE )) self . info . pack ( padx = 10 , pady = 10 ) # Set the title on the parent window self . parent . title ( \"Audiogramm\" ) # Create a frame for the images self . image_frame = ttk . Frame ( self ) self . image_frame . pack ( anchor = \"center\" ) #,fill=\"both\", expand=True) # Button to go back to the main menu self . BackToMainMenu = ttk . Button ( self , text = \"Zur\u00fcck zur Startseite\" , command = lambda : self . parent . show_frame ( MainMenu )) self . BackToMainMenu . pack ( padx = 10 , pady = 10 ) display_images \u00b6 display_images ( folder_name ) Display all images in the given folder Source code in app\\ui.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 def display_images ( self , folder_name ): \"\"\"Display all images in the given folder\"\"\" folder_path = os . path . join ( self . parent . save_path , folder_name ) for widget in self . image_frame . winfo_children (): widget . destroy () # TODO das muss viel sch\u00f6ner angezeigt werden, mittig, gro\u00df, Datum und Uhrzeit etc. ... pics = self . parent . get_images_in_path ( folder_path ) if pics : for file in pics : img = Image . open ( file ) #img = img.resize((400, 300), Image.LANCZOS) photo = ImageTk . PhotoImage ( img ) label = ttk . Label ( self . image_frame , image = photo ) label . image = photo label . pack ( padx = 10 , pady = 10 , side = \"left\" )","title":"ui"},{"location":"api/ui/#ui-module","text":"","title":"ui Module"},{"location":"api/ui/#app.ui.App","text":"Bases: Window Source code in app\\ui.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class App ( tb . Window ): def __init__ ( self , familiarization_func , program_funcs : dict , calibration_funcs : list , progress_func ): \"\"\"Main application window. Contains all pages and controls the flow of the program. Args: familiarization_func (function): function to be called for familiarization audiogram_func (function): function to be called for creating audiogram program_funcs (dict of str:function): function(s) to be called for the main program calibration_funcs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level \"\"\" super () . __init__ ( themename = LIGHT_THEME ) # General theme settings self . title ( \"Sound Player\" ) self . geometry ( GEOMETRY ) self . minsize ( 650 , 650 ) self . attributes ( '-fullscreen' , True ) self . bind ( \"<Escape>\" , self . exit_fullscreen ) self . save_path = os . path . join ( os . getcwd ()) # Ensure the default save path exists os . makedirs ( self . save_path , exist_ok = True ) #self.set_icon(\"app/00_TUBerlin_Logo_rot.jpg\") change the icon maybe? #TODO self . tk . call ( 'tk' , 'scaling' , 2.0 ) # Adjust for high-DPI displays # Dictionary to store all pages self . program_funcs = program_funcs self . frames = {} self . binaural_test = False # Interactive Pages for F in ( MainMenu , FamiliarizationPage , ProgramPage , ResultPage ): frame = F ( self ) self . frames [ F ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Calibration separately to give it its functions frame = CalibrationPage ( self , calibration_funcs ) self . frames [ CalibrationPage ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during familiarization frame = DuringFamiliarizationView ( self , familiarization_func , progress_func ) self . frames [ DuringFamiliarizationView ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during programs for name , program_func in program_funcs . items (): frame = DuringProcedureView ( self , program_func , progress_func , text = \"Programm l\u00e4uft...\" ) self . frames [ name ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Show MainMenu first self . show_frame ( MainMenu ) # Create menubar self . create_menubar () # Variable for threading self . process_done = False # Override the close button protocol self . protocol ( \"WM_DELETE_WINDOW\" , self . on_closing ) self . grid_rowconfigure ( 0 , weight = 1 ) self . grid_columnconfigure ( 0 , weight = 1 ) def create_menubar ( self ): \"\"\"Create a menubar with options for changing the theme and exiting the program\"\"\" menubar = tk . Menu ( self ) self . config ( menu = menubar ) file_menu = tk . Menu ( menubar , tearoff = 0 ) file_menu . add_command ( label = \"Startseite\" , command = lambda : self . show_frame ( MainMenu )) file_menu . add_command ( label = \"Speicherort \u00e4ndern\" , command = self . change_save_path ) # Settings for changing the theme Link: lighthttps://ttkbootstrap.readthedocs.io/en/latest/themes/dark/ ChangeTheme = tk . Menu ( file_menu , tearoff = 0 ) ChangeTheme . add_command ( label = \"light\" , command = lambda : self . change_theme ( LIGHT_THEME )) ChangeTheme . add_command ( label = \"dark\" , command = lambda : self . change_theme ( DARK_THEME )) file_menu . add_cascade ( label = \"Theme \u00e4ndern\" , menu = ChangeTheme ) file_menu . add_separator () file_menu . add_command ( label = \"Programm beenden\" , command = self . on_closing ) menubar . add_cascade ( label = \"Einstellungen\" , menu = file_menu ) def change_theme ( self , theme_name ): \"\"\"Change to the specified theme\"\"\" current_theme = self . style . theme_use () if current_theme == theme_name : messagebox . showwarning ( \"Oops..\" , \"Dieses Theme wird bereits verwendet.\" ) else : self . style . theme_use ( theme_name ) def exit_fullscreen ( self , event = None ): \"\"\"Exit fullscreen mode\"\"\" self . attributes ( '-fullscreen' , False ) def set_icon ( self , path ): \"\"\"Set the window icon using Pillow\"\"\" img = Image . open ( path ) photo = ImageTk . PhotoImage ( img ) self . iconphoto ( False , photo ) def show_frame ( self , page ): \"\"\"Show a frame for the given page name Args: page(class): class of the page to be shown \"\"\" frame = self . frames [ page ] frame . tkraise () def wait_for_process ( self , process , callback ): \"\"\"Starts a process in a new thread and calls a callback function when the process is done. Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" t = threading . Thread ( target = self . run_process , args = ( process , callback )) t . daemon = True t . start () def run_process ( self , process , callback ): \"\"\"Runs a process and calls a callback function when the process is done Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" process () self . process_done = True self . after ( 100 , callback ) def change_save_path ( self ): \"\"\"Ask the user to select a folder to save the files\"\"\" new_path = filedialog . askdirectory ( title = \"Select Folder to Save Files\" ) if new_path : self . save_path = new_path messagebox . showinfo ( \"Speicherort ge\u00e4ndert\" , f \"Neuer Speicherort: { self . save_path } \" ) def on_closing ( self ): \"\"\"Ask for confirmation before closing the program\"\"\" if messagebox . askyesno ( title = \"Quit\" , message = \"M\u00f6chten Sie wirklich das Programm beenden?\" ): self . destroy () def get_images_in_path ( self , directory , image_extensions = [ \".png\" , \".jpg\" , \".jpeg\" , \".gif\" , \".bmp\" ]): \"\"\" Get a list of image files in the specified directory. Args: directory (str): The path to the directory to check. image_extensions (list): List of image file extensions to check for. Returns: list: List of image file paths if any image files are found, False otherwise. \"\"\" if not os . path . exists ( directory ): return False image_files = [ os . path . join ( directory , file ) for file in os . listdir ( directory ) if any ( file . lower () . endswith ( ext ) for ext in image_extensions )] return image_files if image_files else False","title":"App"},{"location":"api/ui/#app.ui.App.__init__","text":"__init__ ( familiarization_func , program_funcs , calibration_funcs , progress_func ) Main application window. Contains all pages and controls the flow of the program. Parameters: familiarization_func ( function ) \u2013 function to be called for familiarization audiogram_func ( function ) \u2013 function to be called for creating audiogram program_funcs ( dict of str ) \u2013 function): function(s) to be called for the main program calibration_funcs ( list function ) \u2013 list of function(s) for calibration in this order: start, next, repeat, stop, set_level Source code in app\\ui.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def __init__ ( self , familiarization_func , program_funcs : dict , calibration_funcs : list , progress_func ): \"\"\"Main application window. Contains all pages and controls the flow of the program. Args: familiarization_func (function): function to be called for familiarization audiogram_func (function): function to be called for creating audiogram program_funcs (dict of str:function): function(s) to be called for the main program calibration_funcs (list function): list of function(s) for calibration in this order: start, next, repeat, stop, set_level \"\"\" super () . __init__ ( themename = LIGHT_THEME ) # General theme settings self . title ( \"Sound Player\" ) self . geometry ( GEOMETRY ) self . minsize ( 650 , 650 ) self . attributes ( '-fullscreen' , True ) self . bind ( \"<Escape>\" , self . exit_fullscreen ) self . save_path = os . path . join ( os . getcwd ()) # Ensure the default save path exists os . makedirs ( self . save_path , exist_ok = True ) #self.set_icon(\"app/00_TUBerlin_Logo_rot.jpg\") change the icon maybe? #TODO self . tk . call ( 'tk' , 'scaling' , 2.0 ) # Adjust for high-DPI displays # Dictionary to store all pages self . program_funcs = program_funcs self . frames = {} self . binaural_test = False # Interactive Pages for F in ( MainMenu , FamiliarizationPage , ProgramPage , ResultPage ): frame = F ( self ) self . frames [ F ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Calibration separately to give it its functions frame = CalibrationPage ( self , calibration_funcs ) self . frames [ CalibrationPage ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during familiarization frame = DuringFamiliarizationView ( self , familiarization_func , progress_func ) self . frames [ DuringFamiliarizationView ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # View during programs for name , program_func in program_funcs . items (): frame = DuringProcedureView ( self , program_func , progress_func , text = \"Programm l\u00e4uft...\" ) self . frames [ name ] = frame frame . grid ( row = 0 , column = 0 , sticky = \"nsew\" ) # Show MainMenu first self . show_frame ( MainMenu ) # Create menubar self . create_menubar () # Variable for threading self . process_done = False # Override the close button protocol self . protocol ( \"WM_DELETE_WINDOW\" , self . on_closing ) self . grid_rowconfigure ( 0 , weight = 1 ) self . grid_columnconfigure ( 0 , weight = 1 )","title":"__init__"},{"location":"api/ui/#app.ui.App.change_save_path","text":"change_save_path () Ask the user to select a folder to save the files Source code in app\\ui.py 183 184 185 186 187 188 def change_save_path ( self ): \"\"\"Ask the user to select a folder to save the files\"\"\" new_path = filedialog . askdirectory ( title = \"Select Folder to Save Files\" ) if new_path : self . save_path = new_path messagebox . showinfo ( \"Speicherort ge\u00e4ndert\" , f \"Neuer Speicherort: { self . save_path } \" )","title":"change_save_path"},{"location":"api/ui/#app.ui.App.change_theme","text":"change_theme ( theme_name ) Change to the specified theme Source code in app\\ui.py 127 128 129 130 131 132 133 134 def change_theme ( self , theme_name ): \"\"\"Change to the specified theme\"\"\" current_theme = self . style . theme_use () if current_theme == theme_name : messagebox . showwarning ( \"Oops..\" , \"Dieses Theme wird bereits verwendet.\" ) else : self . style . theme_use ( theme_name )","title":"change_theme"},{"location":"api/ui/#app.ui.App.create_menubar","text":"create_menubar () Create a menubar with options for changing the theme and exiting the program Source code in app\\ui.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def create_menubar ( self ): \"\"\"Create a menubar with options for changing the theme and exiting the program\"\"\" menubar = tk . Menu ( self ) self . config ( menu = menubar ) file_menu = tk . Menu ( menubar , tearoff = 0 ) file_menu . add_command ( label = \"Startseite\" , command = lambda : self . show_frame ( MainMenu )) file_menu . add_command ( label = \"Speicherort \u00e4ndern\" , command = self . change_save_path ) # Settings for changing the theme Link: lighthttps://ttkbootstrap.readthedocs.io/en/latest/themes/dark/ ChangeTheme = tk . Menu ( file_menu , tearoff = 0 ) ChangeTheme . add_command ( label = \"light\" , command = lambda : self . change_theme ( LIGHT_THEME )) ChangeTheme . add_command ( label = \"dark\" , command = lambda : self . change_theme ( DARK_THEME )) file_menu . add_cascade ( label = \"Theme \u00e4ndern\" , menu = ChangeTheme ) file_menu . add_separator () file_menu . add_command ( label = \"Programm beenden\" , command = self . on_closing ) menubar . add_cascade ( label = \"Einstellungen\" , menu = file_menu )","title":"create_menubar"},{"location":"api/ui/#app.ui.App.exit_fullscreen","text":"exit_fullscreen ( event = None ) Exit fullscreen mode Source code in app\\ui.py 137 138 139 def exit_fullscreen ( self , event = None ): \"\"\"Exit fullscreen mode\"\"\" self . attributes ( '-fullscreen' , False )","title":"exit_fullscreen"},{"location":"api/ui/#app.ui.App.get_images_in_path","text":"get_images_in_path ( directory , image_extensions = [ '.png' , '.jpg' , '.jpeg' , '.gif' , '.bmp' ]) Get a list of image files in the specified directory. Args: directory (str): The path to the directory to check. image_extensions (list): List of image file extensions to check for. Returns: list: List of image file paths if any image files are found, False otherwise. Source code in app\\ui.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def get_images_in_path ( self , directory , image_extensions = [ \".png\" , \".jpg\" , \".jpeg\" , \".gif\" , \".bmp\" ]): \"\"\" Get a list of image files in the specified directory. Args: directory (str): The path to the directory to check. image_extensions (list): List of image file extensions to check for. Returns: list: List of image file paths if any image files are found, False otherwise. \"\"\" if not os . path . exists ( directory ): return False image_files = [ os . path . join ( directory , file ) for file in os . listdir ( directory ) if any ( file . lower () . endswith ( ext ) for ext in image_extensions )] return image_files if image_files else False","title":"get_images_in_path"},{"location":"api/ui/#app.ui.App.on_closing","text":"on_closing () Ask for confirmation before closing the program Source code in app\\ui.py 191 192 193 194 def on_closing ( self ): \"\"\"Ask for confirmation before closing the program\"\"\" if messagebox . askyesno ( title = \"Quit\" , message = \"M\u00f6chten Sie wirklich das Programm beenden?\" ): self . destroy ()","title":"on_closing"},{"location":"api/ui/#app.ui.App.run_process","text":"run_process ( process , callback ) Runs a process and calls a callback function when the process is done Parameters: process ( function ) \u2013 function to be called callback ( function ) \u2013 function to be called when process is done Source code in app\\ui.py 171 172 173 174 175 176 177 178 179 180 def run_process ( self , process , callback ): \"\"\"Runs a process and calls a callback function when the process is done Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" process () self . process_done = True self . after ( 100 , callback )","title":"run_process"},{"location":"api/ui/#app.ui.App.set_icon","text":"set_icon ( path ) Set the window icon using Pillow Source code in app\\ui.py 142 143 144 145 146 def set_icon ( self , path ): \"\"\"Set the window icon using Pillow\"\"\" img = Image . open ( path ) photo = ImageTk . PhotoImage ( img ) self . iconphoto ( False , photo )","title":"set_icon"},{"location":"api/ui/#app.ui.App.show_frame","text":"show_frame ( page ) Show a frame for the given page name Parameters: page(class) \u2013 class of the page to be shown Source code in app\\ui.py 149 150 151 152 153 154 155 156 def show_frame ( self , page ): \"\"\"Show a frame for the given page name Args: page(class): class of the page to be shown \"\"\" frame = self . frames [ page ] frame . tkraise ()","title":"show_frame"},{"location":"api/ui/#app.ui.App.wait_for_process","text":"wait_for_process ( process , callback ) Starts a process in a new thread and calls a callback function when the process is done. Parameters: process ( function ) \u2013 function to be called callback ( function ) \u2013 function to be called when process is done Source code in app\\ui.py 159 160 161 162 163 164 165 166 167 168 def wait_for_process ( self , process , callback ): \"\"\"Starts a process in a new thread and calls a callback function when the process is done. Args: process (function): function to be called callback (function): function to be called when process is done \"\"\" t = threading . Thread ( target = self . run_process , args = ( process , callback )) t . daemon = True t . start ()","title":"wait_for_process"},{"location":"api/ui/#app.ui.CalibrationPage","text":"Bases: Frame Source code in app\\ui.py 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 class CalibrationPage ( ttk . Frame ): def __init__ ( self , parent , calibration_funcs ): \"\"\"Page for calibrating the audiometer. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . cal_start = calibration_funcs [ 0 ] self . cal_next = calibration_funcs [ 1 ] self . cal_repeat = calibration_funcs [ 2 ] self . cal_stop = calibration_funcs [ 3 ] self . cal_setlevel = calibration_funcs [ 4 ] self . create_widgets () self . finished = False def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" button_width = 25 self . intro = ttk . Label ( self , text = text_calibration , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . intro . pack ( padx = 10 , pady = 10 ) self . level_label = ttk . Label ( self , text = \"Wert in dBHL, bei dem kalibriert werden soll:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_label . pack ( padx = 10 , pady = 10 ) self . level_entry_var = tk . StringVar () self . level_entry_var . set ( \"10\" ) self . level_entry = ttk . Entry ( self , width = button_width - 10 , textvariable = self . level_entry_var ) self . level_entry . pack ( padx = 10 , pady = 10 ) self . start_button = ttk . Button ( self , text = \"Kalibrierung starten\" , command = self . start_calibration , width = button_width ) self . start_button . pack ( padx = 10 , pady = 10 ) self . next_button = ttk . Button ( self , text = \"N\u00e4chste Frequenz\" , command = self . next_frequency , width = button_width , state = tk . DISABLED ) self . next_button . pack ( padx = 10 , pady = 10 ) self . repeat_button = ttk . Button ( self , text = \"Erneut wiedergeben\" , command = self . repeat_frequency , width = button_width , state = tk . DISABLED ) self . repeat_button . pack ( padx = 10 , pady = 10 ) self . stop_button = ttk . Button ( self , text = \"Wiedergabe stoppen\" , command = self . stop_playing , width = button_width , state = tk . DISABLED ) self . stop_button . pack ( padx = 10 , pady = 10 ) self . back_button = ttk . Button ( self , text = \"Zur\u00fcck zum Hauptmen\u00fc\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) # TODO Kalibrierung resetten, damit man sie dann wieder von vorne anfangen kann self . back_button . pack ( padx = 10 , pady = 20 ) self . spacer_frame = tk . Frame ( self , width = 20 , height = 80 ) self . spacer_frame . pack () self . current_freq_var = tk . StringVar ( value = \"Aktuelle Frequenz:\" ) self . current_freq = ttk . Label ( self , textvariable = self . current_freq_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . current_freq . pack ( padx = 10 , pady = 10 ) self . level_expected_var = tk . StringVar ( value = \"Schalldruckpegel (soll):\" ) self . level_expected_label = ttk . Label ( self , textvariable = self . level_expected_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_expected_label . pack ( padx = 10 , pady = 10 ) self . level_measured_label = ttk . Label ( self , text = \"Gemessener Schalldruckpegel in dB:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_measured_label . pack ( padx = 10 , pady = 10 ) self . level_measured_var = tk . StringVar () self . level_measured_entry = ttk . Entry ( self , width = button_width - 10 , font = ( FONT_FAMILY , SUBHEADER_SIZE ), state = tk . DISABLED , textvariable = self . level_measured_var ) self . level_measured_entry . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) def start_calibration ( self ): try : current_freq , current_spl = self . cal_start ( float ( self . level_entry_var . get ())) except : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie eine Zahl ein.' ) return self . start_button . config ( state = tk . DISABLED ) self . next_button . config ( state = tk . NORMAL ) self . repeat_button . config ( state = tk . NORMAL ) self . stop_button . config ( state = tk . NORMAL ) self . level_measured_entry . config ( state = tk . NORMAL ) self . current_freq_var . set ( \"Aktuelle Frequenz: \" + str ( current_freq ) + \" Hz\" ) self . level_expected_var . set ( \"Schalldruckpegel (soll): \" + str ( current_spl ) + \" dB\" ) def next_frequency ( self ): try : if self . level_measured_var . get () != \"\" : self . cal_setlevel ( float ( self . level_measured_var . get ())) else : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei \"gemessener Schalldruckpegel\" eine Zahl ein.' ) return except ValueError : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei \"gemessener Schalldruck\" eine Zahl ein.' ) return self . level_measured_var . set ( \"\" ) more_freqs , current_freq , current_spl = self . cal_next () # Change Button when last frequency if not more_freqs : # Grey out all buttons when finished if self . finished : self . next_button . config ( state = tk . DISABLED ) self . repeat_button . config ( state = tk . DISABLED ) self . stop_button . config ( state = tk . DISABLED ) self . level_measured_entry . config ( state = tk . DISABLED ) messagebox . showwarning ( \"Kalibrierung abgeschlossen.\" , \"Die Kalibrierung wurde erfolgreich abgeschlossen. Datei gespeichert als calibration.csv\" ) return self . next_button . config ( text = \"Kalibrierung abschlie\u00dfen\" ) self . finished = True self . current_freq_var . set ( \"Aktuelle Frequenz: \" + str ( current_freq ) + \" Hz\" ) self . level_expected_var . set ( \"Schalldruckpegel (soll): \" + str ( current_spl ) + \" dB\" ) def repeat_frequency ( self ): self . cal_repeat () def stop_playing ( self ): self . cal_stop ()","title":"CalibrationPage"},{"location":"api/ui/#app.ui.CalibrationPage.__init__","text":"__init__ ( parent , calibration_funcs ) Page for calibrating the audiometer. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 def __init__ ( self , parent , calibration_funcs ): \"\"\"Page for calibrating the audiometer. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . cal_start = calibration_funcs [ 0 ] self . cal_next = calibration_funcs [ 1 ] self . cal_repeat = calibration_funcs [ 2 ] self . cal_stop = calibration_funcs [ 3 ] self . cal_setlevel = calibration_funcs [ 4 ] self . create_widgets () self . finished = False","title":"__init__"},{"location":"api/ui/#app.ui.CalibrationPage.create_widgets","text":"create_widgets () Creates the widgets for the page. Source code in app\\ui.py 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 def create_widgets ( self ): \"\"\"Creates the widgets for the page. \"\"\" button_width = 25 self . intro = ttk . Label ( self , text = text_calibration , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . intro . pack ( padx = 10 , pady = 10 ) self . level_label = ttk . Label ( self , text = \"Wert in dBHL, bei dem kalibriert werden soll:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_label . pack ( padx = 10 , pady = 10 ) self . level_entry_var = tk . StringVar () self . level_entry_var . set ( \"10\" ) self . level_entry = ttk . Entry ( self , width = button_width - 10 , textvariable = self . level_entry_var ) self . level_entry . pack ( padx = 10 , pady = 10 ) self . start_button = ttk . Button ( self , text = \"Kalibrierung starten\" , command = self . start_calibration , width = button_width ) self . start_button . pack ( padx = 10 , pady = 10 ) self . next_button = ttk . Button ( self , text = \"N\u00e4chste Frequenz\" , command = self . next_frequency , width = button_width , state = tk . DISABLED ) self . next_button . pack ( padx = 10 , pady = 10 ) self . repeat_button = ttk . Button ( self , text = \"Erneut wiedergeben\" , command = self . repeat_frequency , width = button_width , state = tk . DISABLED ) self . repeat_button . pack ( padx = 10 , pady = 10 ) self . stop_button = ttk . Button ( self , text = \"Wiedergabe stoppen\" , command = self . stop_playing , width = button_width , state = tk . DISABLED ) self . stop_button . pack ( padx = 10 , pady = 10 ) self . back_button = ttk . Button ( self , text = \"Zur\u00fcck zum Hauptmen\u00fc\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) # TODO Kalibrierung resetten, damit man sie dann wieder von vorne anfangen kann self . back_button . pack ( padx = 10 , pady = 20 ) self . spacer_frame = tk . Frame ( self , width = 20 , height = 80 ) self . spacer_frame . pack () self . current_freq_var = tk . StringVar ( value = \"Aktuelle Frequenz:\" ) self . current_freq = ttk . Label ( self , textvariable = self . current_freq_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . current_freq . pack ( padx = 10 , pady = 10 ) self . level_expected_var = tk . StringVar ( value = \"Schalldruckpegel (soll):\" ) self . level_expected_label = ttk . Label ( self , textvariable = self . level_expected_var , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_expected_label . pack ( padx = 10 , pady = 10 ) self . level_measured_label = ttk . Label ( self , text = \"Gemessener Schalldruckpegel in dB:\" , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . level_measured_label . pack ( padx = 10 , pady = 10 ) self . level_measured_var = tk . StringVar () self . level_measured_entry = ttk . Entry ( self , width = button_width - 10 , font = ( FONT_FAMILY , SUBHEADER_SIZE ), state = tk . DISABLED , textvariable = self . level_measured_var ) self . level_measured_entry . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' )","title":"create_widgets"},{"location":"api/ui/#app.ui.DuringFamiliarizationView","text":"Bases: Frame Source code in app\\ui.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 class DuringFamiliarizationView ( ttk . Frame ): def __init__ ( self , parent , familiarization_func , progress_func ): \"\"\"View during familiarization process Args: parent (App): parent application familiarization_func (function): function to be called for familiarization\"\"\" super () . __init__ ( parent ) self . parent = parent self . program = familiarization_func self . get_progress = progress_func self . text = \"Eingew\u00f6hnung l\u00e4uft...\" self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the view \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 )","title":"DuringFamiliarizationView"},{"location":"api/ui/#app.ui.DuringFamiliarizationView.__init__","text":"__init__ ( parent , familiarization_func , progress_func ) View during familiarization process Parameters: parent ( App ) \u2013 parent application familiarization_func ( function ) \u2013 function to be called for familiarization Source code in app\\ui.py 485 486 487 488 489 490 491 492 493 494 495 496 def __init__ ( self , parent , familiarization_func , progress_func ): \"\"\"View during familiarization process Args: parent (App): parent application familiarization_func (function): function to be called for familiarization\"\"\" super () . __init__ ( parent ) self . parent = parent self . program = familiarization_func self . get_progress = progress_func self . text = \"Eingew\u00f6hnung l\u00e4uft...\" self . create_widgets ()","title":"__init__"},{"location":"api/ui/#app.ui.DuringFamiliarizationView.create_widgets","text":"create_widgets () Creates the widgets for the view Source code in app\\ui.py 499 500 501 502 503 504 505 506 def create_widgets ( self ): \"\"\"Creates the widgets for the view \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 )","title":"create_widgets"},{"location":"api/ui/#app.ui.DuringProcedureView","text":"Bases: Frame Source code in app\\ui.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 class DuringProcedureView ( ttk . Frame ): def __init__ ( self , parent , program_func , progress_func , text ): \"\"\"View during main program Args: parent (App): parent application program_func (function): function to be called for the main program text (str): text to be displayed \"\"\" super () . __init__ ( parent ) self . parent = parent self . program = program_func self . get_progress = progress_func self . text = text self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the view \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 )","title":"DuringProcedureView"},{"location":"api/ui/#app.ui.DuringProcedureView.__init__","text":"__init__ ( parent , program_func , progress_func , text ) View during main program Parameters: parent ( App ) \u2013 parent application program_func ( function ) \u2013 function to be called for the main program text ( str ) \u2013 text to be displayed Source code in app\\ui.py 511 512 513 514 515 516 517 518 519 520 521 522 523 524 def __init__ ( self , parent , program_func , progress_func , text ): \"\"\"View during main program Args: parent (App): parent application program_func (function): function to be called for the main program text (str): text to be displayed \"\"\" super () . __init__ ( parent ) self . parent = parent self . program = program_func self . get_progress = progress_func self . text = text self . create_widgets ()","title":"__init__"},{"location":"api/ui/#app.ui.DuringProcedureView.create_widgets","text":"create_widgets () Creates the widgets for the view Source code in app\\ui.py 527 528 529 530 531 532 533 534 def create_widgets ( self ): \"\"\"Creates the widgets for the view \"\"\" self . info = ttk . Label ( self , text = self . text ) self . info . pack ( padx = 10 , pady = 10 ) self . progress_var = tk . IntVar () self . progress_bar = ttk . Progressbar ( self , variable = self . progress_var , maximum = 100 , length = 300 ) self . progress_bar . pack ( padx = 10 , pady = 100 )","title":"create_widgets"},{"location":"api/ui/#app.ui.FamiliarizationPage","text":"Bases: Frame Source code in app\\ui.py 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 class FamiliarizationPage ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Page for starting the familiarization process. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the page \"\"\" button_width = 25 self . label = ttk . Label ( self , text = text_Familiarization , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . label . pack ( padx = 10 , pady = 10 ) self . play_button = ttk . Button ( self , text = \"Starte Eingew\u00f6hnung\" , command = self . run_familiarization , width = button_width ) self . play_button . pack ( padx = 10 , pady = 10 ) self . go_back_button = ttk . Button ( self , text = \"zur\u00fcck\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) self . go_back_button . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) def run_familiarization ( self ): \"\"\"Runs the familiarization process \"\"\" self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( DuringFamiliarizationView ) gender = self . parent . frames [ MainMenu ] . gender_dropdown . get () if gender == \"Geschlecht...\" or gender == \"Keine Angabe\" : gender = \"\" age = self . parent . frames [ MainMenu ] . age_entry . get () self . parent . wait_for_process ( lambda : self . parent . frames [ DuringFamiliarizationView ] . program ( id = self . parent . frames [ MainMenu ] . patient_number , calibrate = self . use_calibration , gender = gender , age = age ), lambda : self . parent . show_frame ( ProgramPage )) time . sleep ( 0.001 ) self . update () counter = 0 sleep_time = random . uniform ( 1 , 2.5 ) # random time in seconds between 1 and 2.5 to update progress bar while self . parent . frames [ DuringFamiliarizationView ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ DuringFamiliarizationView ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ DuringFamiliarizationView ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False","title":"FamiliarizationPage"},{"location":"api/ui/#app.ui.FamiliarizationPage.__init__","text":"__init__ ( parent ) Page for starting the familiarization process. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 359 360 361 362 363 364 365 366 367 def __init__ ( self , parent ): \"\"\"Page for starting the familiarization process. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets ()","title":"__init__"},{"location":"api/ui/#app.ui.FamiliarizationPage.create_widgets","text":"create_widgets () Creates the widgets for the page Source code in app\\ui.py 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 def create_widgets ( self ): \"\"\"Creates the widgets for the page \"\"\" button_width = 25 self . label = ttk . Label ( self , text = text_Familiarization , font = ( FONT_FAMILY , SUBHEADER_SIZE )) self . label . pack ( padx = 10 , pady = 10 ) self . play_button = ttk . Button ( self , text = \"Starte Eingew\u00f6hnung\" , command = self . run_familiarization , width = button_width ) self . play_button . pack ( padx = 10 , pady = 10 ) self . go_back_button = ttk . Button ( self , text = \"zur\u00fcck\" , command = lambda : self . parent . show_frame ( MainMenu ), width = button_width ) self . go_back_button . pack ( padx = 10 , pady = 10 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' )","title":"create_widgets"},{"location":"api/ui/#app.ui.FamiliarizationPage.run_familiarization","text":"run_familiarization () Runs the familiarization process Source code in app\\ui.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 def run_familiarization ( self ): \"\"\"Runs the familiarization process \"\"\" self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( DuringFamiliarizationView ) gender = self . parent . frames [ MainMenu ] . gender_dropdown . get () if gender == \"Geschlecht...\" or gender == \"Keine Angabe\" : gender = \"\" age = self . parent . frames [ MainMenu ] . age_entry . get () self . parent . wait_for_process ( lambda : self . parent . frames [ DuringFamiliarizationView ] . program ( id = self . parent . frames [ MainMenu ] . patient_number , calibrate = self . use_calibration , gender = gender , age = age ), lambda : self . parent . show_frame ( ProgramPage )) time . sleep ( 0.001 ) self . update () counter = 0 sleep_time = random . uniform ( 1 , 2.5 ) # random time in seconds between 1 and 2.5 to update progress bar while self . parent . frames [ DuringFamiliarizationView ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ DuringFamiliarizationView ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ DuringFamiliarizationView ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False","title":"run_familiarization"},{"location":"api/ui/#app.ui.MainMenu","text":"Bases: Frame Source code in app\\ui.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 class MainMenu ( ttk . Frame ): def __init__ ( self , parent ): super () . __init__ ( parent ) self . parent = parent self . button_width = 25 self . start_button = None self . binaural_test = tk . BooleanVar () self . use_calibration = tk . BooleanVar ( value = True ) self . selected_option = None self . patient_number = \"\" self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the page \"\"\" self . patient_number_label = ttk . Label ( self , text = \"Probandennummer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . patient_number_label . pack ( padx = 10 , pady = 10 ) self . patient_number_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . patient_number_entry . pack ( padx = 10 , pady = 10 ) self . gender_label = ttk . Label ( self , text = \"Geschlecht (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . gender_label . pack ( padx = 10 , pady = 10 ) self . gender_dropdown = ttk . Combobox ( self , values = [ \"M\u00e4nnlich\" , \"Weiblich\" , \"Divers\" , \"Keine Angabe\" ], state = \"readonly\" , width = self . button_width - 1 ) self . gender_dropdown . set ( \"Geschlecht...\" ) self . gender_dropdown . pack ( padx = 10 , pady = 10 ) self . age_label = ttk . Label ( self , text = \"Alter (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . age_label . pack ( padx = 10 , pady = 10 ) self . age_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . age_entry . pack ( padx = 10 , pady = 10 ) self . label = ttk . Label ( self , text = \" \\n Bitte w\u00e4hlen Sie ein Programm\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . label . pack ( pady = 10 ) # Dropdown menu options = list ( self . parent . program_funcs . keys ()) self . dropdown = ttk . Combobox ( self , values = options , state = \"readonly\" , width = self . button_width - 1 ) self . dropdown . set ( \"Test w\u00e4hlen...\" ) self . dropdown . pack ( pady = 10 ) self . dropdown . bind ( \"<<ComboboxSelected>>\" , self . on_option_selected ) self . binaural_button = ttk . Checkbutton ( self , text = \"Binaurale Testung\" , variable = self . binaural_test ) self . binaural_button . pack ( pady = 10 ) # Use calibration button self . cal_button = ttk . Checkbutton ( self , text = \"Werte aus letzter Kalibrierung verwenden\" , variable = self . use_calibration ) self . cal_button . pack ( pady = 10 , side = \"bottom\" ) # Headphone selection self . headphone_dropdown = ttk . Combobox ( self , values = self . get_headphone_options (), state = \"readonly\" , width = self . button_width - 1 ) self . headphone_dropdown . set ( \"Sennheiser_HDA200\" ) self . headphone_dropdown . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) self . headphone_label = ttk . Label ( self , text = \"Kopfh\u00f6rer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . headphone_label . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) def get_headphone_options ( self ): file_name = 'retspl.csv' # Check if the CSV file exists if not os . path . isfile ( file_name ): messagebox . showwarning ( \"Warnung\" , f 'Die Datei \" { file_name } \" konnte nicht gefunden werden.' ) return headphone_options = [] try : with open ( file_name , mode = 'r' ) as file : reader = csv . DictReader ( file ) for row in reader : headphone_options . append ( row [ 'headphone_model' ]) headphone_options = list ( set ( headphone_options )) return headphone_options except Exception as e : messagebox . showwarning ( \"Warnung\" , f 'Fehler beim Lesen der Datei \" { file_name } \": { e } ' ) return def on_option_selected ( self , event ): self . selected_option = self . dropdown . get () self . show_start_button () if self . selected_option == \"Kalibrierung\" : self . cal_button . config ( state = tk . DISABLED ) self . binaural_button . config ( state = tk . DISABLED ) self . gender_dropdown . config ( state = tk . DISABLED ) self . patient_number_entry . config ( state = tk . DISABLED ) else : self . cal_button . config ( state = tk . NORMAL ) self . binaural_button . config ( state = tk . NORMAL ) self . gender_dropdown . config ( state = tk . NORMAL ) self . patient_number_entry . config ( state = tk . NORMAL ) def show_start_button ( self ): if self . start_button is None : self . start_button = ttk . Button ( self , text = \"Test starten\" , command = self . go_to_next_page , width = self . button_width ) self . start_button . pack ( pady = 10 ) def go_to_next_page ( self ): if self . selected_option == \"Kalibrierung\" : self . parent . show_frame ( CalibrationPage ) else : self . patient_number = self . patient_number_entry . get () if not self . patient_number : messagebox . showwarning ( \"Warnung\" , \"Bitte geben Sie eine Probandennummer ein.\" ) return # check if valide age is entered if self . age_entry . get (): try : i = int ( self . age_entry . get ()) if i > 110 or i < 0 : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei Alter eine g\u00fcltige Zahl oder gar nichts ein.' ) return except : messagebox . showwarning ( \"Warnung\" , 'Bitte geben Sie bei Alter eine g\u00fcltige Zahl oder gar nichts ein.' ) return patient_folder = os . path . join ( self . parent . save_path , self . patient_number ) pics = self . parent . get_images_in_path ( patient_folder ) if pics : if messagebox . askyesno ( \"Proband vorhanden\" , \"F\u00fcr diese Probandennummer gibt es bereits Ergebnisse. M\u00f6chten Sie diese anzeigen?\" ): results_page = self . parent . frames [ ResultPage ] results_page . display_images ( self . patient_number ) self . parent . show_frame ( ResultPage ) return self . parent . show_frame ( FamiliarizationPage )","title":"MainMenu"},{"location":"api/ui/#app.ui.MainMenu.create_widgets","text":"create_widgets () Creates the widgets for the page Source code in app\\ui.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def create_widgets ( self ): \"\"\"Creates the widgets for the page \"\"\" self . patient_number_label = ttk . Label ( self , text = \"Probandennummer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . patient_number_label . pack ( padx = 10 , pady = 10 ) self . patient_number_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . patient_number_entry . pack ( padx = 10 , pady = 10 ) self . gender_label = ttk . Label ( self , text = \"Geschlecht (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . gender_label . pack ( padx = 10 , pady = 10 ) self . gender_dropdown = ttk . Combobox ( self , values = [ \"M\u00e4nnlich\" , \"Weiblich\" , \"Divers\" , \"Keine Angabe\" ], state = \"readonly\" , width = self . button_width - 1 ) self . gender_dropdown . set ( \"Geschlecht...\" ) self . gender_dropdown . pack ( padx = 10 , pady = 10 ) self . age_label = ttk . Label ( self , text = \"Alter (Optional):\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . age_label . pack ( padx = 10 , pady = 10 ) self . age_entry = ttk . Entry ( self , width = self . button_width + 1 ) self . age_entry . pack ( padx = 10 , pady = 10 ) self . label = ttk . Label ( self , text = \" \\n Bitte w\u00e4hlen Sie ein Programm\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . label . pack ( pady = 10 ) # Dropdown menu options = list ( self . parent . program_funcs . keys ()) self . dropdown = ttk . Combobox ( self , values = options , state = \"readonly\" , width = self . button_width - 1 ) self . dropdown . set ( \"Test w\u00e4hlen...\" ) self . dropdown . pack ( pady = 10 ) self . dropdown . bind ( \"<<ComboboxSelected>>\" , self . on_option_selected ) self . binaural_button = ttk . Checkbutton ( self , text = \"Binaurale Testung\" , variable = self . binaural_test ) self . binaural_button . pack ( pady = 10 ) # Use calibration button self . cal_button = ttk . Checkbutton ( self , text = \"Werte aus letzter Kalibrierung verwenden\" , variable = self . use_calibration ) self . cal_button . pack ( pady = 10 , side = \"bottom\" ) # Headphone selection self . headphone_dropdown = ttk . Combobox ( self , values = self . get_headphone_options (), state = \"readonly\" , width = self . button_width - 1 ) self . headphone_dropdown . set ( \"Sennheiser_HDA200\" ) self . headphone_dropdown . pack ( padx = 10 , pady = 10 , side = \"bottom\" ) self . headphone_label = ttk . Label ( self , text = \"Kopfh\u00f6rer:\" , font = ( FONT_FAMILY , TEXT_SIZE )) self . headphone_label . pack ( padx = 10 , pady = 10 , side = \"bottom\" )","title":"create_widgets"},{"location":"api/ui/#app.ui.ProgramPage","text":"Bases: Frame Source code in app\\ui.py 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 class ProgramPage ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Page for starting the main program. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . selected_option = None self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the page\"\"\" self . start_button = ttk . Button ( self , text = \"Starte Prozess\" , command = self . run_program ) self . start_button . pack ( padx = 10 , pady = 200 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' ) def run_program ( self ): \"\"\"Runs the main program\"\"\" self . selected_option = self . parent . frames [ MainMenu ] . selected_option self . binaural_test = self . parent . frames [ MainMenu ] . binaural_test . get () self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( self . selected_option ) self . parent . wait_for_process ( lambda : self . parent . frames [ self . selected_option ] . program ( self . binaural_test , calibrate = self . use_calibration ), self . show_results ) time . sleep ( 0.001 ) self . update () counter = 0 sleep_time = random . uniform ( 1 , 2.5 ) # random time in seconds between 1 and 2.5 to update progress bar while self . parent . frames [ self . selected_option ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ self . selected_option ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ self . selected_option ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False def show_results ( self ): \"\"\"Show the results page with the images\"\"\" patient_number = self . parent . frames [ MainMenu ] . patient_number results_page = self . parent . frames [ ResultPage ] results_page . display_images ( patient_number ) self . parent . show_frame ( ResultPage )","title":"ProgramPage"},{"location":"api/ui/#app.ui.ProgramPage.__init__","text":"__init__ ( parent ) Page for starting the main program. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 426 427 428 429 430 431 432 433 434 435 def __init__ ( self , parent ): \"\"\"Page for starting the main program. Args: parent (App): parent application \"\"\" super () . __init__ ( parent ) self . parent = parent self . selected_option = None self . create_widgets ()","title":"__init__"},{"location":"api/ui/#app.ui.ProgramPage.create_widgets","text":"create_widgets () Creates the widgets for the page Source code in app\\ui.py 438 439 440 441 442 443 444 def create_widgets ( self ): \"\"\"Creates the widgets for the page\"\"\" self . start_button = ttk . Button ( self , text = \"Starte Prozess\" , command = self . run_program ) self . start_button . pack ( padx = 10 , pady = 200 ) for widget in self . winfo_children (): widget . pack_configure ( anchor = 'center' )","title":"create_widgets"},{"location":"api/ui/#app.ui.ProgramPage.run_program","text":"run_program () Runs the main program Source code in app\\ui.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 def run_program ( self ): \"\"\"Runs the main program\"\"\" self . selected_option = self . parent . frames [ MainMenu ] . selected_option self . binaural_test = self . parent . frames [ MainMenu ] . binaural_test . get () self . use_calibration = self . parent . frames [ MainMenu ] . use_calibration . get () self . parent . show_frame ( self . selected_option ) self . parent . wait_for_process ( lambda : self . parent . frames [ self . selected_option ] . program ( self . binaural_test , calibrate = self . use_calibration ), self . show_results ) time . sleep ( 0.001 ) self . update () counter = 0 sleep_time = random . uniform ( 1 , 2.5 ) # random time in seconds between 1 and 2.5 to update progress bar while self . parent . frames [ self . selected_option ] . progress_var . get () < 100 and not self . parent . process_done : progress = int ( self . parent . frames [ self . selected_option ] . get_progress () * 100 ) if counter >= sleep_time * 1000 : self . parent . frames [ self . selected_option ] . progress_var . set ( progress ) counter = 0 time . sleep ( 0.001 ) counter += 1 self . update () self . parent . process_done = False","title":"run_program"},{"location":"api/ui/#app.ui.ProgramPage.show_results","text":"show_results () Show the results page with the images Source code in app\\ui.py 472 473 474 475 476 477 def show_results ( self ): \"\"\"Show the results page with the images\"\"\" patient_number = self . parent . frames [ MainMenu ] . patient_number results_page = self . parent . frames [ ResultPage ] results_page . display_images ( patient_number ) self . parent . show_frame ( ResultPage )","title":"show_results"},{"location":"api/ui/#app.ui.ResultPage","text":"Bases: Frame Source code in app\\ui.py 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 class ResultPage ( ttk . Frame ): def __init__ ( self , parent ): \"\"\"Page for showing the results of the program. Args: parent (App): parent application\"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets () def create_widgets ( self ): \"\"\"Creates the widgets for the view\"\"\" self . info = ttk . Label ( self , text = \"Ergebnisse\" , font = ( FONT_FAMILY , HEADER_SIZE )) self . info . pack ( padx = 10 , pady = 10 ) # Set the title on the parent window self . parent . title ( \"Audiogramm\" ) # Create a frame for the images self . image_frame = ttk . Frame ( self ) self . image_frame . pack ( anchor = \"center\" ) #,fill=\"both\", expand=True) # Button to go back to the main menu self . BackToMainMenu = ttk . Button ( self , text = \"Zur\u00fcck zur Startseite\" , command = lambda : self . parent . show_frame ( MainMenu )) self . BackToMainMenu . pack ( padx = 10 , pady = 10 ) def display_images ( self , folder_name ): \"\"\"Display all images in the given folder\"\"\" folder_path = os . path . join ( self . parent . save_path , folder_name ) for widget in self . image_frame . winfo_children (): widget . destroy () # TODO das muss viel sch\u00f6ner angezeigt werden, mittig, gro\u00df, Datum und Uhrzeit etc. ... pics = self . parent . get_images_in_path ( folder_path ) if pics : for file in pics : img = Image . open ( file ) #img = img.resize((400, 300), Image.LANCZOS) photo = ImageTk . PhotoImage ( img ) label = ttk . Label ( self . image_frame , image = photo ) label . image = photo label . pack ( padx = 10 , pady = 10 , side = \"left\" ) def back_to_MainMenu ( self ): self . parent . show_frame ( MainMenu )","title":"ResultPage"},{"location":"api/ui/#app.ui.ResultPage.__init__","text":"__init__ ( parent ) Page for showing the results of the program. Parameters: parent ( App ) \u2013 parent application Source code in app\\ui.py 539 540 541 542 543 544 545 546 547 548 def __init__ ( self , parent ): \"\"\"Page for showing the results of the program. Args: parent (App): parent application\"\"\" super () . __init__ ( parent ) self . parent = parent self . create_widgets ()","title":"__init__"},{"location":"api/ui/#app.ui.ResultPage.create_widgets","text":"create_widgets () Creates the widgets for the view Source code in app\\ui.py 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 def create_widgets ( self ): \"\"\"Creates the widgets for the view\"\"\" self . info = ttk . Label ( self , text = \"Ergebnisse\" , font = ( FONT_FAMILY , HEADER_SIZE )) self . info . pack ( padx = 10 , pady = 10 ) # Set the title on the parent window self . parent . title ( \"Audiogramm\" ) # Create a frame for the images self . image_frame = ttk . Frame ( self ) self . image_frame . pack ( anchor = \"center\" ) #,fill=\"both\", expand=True) # Button to go back to the main menu self . BackToMainMenu = ttk . Button ( self , text = \"Zur\u00fcck zur Startseite\" , command = lambda : self . parent . show_frame ( MainMenu )) self . BackToMainMenu . pack ( padx = 10 , pady = 10 )","title":"create_widgets"},{"location":"api/ui/#app.ui.ResultPage.display_images","text":"display_images ( folder_name ) Display all images in the given folder Source code in app\\ui.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 def display_images ( self , folder_name ): \"\"\"Display all images in the given folder\"\"\" folder_path = os . path . join ( self . parent . save_path , folder_name ) for widget in self . image_frame . winfo_children (): widget . destroy () # TODO das muss viel sch\u00f6ner angezeigt werden, mittig, gro\u00df, Datum und Uhrzeit etc. ... pics = self . parent . get_images_in_path ( folder_path ) if pics : for file in pics : img = Image . open ( file ) #img = img.resize((400, 300), Image.LANCZOS) photo = ImageTk . PhotoImage ( img ) label = ttk . Label ( self . image_frame , image = photo ) label . image = photo label . pack ( padx = 10 , pady = 10 , side = \"left\" )","title":"display_images"},{"location":"user_guide/hardware/","text":"Hardware Anforderungen \u00b6 1. Computer System \u00b6 Operating System : Windows 10 oder h\u00f6her, macOS Processor : Intel i5 oder gleichwertiger AMD processor oder h\u00f6her RAM : Mindestens 8 GB (16 GB recommended for optimal performance) Storage : 200 MB freier Festplattenspeicher f\u00fcr die Softwareinstallation, zus\u00e4tzlicher Speicherplatz f\u00fcr die Speicherung von Testergebnissen 2. Audio Interface \u00b6 Soundkarte : Hochwertige externe oder interne Soundkarte, die pr\u00e4zise Audioausgabe erm\u00f6glicht Kopfh\u00f6rer : Kalibrierte Koph\u00f6rer, empfohlen Sennheiser HDA 200. Auch unterst\u00fctzt: Beyer_DT_48, Sennheiser_HDA_280,RadioEar_DD_45,Telephonics_TDH_39 3. Display \u00b6 Monitor : Mindestaufl\u00f6sung von 1280 x 720; 1920 x 1080 oder h\u00f6her 4. Eingabeger\u00e4te \u00b6 Tastatur und Maus : Standardtastatur und Maus zur Navigation durch die GUI und zur Bereitstellung von Feedback. 5. Kalibrierungsausr\u00fcstung \u00b6 Kunstkopf oder akustischer Kuppler : Ein Kunstkopf oder ein akustischer Kuppler zur Messung und Kalibrierung der Ausgabelevel Hardware Requirements \u00b6 1. Computer System \u00b6 Operating System : Windows 10 or higher, macOS Processor : Intel i5 or equivalent AMD processor or higher RAM : 8 GB minimum (16 GB recommended for optimal performance) Storage : 200 MB of free disk space for software installation, additional space for storing test results 2. Audio Interface \u00b6 Sound Card : High-quality external or internal sound card capable of precise audio output Headphones : Calibrated headphones, such as Sennheiser HDA 200, for accurate frequency response Microphone (Optional) : For calibration purposes or voice commands 3. Display \u00b6 Monitor : Minimum resolution of 1280 x 720; 1920 x 1080 or higher recommended for better GUI experience 4. Input Devices \u00b6 Keyboard and Mouse : Standard keyboard and mouse for navigating the GUI and providing feedback 5. Calibration Equipment \u00b6 Head and Torso Simulator or acoustic coupler : An artificial head or an acoustic coupler for measuring and calibrating the output levels","title":"Hardware Requirements"},{"location":"user_guide/hardware/#hardware-anforderungen","text":"","title":"Hardware Anforderungen"},{"location":"user_guide/hardware/#1-computer-system","text":"Operating System : Windows 10 oder h\u00f6her, macOS Processor : Intel i5 oder gleichwertiger AMD processor oder h\u00f6her RAM : Mindestens 8 GB (16 GB recommended for optimal performance) Storage : 200 MB freier Festplattenspeicher f\u00fcr die Softwareinstallation, zus\u00e4tzlicher Speicherplatz f\u00fcr die Speicherung von Testergebnissen","title":"1. Computer System"},{"location":"user_guide/hardware/#2-audio-interface","text":"Soundkarte : Hochwertige externe oder interne Soundkarte, die pr\u00e4zise Audioausgabe erm\u00f6glicht Kopfh\u00f6rer : Kalibrierte Koph\u00f6rer, empfohlen Sennheiser HDA 200. Auch unterst\u00fctzt: Beyer_DT_48, Sennheiser_HDA_280,RadioEar_DD_45,Telephonics_TDH_39","title":"2. Audio Interface"},{"location":"user_guide/hardware/#3-display","text":"Monitor : Mindestaufl\u00f6sung von 1280 x 720; 1920 x 1080 oder h\u00f6her","title":"3. Display"},{"location":"user_guide/hardware/#4-eingabegerate","text":"Tastatur und Maus : Standardtastatur und Maus zur Navigation durch die GUI und zur Bereitstellung von Feedback.","title":"4. Eingabeger\u00e4te"},{"location":"user_guide/hardware/#5-kalibrierungsausrustung","text":"Kunstkopf oder akustischer Kuppler : Ein Kunstkopf oder ein akustischer Kuppler zur Messung und Kalibrierung der Ausgabelevel","title":"5. Kalibrierungsausr\u00fcstung"},{"location":"user_guide/hardware/#hardware-requirements","text":"","title":"Hardware Requirements"},{"location":"user_guide/hardware/#1-computer-system_1","text":"Operating System : Windows 10 or higher, macOS Processor : Intel i5 or equivalent AMD processor or higher RAM : 8 GB minimum (16 GB recommended for optimal performance) Storage : 200 MB of free disk space for software installation, additional space for storing test results","title":"1. Computer System"},{"location":"user_guide/hardware/#2-audio-interface_1","text":"Sound Card : High-quality external or internal sound card capable of precise audio output Headphones : Calibrated headphones, such as Sennheiser HDA 200, for accurate frequency response Microphone (Optional) : For calibration purposes or voice commands","title":"2. Audio Interface"},{"location":"user_guide/hardware/#3-display_1","text":"Monitor : Minimum resolution of 1280 x 720; 1920 x 1080 or higher recommended for better GUI experience","title":"3. Display"},{"location":"user_guide/hardware/#4-input-devices","text":"Keyboard and Mouse : Standard keyboard and mouse for navigating the GUI and providing feedback","title":"4. Input Devices"},{"location":"user_guide/hardware/#5-calibration-equipment","text":"Head and Torso Simulator or acoustic coupler : An artificial head or an acoustic coupler for measuring and calibrating the output levels","title":"5. Calibration Equipment"},{"location":"user_guide/installation/","text":"Installation \u00b6 Schnelle Installation mit venv \u00b6 Repository klonen: git clone https://github.com/Satur42/Audiometer.git cd Audiometer Virtuelle Umgebung erstellen: python -m venv venv Virtuelle Umgebung aktivieren: Auf Windows: venv\\Scripts\\activate Auf macOS und Linux:: source venv/bin/activate Ben\u00f6tigte Abh\u00e4ngigkeiten installieren: pip install -r requirements.txt Skript ausf\u00fchren: python run_app.py Installation \u00b6 Quick Installation with venv \u00b6 Clone the repository: git clone https://github.com/Satur42/Audiometer.git cd Audiometer Create a virtual environment: python -m venv venv Activate virtual environment: On Windows: venv\\Scripts\\activate On macOS and Linux:: source venv/bin/activate Install the required dependencies: pip install -r requirements.txt Run script: python run_app.py","title":"Installation"},{"location":"user_guide/installation/#installation","text":"","title":"Installation"},{"location":"user_guide/installation/#schnelle-installation-mit-venv","text":"Repository klonen: git clone https://github.com/Satur42/Audiometer.git cd Audiometer Virtuelle Umgebung erstellen: python -m venv venv Virtuelle Umgebung aktivieren: Auf Windows: venv\\Scripts\\activate Auf macOS und Linux:: source venv/bin/activate Ben\u00f6tigte Abh\u00e4ngigkeiten installieren: pip install -r requirements.txt Skript ausf\u00fchren: python run_app.py","title":"Schnelle Installation mit venv"},{"location":"user_guide/installation/#installation_1","text":"","title":"Installation"},{"location":"user_guide/installation/#quick-installation-with-venv","text":"Clone the repository: git clone https://github.com/Satur42/Audiometer.git cd Audiometer Create a virtual environment: python -m venv venv Activate virtual environment: On Windows: venv\\Scripts\\activate On macOS and Linux:: source venv/bin/activate Install the required dependencies: pip install -r requirements.txt Run script: python run_app.py","title":"Quick Installation with venv"},{"location":"user_guide/intro/","text":"Einleitung \u00b6 Willkommen zur Dokumentation des Audiometer-Projekts, das im Rahmen des \"Projekt Python und Akustik 2024\" an der Technischen Universit\u00e4t Berlin entwickelt wurde. Dieses Projekt zielt darauf ab, ein automatisiertes Audiometer zu programmieren, das die H\u00f6rf\u00e4higkeit von Probanden pr\u00e4zise und benutzerfreundlich ermittelt. Ein Audiometer ist ein diagnostisches Ger\u00e4t, das verwendet wird, um die H\u00f6rschwellen eines Menschen zu bestimmen. Es gibt verschiedene Methoden zur Durchf\u00fchrung von H\u00f6rtests, in diesem Projekt wurde das Einzelton-Verfahren mit ansteigendem Pegel, \u00fcber Kopfh\u00f6rer und ohne Verdeckung, realisiert. Dieses Verfahren ist gem\u00e4\u00df der DIN EN ISO 8253-1 normiert. Das Audiometer testet die Frequenzb\u00e4nder von 125 Hz bis 8000 Hz. Es wird als Output ein Audiogramm erstellt in welchem die H\u00f6rschwellen abgelesen werden k\u00f6nnen und eine CSV Datei gespeichert, die zur weiteren Verabeitung der Daten verwendet werden kann. Neben dem klassichen Audiometer-Testverfahren gibt es au\u00dferdem die M\u00f6glichkeit der binauralen Testung und eine Screening-Audiometrie. Zudem wird eine Eingew\u00f6hnung des Probanden durch eine Einweisung und einen Testlauf im Frequenzband von 1000 Hz durchgef\u00fchrt, um sicherzustellen, dass der Proband den Testablauf verstanden hat. Grunds\u00e4tzlich ist das Programm so konzipiert, dass es \u00fcber die GUI selbst\u00e4ndig vom Probanden durchgef\u00fchrt werden kann. Wir empfehlen jedoch eine Betreuung von Fachkundigen um validierte Ergebnisse zu erhalten. Es ist zu beachten, dass diese computergesteuerte Audiometer nur dazu dient, Ihr H\u00f6rverm\u00f6gen zu beurteilen, und eine genaue Diagnose durch einen Facharzt nicht ersetzt. F\u00fcr eine genauere Diagnose konsultieren Sie bitte Ihren Arzt. Introduction \u00b6 Welcome to the documentation of the audiometer project, which was developed as part of the \"Project Python and Acoustics 2024\" at the Technical University of Berlin. This project aims to programme an automated audiometer that determines the hearing ability of test persons in a precise and user-friendly way. An audiometer is a diagnostic device that is used to determine a person's hearing thresholds. There are various methods for carrying out hearing tests; in this project, the single-tone method with increasing level, via headphones and without masking, was realised. This method is standardised in accordance with DIN EN ISO 8253-1. The audiometer tests the frequency bands from 125 Hz to 8000 Hz. The output is an audiogram in which the hearing thresholds can be read and a CSV file is saved, which can be used for further processing of the data. In addition to the classic audiometer test procedure, there is also the option of binaural testing and screening audiometry. In addition, the respondent is familiarised with the programme by means of a briefing and a test run in the 1000 Hz frequency band to ensure that the respondent has understood the test procedure. In principle, the programme is designed so that it can be carried out independently by the respondent using the GUI. However, we recommend supervision by a specialist in order to obtain validated results. Please note that this computerised audiometer is only intended to assess your hearing and does not replace an accurate diagnosis by a specialist. For a more accurate diagnosis, please consult your doctor. Installation Hardware Requirements","title":"Introduction"},{"location":"user_guide/intro/#einleitung","text":"Willkommen zur Dokumentation des Audiometer-Projekts, das im Rahmen des \"Projekt Python und Akustik 2024\" an der Technischen Universit\u00e4t Berlin entwickelt wurde. Dieses Projekt zielt darauf ab, ein automatisiertes Audiometer zu programmieren, das die H\u00f6rf\u00e4higkeit von Probanden pr\u00e4zise und benutzerfreundlich ermittelt. Ein Audiometer ist ein diagnostisches Ger\u00e4t, das verwendet wird, um die H\u00f6rschwellen eines Menschen zu bestimmen. Es gibt verschiedene Methoden zur Durchf\u00fchrung von H\u00f6rtests, in diesem Projekt wurde das Einzelton-Verfahren mit ansteigendem Pegel, \u00fcber Kopfh\u00f6rer und ohne Verdeckung, realisiert. Dieses Verfahren ist gem\u00e4\u00df der DIN EN ISO 8253-1 normiert. Das Audiometer testet die Frequenzb\u00e4nder von 125 Hz bis 8000 Hz. Es wird als Output ein Audiogramm erstellt in welchem die H\u00f6rschwellen abgelesen werden k\u00f6nnen und eine CSV Datei gespeichert, die zur weiteren Verabeitung der Daten verwendet werden kann. Neben dem klassichen Audiometer-Testverfahren gibt es au\u00dferdem die M\u00f6glichkeit der binauralen Testung und eine Screening-Audiometrie. Zudem wird eine Eingew\u00f6hnung des Probanden durch eine Einweisung und einen Testlauf im Frequenzband von 1000 Hz durchgef\u00fchrt, um sicherzustellen, dass der Proband den Testablauf verstanden hat. Grunds\u00e4tzlich ist das Programm so konzipiert, dass es \u00fcber die GUI selbst\u00e4ndig vom Probanden durchgef\u00fchrt werden kann. Wir empfehlen jedoch eine Betreuung von Fachkundigen um validierte Ergebnisse zu erhalten. Es ist zu beachten, dass diese computergesteuerte Audiometer nur dazu dient, Ihr H\u00f6rverm\u00f6gen zu beurteilen, und eine genaue Diagnose durch einen Facharzt nicht ersetzt. F\u00fcr eine genauere Diagnose konsultieren Sie bitte Ihren Arzt.","title":"Einleitung"},{"location":"user_guide/intro/#introduction","text":"Welcome to the documentation of the audiometer project, which was developed as part of the \"Project Python and Acoustics 2024\" at the Technical University of Berlin. This project aims to programme an automated audiometer that determines the hearing ability of test persons in a precise and user-friendly way. An audiometer is a diagnostic device that is used to determine a person's hearing thresholds. There are various methods for carrying out hearing tests; in this project, the single-tone method with increasing level, via headphones and without masking, was realised. This method is standardised in accordance with DIN EN ISO 8253-1. The audiometer tests the frequency bands from 125 Hz to 8000 Hz. The output is an audiogram in which the hearing thresholds can be read and a CSV file is saved, which can be used for further processing of the data. In addition to the classic audiometer test procedure, there is also the option of binaural testing and screening audiometry. In addition, the respondent is familiarised with the programme by means of a briefing and a test run in the 1000 Hz frequency band to ensure that the respondent has understood the test procedure. In principle, the programme is designed so that it can be carried out independently by the respondent using the GUI. However, we recommend supervision by a specialist in order to obtain validated results. Please note that this computerised audiometer is only intended to assess your hearing and does not replace an accurate diagnosis by a specialist. For a more accurate diagnosis, please consult your doctor. Installation Hardware Requirements","title":"Introduction"}]}